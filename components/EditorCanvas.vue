<script setup lang="ts">
import { onMounted, onUnmounted, ref, shallowRef, watch, watchEffect, triggerRef, computed, nextTick, defineAsyncComponent } from 'vue'
import { useRuntimeConfig } from '#imports'
import ContextMenu from './ui/ContextMenu.vue'
import CanvasRulers from './ui/CanvasRulers.vue'
import { useFigmaCrop } from '~/composables/useFigmaCrop'
import { useProductZone } from '~/composables/useProductZone'
import { useAiImageStudio } from '~/composables/useAiImageStudio'
import { toWasabiProxyUrl } from '~/utils/storageProxy'
import { finalizeSerializedCanvasJson } from '~/utils/editorCanvasSerialize'
import { prepareCanvasForSerialization } from '~/utils/editorCanvasPreSerialize'
import { appendHistoryEntry } from '~/utils/editorHistoryState'
import { registerHistorySaveListeners } from '~/utils/editorHistoryListeners'
import { applyHistoryStateToCanvas } from '~/utils/editorHistoryApply'
import {
    findPreparedNonEmptyHistoryState,
    prepareHistoryStateFromString
} from '~/utils/editorHistoryNavigation'
import { findPageIndexById } from '~/utils/editorPageLookup'
import { persistSerializedPageState } from '~/utils/editorPagePersistence'
import { generateThumbnailFromCanvasJson } from '~/utils/editorThumbnail'
import {
    downloadFile,
    downloadMultipleFiles,
    shareFileFromDataUrl
} from '~/utils/editorFileTransfer'
import {
    fastHashString,
    getSavedViewportTransform,
    setSavedViewportTransform
} from '~/utils/editorCanvasState'
import {
    canGenerateThumbnailNow,
    canAllowEmptyOverwrite,
    getAdaptiveCoalesceDelayMs,
    shouldRunHeavySanitizeForReason,
    shouldSkipAutoSave,
    shouldSkipByFingerprint,
    shouldSkipLifecycleSave
} from '~/utils/editorSavePolicy'
import {
    getTextSelectionRange,
    isTextStyleObject,
    snapshotForPropertiesPanel,
    TEXT_OBJECT_STYLE_PROPS,
    TEXT_SELECTION_STYLE_PROPS
} from '~/utils/editorSelectionSnapshot'
import {
    applySelectionTextStyle,
    convertStaticTextToIText
} from '~/utils/editorSelectionTextOps'
import {
    buildSelectionSyncPayload,
    getSelectedObjectFloatingPos,
    refreshSelectedRefWithRecovery,
    syncSelectionDomainState
} from '~/utils/editorSelectionRuntime'
import type { LabelTemplate } from '~/types/label-template'
import { applyAiToPage } from '~/src/ai/aiApplyToProject'

const LayersPanel = defineAsyncComponent(() => import('./LayersPanel.vue'))
const ProjectManager = defineAsyncComponent(() => import('./ProjectManager.vue'))
const SidebarLeft = defineAsyncComponent(() => import('./SidebarLeft.vue'))
const AiImageStudioModal = defineAsyncComponent(() => import('./AiImageStudioModal.vue'))
const CanvasFloatingToolbar = defineAsyncComponent(() => import('./CanvasFloatingToolbar.vue'))
const PenContextualToolbar = defineAsyncComponent(() => import('./PenContextualToolbar.vue'))
const FrameLabelsOverlay = defineAsyncComponent(() => import('./FrameLabelsOverlay.vue'))
const EditorModalsHost = defineAsyncComponent(() => import('./EditorModalsHost.vue'))
const EditorRightSidebar = defineAsyncComponent(() => import('./EditorRightSidebar.vue'))
import {
  Undo,
  Redo,
  Save,
  Circle,
  Triangle,
  Download,
  Search,
  Play,
  ChevronsUp,
  ChevronsDown,
  ArrowUp,
  ArrowDown,
  Tag,
  Frame, // New Icon
  Group, // Group icon
  Ungroup, // Ungroup icon
} from 'lucide-vue-next'

const isDrawing = ref(false)
const isNodeEditing = ref(false)
const isPenMode = ref(false) // Pen Tool mode (vector path creation)
const fileInput = ref<HTMLInputElement | null>(null)
const pendingImageReplaceTargetId = ref<string | null>(null)
const pendingImageAddCardId = ref<string | null>(null)
const pendingLocalImageActionMode = ref<'replace' | 'add' | null>(null)
const penPathPoints = ref<Array<{x: number, y: number, handles?: {in: {x: number, y: number}, out: {x: number, y: number}}}>>([])
const currentPenPath = ref<any>(null) // Current path being created
const currentPenPoint = ref<any>(null) // Current point circle
const currentMousePos = ref<{x: number, y: number} | null>(null) // Current mouse position in pen mode
const penStrokeWidth = ref(3) // Vector Pen default stroke width
const showPenContextualToolbar = ref(false)
const selectedPathNodeIndex = ref<number | null>(null) // Selected node index during editing
const currentEditingPath = ref<any>(null) // Path object currently being edited
const activeMode = ref<'design' | 'prototype'>('design')
const showZoomMenu = ref(false)
let globalMouseUpHandler: ((e: MouseEvent) => void) | null = null
let globalEscKeyHandler: ((e: KeyboardEvent) => void) | null = null
let globalKeyUpHandler: ((e: KeyboardEvent) => void) | null = null
let teardownSnapping: (() => void) | null = null
let domCanvasDblClickHandler: ((e: MouseEvent) => void) | null = null
let domCanvasTouchStartHandler: ((e: TouchEvent) => void) | null = null
let domCanvasTouchMoveHandler: ((e: TouchEvent) => void) | null = null
let domCanvasTouchEndHandler: ((e: TouchEvent) => void) | null = null
let domCanvasTouchCancelHandler: ((e: TouchEvent) => void) | null = null
let lastDomDblClickAt = 0
let wrapperResizeObserver: ResizeObserver | null = null
let isSpacePanPressed = false
let keyboardNudgeDirty = false
let globalStylesSaveTimer: ReturnType<typeof setTimeout> | null = null
let viewportStateSaveTimer: ReturnType<typeof setTimeout> | null = null

// Flag to track if canvas is destroyed (prevents errors after unmount)
const isCanvasDestroyed = ref(false)

// === AI Image Studio (global modal) ===
const aiStudio = useAiImageStudio()
const aiStudioOpen = aiStudio.open
const aiStudioOptions = aiStudio.options
const aiStudioUploads = ref<Array<{ id: string; name: string; url: string }>>([])
const showProductImageUploadPicker = ref(false)
const productImagePickerMode = ref<'replace' | 'add'>('replace')
const productImagePickerSearch = ref('')
const productImagePickerTargetImageId = ref<string | null>(null)
const productImagePickerTargetCardId = ref<string | null>(null)

// === Figma-style Crop Overlay ===
const figmaCrop = useFigmaCrop()

// Handlers para eventos do crop overlay
const handleCropRectUpdate = (rect: { x: number; y: number; width: number; height: number }) => {
    figmaCrop.updateCropRect(rect)
}

const handleCropComplete = (rect: { x: number; y: number; width: number; height: number }) => {
    figmaCrop.applyCrop(rect)
    canvas.value?.requestRenderAll()
    saveCurrentState?.()
}

// Offset do canvas para posicionar o overlay corretamente
const cropCanvasOffset = computed(() => {
    if (!wrapperEl.value) return { x: 0, y: 0 }
    const rect = wrapperEl.value.getBoundingClientRect()
    return {
        x: rect.left,
        y: rect.top
    }
})

// Zoom level para o overlay
const zoom = ref(1)

const refreshAiStudioUploads = async () => {
    try {
        const headers = await getApiAuthHeaders()
        const data: any = await $fetch('/api/assets', { headers, query: { limit: 80 } }).catch(() => [])
        if (Array.isArray(data)) {
            aiStudioUploads.value = data.map((a: any) => ({ id: a.id, name: a.name, url: a.url }))
        }
    } catch (e) {
        console.warn('[ai-studio] Falha ao carregar uploads:', e)
    }
}

const normalizeImageSearch = (value: string) => String(value || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .trim();

const filteredProductImageUploads = computed(() => {
    const list = Array.isArray(aiStudioUploads.value) ? aiStudioUploads.value : [];
    const q = normalizeImageSearch(productImagePickerSearch.value);
    if (!q) return list;
    return list.filter((item: any) => {
        const hay = normalizeImageSearch(`${item?.name || ''} ${item?.id || ''} ${item?.url || ''}`);
        return hay.includes(q);
    });
});

const guessAiSizeFromObject = (obj: any): '1024x1024' | '1024x1536' | '1536x1024' => {
    const w = Math.max(1, Number(obj?.getScaledWidth?.() ?? ((obj?.width || 1) * (obj?.scaleX || 1))) || 1)
    const h = Math.max(1, Number(obj?.getScaledHeight?.() ?? ((obj?.height || 1) * (obj?.scaleY || 1))) || 1)
    const ar = w / h
    if (ar > 1.15) return '1536x1024'
    if (ar < 0.87) return '1024x1536'
    return '1024x1024'
}

const findImageTargetInSelection = (obj: any): { img: any; parent: any | null } | null => {
    if (!obj) return null
    const t = String(obj.type || '').toLowerCase()
    if (t === 'image') return { img: obj, parent: null }
    if (t === 'group' || t === 'activeselection') {
        const list = typeof obj.getObjects === 'function' ? obj.getObjects() : []
        const img = (list || []).find((o: any) => String(o?.type || '').toLowerCase() === 'image')
        return img ? { img, parent: obj } : null
    }
    return null
}

const getPreferredProductImageFromGroup = (group: any): any | null => {
    if (!group || typeof group.getObjects !== 'function') return null;
    const list = group.getObjects() || [];
    const preferred = list.find((o: any) => {
        if (String(o?.type || '').toLowerCase() !== 'image') return false;
        const n = String(o?.name || '').trim();
        return n === 'smart_image' || n === 'product_image' || n === 'productImage';
    });
    if (preferred) return preferred;
    return list.find((o: any) => String(o?.type || '').toLowerCase() === 'image') || null;
};

const resolveSelectedProductCardContext = (active: any): { card: any | null; image: any | null } => {
    if (!active) return { card: null, image: null };

    if (isProductCardContainer(active)) {
        return { card: active, image: getPreferredProductImageFromGroup(active) };
    }

    const t = String(active.type || '').toLowerCase();
    if (t === 'image') {
        const parentCard = findProductCardParentGroup(active);
        return { card: parentCard, image: active };
    }

    const directParentCard = findProductCardParentGroup(active);
    if (directParentCard) {
        return { card: directParentCard, image: t === 'image' ? active : getPreferredProductImageFromGroup(directParentCard) };
    }

    if (t === 'activeselection' && typeof active.getObjects === 'function') {
        const list = active.getObjects() || [];
        for (const member of list) {
            if (isProductCardContainer(member)) {
                return { card: member, image: getPreferredProductImageFromGroup(member) };
            }
            const card = findProductCardParentGroup(member);
            if (card) {
                const mt = String(member?.type || '').toLowerCase();
                const image = mt === 'image' ? member : getPreferredProductImageFromGroup(card);
                return { card, image };
            }
        }
    }

    return { card: null, image: null };
};

/**
 * Safe wrapper for requestRenderAll that checks if canvas is valid before rendering.
 * Prevents "Cannot read properties of undefined" errors when canvas is disposed.
 */
const safeRequestRenderAll = (canvasInstance?: any): void => {
    const c = canvasInstance || canvas.value;
    if (!c || isCanvasDestroyed.value) return;
    if (typeof c.requestRenderAll !== 'function') return;

    const ensureFabricContexts = (fc: any): boolean => {
        try {
            // In some edge cases (fast drag / mouseup outside / resize), Fabric can lose its cached contexts.
            // If we just skip render, the lower canvas stays cleared (appears black). Rehydrate from DOM elements.
            if (fc.upperCanvasEl && (!fc.contextTop || typeof fc.contextTop.clearRect !== 'function')) {
                const ctxTop = fc.upperCanvasEl.getContext?.('2d');
                if (ctxTop) fc.contextTop = ctxTop;
            }
            if (fc.lowerCanvasEl && (!fc.contextContainer || typeof fc.contextContainer.clearRect !== 'function')) {
                const ctx = fc.lowerCanvasEl.getContext?.('2d');
                if (ctx) fc.contextContainer = ctx;
            }
            // Some Fabric builds also keep a direct `context` alias.
            if (!fc.context && fc.contextContainer) fc.context = fc.contextContainer;
            return !!(fc.contextContainer && typeof fc.contextContainer.clearRect === 'function');
        } catch {
            return false;
        }
    };

    try {
        if (!ensureFabricContexts(c)) return;
        c.requestRenderAll();
    } catch {
        // As a last resort, attempt a synchronous render.
        try {
            if (typeof c.renderAll === 'function') c.renderAll();
        } catch {
            // Ignore
        }
    }
};

// Hardens Fabric render calls to avoid the editor going black when something
// unexpected sneaks into internal `_objects` arrays (canvas/group/clipPath).
const patchCanvasRenderSafety = (c: any): void => {
    if (!c || (c as any).__patchedSafeRender) return;

    const isValidRenderable = (o: any) => {
        return !!(o && typeof o === 'object' && typeof o.render === 'function' && typeof o.setCoords === 'function');
    };

    const ensureFabricContexts = (fc: any): boolean => {
        try {
            if (fc.upperCanvasEl && (!fc.contextTop || typeof fc.contextTop.clearRect !== 'function')) {
                const ctxTop = fc.upperCanvasEl.getContext?.('2d');
                if (ctxTop) fc.contextTop = ctxTop;
            }
            if (fc.lowerCanvasEl && (!fc.contextContainer || typeof fc.contextContainer.clearRect !== 'function')) {
                const ctx = fc.lowerCanvasEl.getContext?.('2d');
                if (ctx) fc.contextContainer = ctx;
            }
            if (!fc.context && fc.contextContainer) fc.context = fc.contextContainer;
            return !!(fc.contextContainer && typeof fc.contextContainer.clearRect === 'function');
        } catch {
            return false;
        }
    };

    const purgeInvalidRecursive = (container: any): number => {
        if (!container) return 0;
        const internal = (container as any)._objects;
        let removed = 0;
        if (Array.isArray(internal)) {
            const before = internal.length;
            const valid = internal.filter(isValidRenderable);
            if (valid.length !== before) {
                internal.length = 0;
                valid.forEach((o: any) => internal.push(o));
                removed += (before - valid.length);
                if (typeof (container as any)._onStackOrderChanged === 'function') (container as any)._onStackOrderChanged();
                if (typeof (container as any).triggerLayout === 'function') (container as any).triggerLayout();
                if (typeof (container as any).setCoords === 'function') (container as any).setCoords();
                (container as any).dirty = true;
            }
            for (const child of internal) {
                // Clean invalid clipPaths (common crash source)
                try {
                    if (child?.clipPath) clearInvalidClipPath(child, true);
                } catch {
                    // ignore
                }
                if (child && Array.isArray((child as any)._objects)) {
                    removed += purgeInvalidRecursive(child);
                }
                // Some clipPaths are groups internally
                try {
                    const cp = child?.clipPath;
                    if (cp && Array.isArray((cp as any)._objects)) {
                        removed += purgeInvalidRecursive(cp);
                    }
                } catch {
                    // ignore
                }
            }
        }
        return removed;
    };

    const origRequest = typeof c.requestRenderAll === 'function' ? c.requestRenderAll.bind(c) : null;
    const origRender = typeof c.renderAll === 'function' ? c.renderAll.bind(c) : null;

    // FIX FLICKERING: Não rodar purgeInvalidRecursive em CADA render.
    // purgeInvalidRecursive varre todos os objetos recursivamente (incluindo clipPaths),
    // o que é pesado e causa flickering visível. Agora só roda como fallback após erro.
    // PERFORMANCE: Cache context validity — only re-check every 500ms or after error.
    let contextsValid = true;
    let lastContextCheck = 0;
    const CONTEXT_CHECK_INTERVAL = 500; // ms
    let renderRafId: number | null = null;

    const checkContextsIfNeeded = (): boolean => {
        const now = performance.now();
        if (contextsValid && (now - lastContextCheck) < CONTEXT_CHECK_INTERVAL) return true;
        contextsValid = ensureFabricContexts(c);
        lastContextCheck = now;
        return contextsValid;
    };

    const scheduleRenderWork = (work: () => void) => {
        if (typeof window === 'undefined') {
            work();
            return;
        }
        if (renderRafId !== null) return;
        renderRafId = requestAnimationFrame(() => {
            renderRafId = null;
            work();
        })
    };

    if (origRequest) {
        (c as any).__origRequestRenderAll = origRequest;
        c.requestRenderAll = () => {
            if (!checkContextsIfNeeded()) return;
            scheduleRenderWork(() => {
                try {
                    origRequest();
                } catch (e) {
                    // Render falhou — invalidar cache, purgar objetos inválidos e tentar novamente
                    contextsValid = false;
                    try {
                        purgeInvalidRecursive(c);
                    } catch {
                        // ignore
                    }
                    try {
                        if (origRender) origRender();
                    } catch {
                        // ignore
                    }
                }
            });
            return;
        };
    }

    if (origRender) {
        (c as any).__origRenderAll = origRender;
        c.renderAll = () => {
            if (!checkContextsIfNeeded()) return;
            try {
                return origRender();
            } catch {
                // Render falhou — invalidar cache, purgar e tentar novamente
                contextsValid = false;
                try {
                    purgeInvalidRecursive(c);
                } catch {
                    // ignore
                }
                try {
                    return origRender();
                } catch {
                    // ignore
                }
            }
        };
    }

    (c as any).__patchedSafeRender = true;
};

const ensureCanvasContextsReady = (fc: any): boolean => {
    if (!fc || isCanvasDestroyed.value) return false;
    try {
        if (fc.upperCanvasEl && (!fc.contextTop || typeof fc.contextTop.clearRect !== 'function')) {
            const ctxTop = fc.upperCanvasEl.getContext?.('2d');
            if (ctxTop) fc.contextTop = ctxTop;
        }
        const lowerEl = fc.lowerCanvasEl || fc.getElement?.();
        if (lowerEl && (!fc.contextContainer || typeof fc.contextContainer.clearRect !== 'function')) {
            const ctx = lowerEl.getContext?.('2d');
            if (ctx) fc.contextContainer = ctx;
        }
        if (!fc.context && fc.contextContainer) fc.context = fc.contextContainer;
        return !!(fc.contextContainer && typeof fc.contextContainer.clearRect === 'function');
    } catch {
        return false;
    }
};

const isCanvasContextError = (err: any): boolean => {
    const msg = String(err?.message || err || '').toLowerCase();
    return msg.includes('clearrect') || msg.includes('contextcontainer') || msg.includes('getcontext');
};

const loadFromJsonSafe = async (json: any): Promise<void> => {
    const c = canvas.value as any;
    if (!c || isCanvasDestroyed.value) {
        throw new Error('Canvas indisponível para loadFromJSON');
    }
    if (!ensureCanvasContextsReady(c)) {
        throw new Error('Contexto do canvas indisponível para loadFromJSON');
    }

    const prevRenderOnAddRemove = c.renderOnAddRemove;
    c.renderOnAddRemove = false;
    try {
        await c.loadFromJSON(json);
    } catch (err: any) {
        if (!isCanvasContextError(err) || isCanvasDestroyed.value) throw err;
        if (!ensureCanvasContextsReady(c)) throw err;
        await c.loadFromJSON(json);
    } finally {
        c.renderOnAddRemove = prevRenderOnAddRemove;
        // Re-apply runtime-only properties for persistent user guides after any load.
        try { normalizeUserGuides(c); } catch {}
        safeRequestRenderAll(c);
    }
};

/**
 * Validates if a clipPath is a valid Fabric.js object
 * A valid clipPath must have required Fabric methods and properties
 */
const isValidClipPath = (clipPath: any): boolean => {
    if (!clipPath) return false;

    // Must be an object
    if (typeof clipPath !== 'object' || Array.isArray(clipPath)) return false;

    // Must have Fabric-specific properties
    if (!clipPath.type) return false;

    // CRITICAL: _objects must ALWAYS be an array if it exists
    // fabric.js createClipPathLayer calls forEach on _objects
    if (clipPath._objects !== undefined && !Array.isArray(clipPath._objects)) {
        console.warn('[clipPath] _objects não é um array:', clipPath._objects);
        return false;
    }

    // Ensure _objects is initialized as empty array for group-like objects
    // This prevents "forEach of undefined" errors in fabric.js
    if (clipPath._objects === undefined &&
        (clipPath.type === 'group' || clipPath.type === 'activeSelection')) {
        console.warn('[clipPath] Group sem _objects array:', clipPath.type);
        return false;
    }

    // Must have render method
    if (typeof clipPath.render !== 'function') return false;

    // RECURSIVELY validate nested clipPaths
    if (clipPath.clipPath && !isValidClipPath(clipPath.clipPath)) {
        console.warn('[clipPath] clipPath aninhado inválido');
        return false;
    }

    // Validate all child objects have proper _objects arrays
    if (Array.isArray(clipPath._objects)) {
        for (const child of clipPath._objects) {
            if (child && child._objects !== undefined && !Array.isArray(child._objects)) {
                console.warn('[clipPath] Child com _objects inválido:', child.type);
                return false;
            }
            // Check nested clipPath on child
            if (child && child.clipPath && !isValidClipPath(child.clipPath)) {
                console.warn('[clipPath] Child com clipPath aninhado inválido');
                return false;
            }
        }
    }

    return true;
};

/**
 * Clears invalid clipPath from an object
 * @param obj - Fabric object to check
 * @param recursive - Whether to check children in groups
 */
const clearInvalidClipPath = (obj: any, recursive: boolean = false): void => {
    if (!obj) return;

    try {
        // First, fix any clipPath that has malformed _objects
        if (obj.clipPath) {
            const clip = obj.clipPath;
            // CRITICAL FIX: Ensure _objects is ALWAYS an array for clipPaths
            // fabric.js createClipPathLayer calls forEach on _objects without checking
            if (clip._objects === undefined || clip._objects === null) {
                clip._objects = [];
            } else if (!Array.isArray(clip._objects)) {
                console.warn('[clipPath] _objects não é um array em:', obj.type || 'unknown', '- removendo clipPath');
                obj.set('clipPath', null);
                if (obj._frameClipOwner) {
                    delete obj._frameClipOwner;
                }
                return;
            }
            // Also fix nested clipPath
            if (clip.clipPath) {
                if (clip.clipPath._objects === undefined || clip.clipPath._objects === null) {
                    clip.clipPath._objects = [];
                } else if (!Array.isArray(clip.clipPath._objects)) {
                    obj.set('clipPath', null);
                    if (obj._frameClipOwner) {
                        delete obj._frameClipOwner;
                    }
                    return;
                }
            }
        }

        // Check if object has an invalid clipPath (after fixing attempt)
        if (obj.clipPath && !isValidClipPath(obj.clipPath)) {
            console.warn('[clipPath] Removendo clipPath inválido de objeto:', obj.type || 'unknown', obj.id || 'no-id');
            obj.set('clipPath', null);

            // Also clear the frame owner reference if it exists
            if (obj._frameClipOwner) {
                delete obj._frameClipOwner;
            }
        }

        // Also check and fix malformed _objects arrays on the object itself
        // This happens when fabric.js objects are deserialized incorrectly
        if (obj._objects !== undefined && !Array.isArray(obj._objects)) {
            console.warn('[clipPath] Fixing _objects não-array em:', obj.type || 'unknown');
            obj._objects = [];
        }

        // Recursively check children in groups
        if (recursive && obj._objects && Array.isArray(obj._objects)) {
            obj._objects.forEach((child: any) => {
                clearInvalidClipPath(child, true);
            });
        }

        // Also check objects in groups via getObjects if available
        if (recursive && typeof obj.getObjects === 'function') {
            const children = obj.getObjects();
            if (Array.isArray(children)) {
                children.forEach((child: any) => {
                    clearInvalidClipPath(child, true);
                });
            }
        }
    } catch (e) {
        // Silently handle errors during clipPath clearing
        console.warn('[clipPath] Erro ao limpar clipPath:', e);
    }
};

/**
 * Validates and sanitizes all clipPaths in the canvas.
 * Should be called after loadFromJSON and before any render operations.
 */
const sanitizeAllClipPaths = (): void => {
    if (!canvas.value || isCanvasDestroyed.value) return;

    try {
        const objects = canvas.value.getObjects();
        objects.forEach((obj: any) => {
            clearInvalidClipPath(obj, true);
        })
    } catch (e) {
        console.warn('⚠️ Erro ao sanitizar clipPaths:', e);
    }
};

/**
 * Nuclear option: Removes ALL clipPaths from the canvas.
 * Use this as a last resort when sanitization fails and rendering still crashes.
 */
const removeAllClipPaths = (): void => {
    if (!canvas.value || isCanvasDestroyed.value) return;

    try {
        const objects = canvas.value.getObjects();
        let clearedCount = 0;
        objects.forEach((obj: any) => {
            if (obj.clipPath) {
                obj.set('clipPath', null);
                delete obj._frameClipOwner;
                clearedCount++;
            }
            // Also check nested objects in groups
            if (obj._objects && Array.isArray(obj._objects)) {
                obj._objects.forEach((child: any) => {
                    if (child.clipPath) {
                        child.set('clipPath', null);
                        delete child._frameClipOwner;
                        clearedCount++;
                    }
                });
            }
        });
        console.log(`[clipPath] Nuclear option: removidos ${clearedCount} clipPaths`);
    } catch (e) {
        console.warn('⚠️ Erro ao remover clipPaths:', e);
    }
};

// Product Zone State
const productZoneState = useProductZone()

// Label templates (price splash models)
const showLabelTemplatesModal = ref(false)
const labelTemplates = ref<LabelTemplate[]>([])
const hasLoadedLabelTemplatesFromDb = ref(false)

const LABEL_TEMPLATES_JSON_KEY = '__labelTemplates'
const BUILTIN_DEFAULT_LABEL_TEMPLATE_ID = 'tpl_default'
const BUILTIN_ATACAREJO_LABEL_TEMPLATE_ID = 'tpl_atacarejo_10fd'
const BUILTIN_BLACK_YELLOW_LABEL_TEMPLATE_ID = 'tpl_black_yellow'
const BUILTIN_RED_BURST_LABEL_TEMPLATE_ID = 'tpl_red_burst'
const BUILTIN_OFER_AMARELA_LABEL_TEMPLATE_ID = 'tpl_oferta_amarela'
const BUILTIN_ATACAREJO_SEED_VERSION = 4
const LABEL_TEMPLATE_PREVIEW_RENDER_VERSION = 2
const LABEL_TEMPLATE_EXTRA_PROPS = ['name', 'fontFamily', '__preserveManualLayout', '__forceAtacarejoCanonical', '__atacValueVariants', '__atacVariantGroups', '__fontScale', '__yOffsetRatio', '__strokeWidth', '__roundness', '__originalWidth', '__originalHeight', '__originalFontSize', '__originalLeft', '__originalTop', '__originalOriginX', '__originalOriginY', '__originalScaleX', '__originalScaleY', '__originalRadius', '__originalRx', '__originalRy', '__originalStrokeWidth', '__shadowBlur', '__manualTemplateBaseW', '__manualTemplateBaseH', '__manualGapSingle', '__manualGapRetail', '__manualGapWholesale', '__manualSingleAnchors']

const getLabelTemplateTimestamp = (tpl: any): number => {
    const ts = Date.parse(String(tpl?.updatedAt || tpl?.createdAt || ''));
    return Number.isFinite(ts) ? ts : Number.NaN;
};

const shouldUseIncomingTemplateSnapshot = (prev: any, incoming: any): boolean => {
    const prevTs = getLabelTemplateTimestamp(prev);
    const incomingTs = getLabelTemplateTimestamp(incoming);
    const incomingIsLocalOverride = !!(incoming as any)?.__localOverride;
    const prevIsLocalOverride = !!(prev as any)?.__localOverride;

    // Local override always wins over non-local data.
    if (incomingIsLocalOverride !== prevIsLocalOverride) {
        return incomingIsLocalOverride;
    }

    // Same tier (both local or both non-local): prefer newer timestamp.
    if (Number.isFinite(incomingTs) && Number.isFinite(prevTs)) {
        return incomingTs >= prevTs;
    }
    if (Number.isFinite(incomingTs) && !Number.isFinite(prevTs)) return true;
    if (!Number.isFinite(incomingTs) && Number.isFinite(prevTs)) return false;

    // Legacy payloads without timestamp: keep incoming on hydration path.
    return true;
};

const serializeLabelTemplatesForProject = () => {
    // Keep project JSON lean: previews can be regenerated client-side.
    // Avoid embedding DB/library templates into every project (keeps canvas_data smaller),
    // except when user edited one locally (local override must survive reloads).
    return (labelTemplates.value || [])
        .filter((t: any) => !(t as any)?.__fromDb || (t as any)?.__localOverride === true)
        .map((t: any) => ({
            ...t,
            __fromDb: undefined,
            previewDataUrl: undefined
        }))
}

const hydrateLabelTemplatesFromProjectJson = (json: any) => {
    const raw = json?.[LABEL_TEMPLATES_JSON_KEY]
    if (!Array.isArray(raw)) return;

    const existing = (labelTemplates.value || []) as any[];
    const byId = new Map<string, any>(existing.map(t => [String(t?.id), t]));
    for (const t of raw as any[]) {
        if (!t?.id) continue;
        const id = String(t.id);
        const prev = byId.get(id);
        if (!prev) {
            byId.set(id, {
                ...t,
                __fromDb: false,
                __localOverride: true
            });
            continue;
        }

        const incomingIsLocalOverride = !!(t as any)?.__localOverride;
        const prevIsLocalOverride = !!(prev as any)?.__localOverride;
        const useIncoming = shouldUseIncomingTemplateSnapshot(prev, t);

        const merged = {
            ...(useIncoming ? prev : t),
            ...(useIncoming ? t : prev),
            previewDataUrl: ((useIncoming ? t : prev) as any)?.previewDataUrl ?? ((useIncoming ? prev : t) as any)?.previewDataUrl
        } as any;

        const hasLocalOverride = prevIsLocalOverride || incomingIsLocalOverride;
        if (hasLocalOverride) {
            merged.__fromDb = false;
            merged.__localOverride = true;
        }

        byId.set(id, merged);
    }
    labelTemplates.value = Array.from(byId.values()) as any;
}

const syncLabelTemplatesIntoProjectPages = (source: 'user' | 'system' = 'user') => {
    const templatesSnapshot = serializeLabelTemplatesForProject();
    const pages = Array.isArray(project.pages) ? project.pages : [];
    if (!pages.length) return;

    for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        const baseCanvasData = (page?.canvasData && typeof page.canvasData === 'object')
            ? page.canvasData
            : { version: '6.0.0', objects: [] };
        const nextCanvasData = {
            ...baseCanvasData,
            [LABEL_TEMPLATES_JSON_KEY]: templatesSnapshot
        };
        updatePageData(i, nextCanvasData, {
            source,
            markUnsaved: source === 'user',
            skipIfSameFingerprint: false
        });
    }
}

const normalizeDbLabelTemplate = (row: any): LabelTemplate | null => {
    if (!row?.id || !row?.group) return null;
    return {
        id: String(row.id),
        name: String(row.name || 'Etiqueta'),
        kind: (row.kind || 'priceGroup-v1') as any,
        group: row.group ?? (row as any)['group'],
        previewDataUrl: row.preview_data_url ?? undefined,
        createdAt: row.created_at ? String(row.created_at) : new Date().toISOString(),
        updatedAt: row.updated_at ? String(row.updated_at) : (row.created_at ? String(row.created_at) : new Date().toISOString())
    };
}

const loadLabelTemplatesFromDb = async () => {
    if (hasLoadedLabelTemplatesFromDb.value) return;
    hasLoadedLabelTemplatesFromDb.value = true;

    try {
        const userId = currentUser.value?.id || undefined;
        const headers = await getApiAuthHeaders();
        const resp: any = await $fetch('/api/label-templates', { method: 'GET', headers, query: userId ? { userId } : {} });
        const rows = Array.isArray(resp?.templates) ? resp.templates : [];
        const incoming = rows.map(normalizeDbLabelTemplate).filter(Boolean) as LabelTemplate[];
        if (!incoming.length) return;

        const existing = (labelTemplates.value || []) as any[];
        const byId = new Map<string, any>(existing.map(t => [String(t?.id), t]));

        for (const t of incoming) {
            const prev = byId.get(String(t.id));
            if (prev) {
                // Evitar sobrescrever mudanças locais/projeto com versão antiga do banco.
                const prevTs = Date.parse(String(prev?.updatedAt || prev?.createdAt || 0));
                const dbTs = Date.parse(String((t as any)?.updatedAt || (t as any)?.createdAt || 0));
                const prevIsLocalOverride = !!(prev as any)?.__localOverride;
                // Never let DB overwrite a local override saved in the project.
                const useDb = !prevIsLocalOverride && Number.isFinite(dbTs) && (!Number.isFinite(prevTs) || dbTs > prevTs);
                const merged = {
                    ...(useDb ? prev : t),
                    ...(useDb ? t : prev),
                    previewDataUrl: (useDb ? t.previewDataUrl : prev.previewDataUrl) ?? (useDb ? prev.previewDataUrl : t.previewDataUrl)
                } as any;
                if (prevIsLocalOverride) {
                    merged.__fromDb = false;
                    merged.__localOverride = true;
                } else if (useDb) {
                    merged.__fromDb = true;
                }
                byId.set(String(t.id), merged);
            } else {
                byId.set(String(t.id), { ...t, __fromDb: true });
            }
        }
        labelTemplates.value = Array.from(byId.values()) as any;
    } catch (err) {
        console.warn('[labelTemplates] Falha ao carregar modelos do banco', err);
    }
}

const ensureLabelTemplatesReady = async () => {
    await loadLabelTemplatesFromDb();
    await ensureBuiltInDefaultLabelTemplate();
    await ensureBuiltInBlackYellowLabelTemplate();
    await ensureBuiltInOfertaAmarelaLabelTemplate();
    await ensureBuiltInRedBurstLabelTemplate();
    await ensureBuiltInAtacarejoLabelTemplate();

    // Generate/refresh previews in-memory.
    // This self-heals stale/broken thumbnails after reload or renderer updates.
    const list = [...(labelTemplates.value || [])];
    let changed = false;
    for (let i = 0; i < list.length; i++) {
        const t = list[i];
        if (!t) continue;
        const currentPreviewVersion = Number((t as any).__previewRenderVersion || 0);
        const needsPreviewRefresh =
            !(t as any).previewDataUrl ||
            currentPreviewVersion < LABEL_TEMPLATE_PREVIEW_RENDER_VERSION;
        if (!needsPreviewRefresh) continue;
        const url = await renderLabelTemplatePreview(t);
        if (url) {
            (list[i] as any) = {
                ...(t as any),
                previewDataUrl: url,
                __previewRenderVersion: LABEL_TEMPLATE_PREVIEW_RENDER_VERSION
            };
            changed = true;
        }
    }
    if (changed) labelTemplates.value = list as any;

    // Hard guard: never keep duplicated IDs in memory.
    const dedup = new Map<string, any>();
    (labelTemplates.value || []).forEach((tpl: any) => {
        const id = String(tpl?.id || '').trim();
        if (!id) return;
        dedup.set(id, tpl);
    });
    if (dedup.size !== (labelTemplates.value || []).length) {
        labelTemplates.value = Array.from(dedup.values()) as any;
    }
}

const upsertLabelTemplateToDb = async (tpl: LabelTemplate): Promise<boolean> => {
    if (!tpl || (tpl as any).isBuiltIn) return true;
    try {
        const headers = await getApiAuthHeaders();
        const resp: any = await $fetch('/api/label-templates', {
            method: 'POST',
            headers,
            body: {
                id: tpl.id,
                userId: currentUser.value?.id ?? null,
                name: tpl.name,
                kind: tpl.kind,
                group: tpl.group,
                previewDataUrl: tpl.previewDataUrl ?? null
            }
        });
        if (!resp?.success) {
            console.warn('[labelTemplates] API retornou falha ao salvar modelo no banco', resp);
            return false;
        }
        return true;
    } catch (err) {
        console.warn('[labelTemplates] Falha ao salvar modelo no banco', err);
        return false;
    }
}

const deleteLabelTemplateFromDb = async (templateId: string) => {
    if (!templateId) return;
    try {
        const headers = await getApiAuthHeaders();
        await $fetch('/api/label-templates', { method: 'DELETE', headers, query: { id: templateId } });
    } catch (err) {
        console.warn('[labelTemplates] Falha ao excluir modelo do banco', err);
    }
}

const activeZoneTemplateId = () => {
    const z = canvas.value?.getActiveObject?.();
    if (z && isLikelyProductZone(z)) return (z as any)._zoneGlobalStyles?.splashTemplateId as (string | undefined);
    return undefined;
}

// Note: computed must depend on a reactive value; selectedObjectRef updates on selection events.
let canSaveLabelTemplateFromSelectionComputed: any = null;

// Canvas context menu (right click) - used for Arrange / Layer order like Figma
const canvasContextMenu = ref({
    show: false,
    x: 0,
    y: 0
});

const layersContextMenu = ref({
    show: false,
    x: 0,
    y: 0
});

const canvasContextMenuItems = computed(() => ([
    { label: 'Trazer para frente', action: 'arrange-bring-to-front', icon: ChevronsUp },
    { label: 'Avancar (uma camada)', action: 'arrange-bring-forward', icon: ArrowUp },
    { label: 'Recuar (uma camada)', action: 'arrange-send-backward', icon: ArrowDown },
    { label: 'Enviar para tras', action: 'arrange-send-to-back', icon: ChevronsDown },
    { divider: true },
    { label: 'Mascarar', action: 'mask-selection', icon: Frame },
    { divider: true },
    { label: 'Agrupar (Ctrl+G)', action: 'group-selection', icon: Group },
    { label: 'Desagrupar (Ctrl+Shift+G)', action: 'ungroup-selection', icon: Ungroup }
]));

const handleCanvasContextMenuSelect = (action: string) => {
    if (action === 'arrange-bring-to-front') arrangeActiveObjects('bring-to-front');
    if (action === 'arrange-bring-forward') arrangeActiveObjects('bring-forward');
    if (action === 'arrange-send-backward') arrangeActiveObjects('send-backward');
    if (action === 'arrange-send-to-back') arrangeActiveObjects('send-to-back');
    if (action === 'mask-selection') void handleAction('toggle-mask');
    if (action === 'group-selection') groupSelection();
    if (action === 'ungroup-selection') ungroupSelection();
};

const layersContextMenuItems = computed(() => ([
    { label: 'Mascarar', action: 'mask-selection', icon: Frame },
    { divider: true },
    { label: 'Agrupar (Ctrl+G)', action: 'group-selection', icon: Group },
    { label: 'Desagrupar (Ctrl+Shift+G)', action: 'ungroup-selection', icon: Ungroup }
]));

const handleLayersContextMenuSelect = (action: string) => {
    if (action === 'mask-selection') void handleAction('toggle-mask');
    if (action === 'group-selection') groupSelection();
    if (action === 'ungroup-selection') ungroupSelection();
};

const groupSelection = () => {
    if (!canvas.value) return;
    const activeObject = canvas.value.getActiveObject();
    
    if (!activeObject) return;
    
    if (activeObject.type === 'activeSelection' && fabric.Group) {
        const group = new fabric.Group(activeObject.getObjects(), {
            originX: 'center',
            originY: 'center',
            selectable: true,
            evented: true
        });
        
        canvas.value.remove(activeObject);
        canvas.value.add(group);
        canvas.value.setActiveObject(group);
        canvas.value.requestRenderAll();
        refreshCanvasObjects();
        saveCurrentState();
    }
};

const ungroupSelection = () => {
    if (!canvas.value) return;
    const activeObject = canvas.value.getActiveObject();
    
    if (!activeObject || activeObject.type !== 'group') return;
    
    const group = activeObject as any;
    const objects = group.getObjects();
    group.ungroupOnCanvas();
    
    canvas.value.setActiveObject(objects[0]);
    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    saveCurrentState();
};

watch(showLabelTemplatesModal, async (open) => {
    if (!open) return;
    await ensureLabelTemplatesReady();
});

const FRAME_SPAWN_GAP = 48;

const getFrameBounds = (frame: any) => {
    if (!frame) return null;
    const angle = Math.abs(Number(frame.angle || 0)) % 360;
    if (angle > 0.001) {
        try {
            const rotatedBounds = frame.getBoundingRect?.(true);
            if (
                rotatedBounds &&
                Number.isFinite(rotatedBounds.left) &&
                Number.isFinite(rotatedBounds.top) &&
                Number.isFinite(rotatedBounds.width) &&
                Number.isFinite(rotatedBounds.height) &&
                rotatedBounds.width > 0 &&
                rotatedBounds.height > 0
            ) {
                return rotatedBounds;
            }
        } catch {
            // fallback below
        }
    }

    const width = Math.abs((Number(frame.width) || 0) * (Number(frame.scaleX) || 1));
    const height = Math.abs((Number(frame.height) || 0) * (Number(frame.scaleY) || 1));
    const center = typeof frame.getCenterPoint === 'function'
        ? frame.getCenterPoint()
        : { x: Number(frame.left) || 0, y: Number(frame.top) || 0 };
    const left = Number(center.x || 0) - (width / 2);
    const top = Number(center.y || 0) - (height / 2);
    if (!Number.isFinite(left) || !Number.isFinite(top) || width <= 0 || height <= 0) return null;
    return { left, top, width, height };
};

const getFrameSpawnPosition = (referenceFrame: any, nextFrameWidth: number, nextFrameHeight: number) => {
    const fallback = {
        left: nextFrameWidth / 2,
        top: nextFrameHeight / 2
    };
    const bounds = getFrameBounds(referenceFrame);
    if (!bounds) return fallback;

    return {
        left: bounds.left + bounds.width + FRAME_SPAWN_GAP + nextFrameWidth / 2,
        top: bounds.top + bounds.height / 2
    };
};

const addFrame = () => {
    if (!canvas.value) return;

    const frameWidth = 1080;
    const frameHeight = 1350;

    const getNextFrameName = () => {
        if (!canvas.value) return 'Frame 1';
        const frames = canvas.value.getObjects().filter((o: any) => !!o?.isFrame);
        let maxN = 0;
        frames.forEach((f: any) => {
            const n = (f?.layerName || f?.name || '').toString();
            const m = /^Frame\s+(\d+)\s*$/i.exec(n);
            if (m) maxN = Math.max(maxN, Number(m[1] || 0));
        });
        return `Frame ${maxN + 1}`;
    };

    // Calculate zoom to fit frame in viewport with padding
    const canvasWidth = canvas.value.getWidth() || 800;
    const canvasHeight = canvas.value.getHeight() || 600;
    const padding = 80; // Padding around frame
    const zoomX = (canvasWidth - padding * 2) / frameWidth;
    const zoomY = (canvasHeight - padding * 2) / frameHeight;
    const fitZoom = Math.min(zoomX, zoomY, 1); // Don't zoom more than 100%
    
    const frames = canvas.value.getObjects().filter((o: any) => !!o?.isFrame);
    const active = canvas.value.getActiveObject() as any;

    const rightMostFrame = frames.reduce((best: any, candidate: any) => {
        const bestBounds = getFrameBounds(best);
        const candidateBounds = getFrameBounds(candidate);
        if (!candidateBounds) return best;
        if (!bestBounds) return candidate;
        return (candidateBounds.left + candidateBounds.width) > (bestBounds.left + bestBounds.width) ? candidate : best;
    }, null as any);

    const referenceFrame = active?.isFrame ? active : rightMostFrame;
    const spawn = getFrameSpawnPosition(referenceFrame, frameWidth, frameHeight);

    // Create Frame Rect
    const frame = new fabric.Rect({
        left: spawn.left,
        top: spawn.top,
        originX: 'center',
        originY: 'center',
        width: frameWidth,
        height: frameHeight,
        fill: '#ffffff',
        stroke: 'transparent',
        strokeWidth: 2,
        strokeUniform: true, // Stroke não afeta dimensões (1080 fica 1080, não 1082)
        isFrame: true, // Custom Flag used by after:render
        clipContent: true,
        name: getNextFrameName(),
        objectCaching: false, // Disabled to prevent trails during movement
        statefullCache: false,
        noScaleCache: true,
        hasBorders: true,
        transparentCorners: false,
        cornerColor: '#0d99ff',
        cornerSize: 8,
        padding: 0,
        // Controle preciso de resize (1 pixel por vez)
        lockScalingX: false,
        lockScalingY: false,
        // Usa controles de escala suave mas precisos
        cornerStrokeColor: '#0d99ff',
        borderScaleFactor: 1
    });

    (frame as any)._customId = Math.random().toString(36).substr(2, 9);
    (frame as any).__strokeEnabled = false;
    
    // CRITICAL: Set layerName to ensure it persists and shows as "FRAMER" in LayersPanel
    // The name "Frame N" is for canvas display, layerName "FRAMER" is for layers panel
    frame.layerName = 'FRAMER';

    canvas.value.add(frame);
    // Frames devem ficar atrás do conteúdo (evita bloquear drag/seleção de imagens)
    ensureFramesBelowContents();
    canvas.value.setActiveObject(frame);
    
    // Adjust zoom and center viewport to fit the frame
    canvas.value.setZoom(fitZoom);
    const vpt = canvas.value.viewportTransform || [1, 0, 0, 1, 0, 0];
    // Center the frame in viewport
    vpt[4] = (canvasWidth - frameWidth * fitZoom) / 2;
    vpt[5] = (canvasHeight - frameHeight * fitZoom) / 2;
    canvas.value.setViewportTransform(vpt);
    
    canvas.value.requestRenderAll();
    
    // Force update canvasObjects immediately so LayersPanel shows the new frame
    refreshCanvasObjects();
    
    saveCurrentState();
}

// === FRAMES (Figma-like) ===
// Basic parenting via `parentFrameId` + optional clipping via `clipContent`.
const ensureFramesBelowContents = () => {
    if (!canvas.value) return;
    const all = canvas.value.getObjects();
    // Keep non-export/system overlays (guides, etc.) pinned on top.
    const pinnedTop = all.filter((o: any) => !!o?.excludeFromExport);
    const list = all.filter((o: any) => !o?.excludeFromExport);
    // Put frames behind everything else (Figma-like: frame is a container/background).
    const frames = list.filter((o: any) => !!o?.isFrame);
    const rest = list.filter((o: any) => !o?.isFrame);
    const desiredOrder = [...frames, ...rest, ...pinnedTop];

    // Avoid expensive stack rewrites + re-render when order is already correct.
    if (desiredOrder.length === all.length) {
        let sameOrder = true;
        for (let i = 0; i < all.length; i++) {
            if (all[i] !== desiredOrder[i]) {
                sameOrder = false;
                break;
            }
        }
        if (sameOrder) return;
    }

    applyArrangedOrder(canvas.value, desiredOrder);
};

const isFrameLikeObject = (obj: any) => {
    if (!obj) return false;
    if (obj.isFrame) return true;

    const layerName = String(obj.layerName || '').trim().toUpperCase();
    const name = String(obj.name || '').trim();
    if (layerName === 'FRAMER' || layerName === 'FRAME' || /^FRAMER?\s+\d+\s*$/i.test(layerName)) return true;
    if (/^FRAMER(?:\s+\d+)?$/i.test(name) || /^FRAME(?:\s+\d+)?\s*$/i.test(name)) return true;

    const isRect = isRectObject(obj) || String(obj.type || '').toLowerCase() === 'rect';
    if (isRect && (obj.isGridCell === true || String(obj.gridGroupId || '').trim().length > 0)) return true;

    return false;
};

const normalizeFrameRuntimeProps = (obj: any) => {
    if (!obj || !isFrameLikeObject(obj)) return null;
    if (!obj._customId) obj._customId = Math.random().toString(36).substr(2, 9);
    if (!obj.isFrame) obj.isFrame = true;
    if (typeof obj.clipContent !== 'boolean') obj.clipContent = true;
    if (!obj.layerName) obj.layerName = 'FRAMER';
    return obj;
};

const getFrameById = (id: string) => {
    if (!canvas.value || !id) return null;
    return getAllFrames().find((o: any) => String(o?._customId || o?.id || '') === String(id)) || null;
};

const getAllFrames = () => {
    if (!canvas.value) return [];
    const frames: any[] = [];
    canvas.value.getObjects().forEach((obj: any) => {
        const normalized = normalizeFrameRuntimeProps(obj);
        if (normalized) frames.push(normalized);
    });
    return frames;
};

const getOrCreateFrameClipRect = (frame: any) => {
    if (!frame || !fabric) return null;
    const kRectLocal = 1 - 0.5522847498;
    const clampR = (n: any, w: number, h: number) => {
        const v = Math.max(0, Number(n || 0));
        return Math.min(v, w / 2, h / 2);
    };

    const buildCornerPath = (w: number, h: number, radii: any) => {
        const x = -w / 2;
        const y = -h / 2;
        const tl = clampR(radii?.tl, w, h);
        const tr = clampR(radii?.tr, w, h);
        const br = clampR(radii?.br, w, h);
        const bl = clampR(radii?.bl, w, h);

        const parts = [
            `M ${x + tl} ${y}`,
            `L ${x + w - tr} ${y}`,
            tr ? `C ${x + w - kRectLocal * tr} ${y} ${x + w} ${y + kRectLocal * tr} ${x + w} ${y + tr}` : '',
            `L ${x + w} ${y + h - br}`,
            br ? `C ${x + w} ${y + h - kRectLocal * br} ${x + w - kRectLocal * br} ${y + h} ${x + w - br} ${y + h}` : '',
            `L ${x + bl} ${y + h}`,
            bl ? `C ${x + kRectLocal * bl} ${y + h} ${x} ${y + h - kRectLocal * bl} ${x} ${y + h - bl}` : '',
            `L ${x} ${y + tl}`,
            tl ? `C ${x} ${y + kRectLocal * tl} ${x + kRectLocal * tl} ${y} ${x + tl} ${y}` : '',
            'Z'
        ].filter(Boolean);
        return parts.join(' ');
    };

    const hasCornerRadii = !!(frame.cornerRadii && typeof frame.cornerRadii === 'object');
    const wantPathClip = hasCornerRadii;

    // CRITICAL FIX: The clipPath needs to be created with proper offset calculation
    // When using absolutePositioned: false, the clipPath is relative to the object's origin
    // We need to calculate the offset from the object to the frame

    const clip = wantPathClip
        ? new fabric.Path(buildCornerPath(frame.width, frame.height, frame.cornerRadii), {
            originX: 'center',
            originY: 'center',
            left: 0,
            top: 0,
            scaleX: 1,
            scaleY: 1,
            angle: 0,
            absolutePositioned: false,
            selectable: false,
            evented: false,
            objectCaching: false
        })
        : new fabric.Rect({
            originX: 'center',
            originY: 'center',
            left: 0,
            top: 0,
            width: frame.width,
            height: frame.height,
            rx: frame.rx ?? 0,
            ry: frame.ry ?? 0,
            scaleX: 1,
            scaleY: 1,
            angle: 0,
            absolutePositioned: false,
            selectable: false,
            evented: false,
            objectCaching: false
        });

    clip._objects = [];
    (frame as any).__clipRect = clip;

    if (typeof clip.setCoords === 'function') clip.setCoords();
    clip.dirty = true;

    return clip;
};

const findFrameUnderObject = (obj: any) => {
    if (!canvas.value || !obj) return null;
    // Frames NUNCA podem ser filhos de outros frames
    if (obj.isFrame) return null;

    const frames = getAllFrames().filter((f: any) => f !== obj);
    if (!frames.length) return null;

    const objBounds = obj.getBoundingRect ? obj.getBoundingRect(true) : null;
    const objArea = objBounds ? Math.max(1, objBounds.width * objBounds.height) : 1;
    const center = typeof obj.getCenterPoint === 'function'
        ? obj.getCenterPoint()
        : (objBounds ? { x: objBounds.left + (objBounds.width / 2), y: objBounds.top + (objBounds.height / 2) } : null);

    // STRICT RULE:
    // - Prefer center-inside to avoid accidental parenting when only touching frame edge.
    // - Fallback to substantial overlap for large objects.
    const hits = frames.filter((f: any) => {
        const fb = f.getBoundingRect ? f.getBoundingRect(true) : null;
        if (!fb) return false;

        const centerInside = !!(center &&
            center.x >= fb.left &&
            center.x <= (fb.left + fb.width) &&
            center.y >= fb.top &&
            center.y <= (fb.top + fb.height));
        if (centerInside) return true;

        if (!objBounds) return false;
        const ix = Math.max(0, Math.min(objBounds.left + objBounds.width, fb.left + fb.width) - Math.max(objBounds.left, fb.left));
        const iy = Math.max(0, Math.min(objBounds.top + objBounds.height, fb.top + fb.height) - Math.max(objBounds.top, fb.top));
        const overlapArea = ix * iy;
        const overlapRatio = overlapArea / objArea;
        return overlapRatio >= 0.6;
    });

    if (!hits.length) return null;

    // Prefer the smallest frame (innermost) when nested.
    hits.sort((a: any, b: any) => (a.getScaledWidth() * a.getScaledHeight()) - (b.getScaledWidth() * b.getScaledHeight()));
    return hits[0];
};

const syncObjectFrameClip = (obj: any) => {
    if (!canvas.value || !obj) return;
    if ((obj as any).excludeFromExport) return;

    // Product cards should NEVER be clipped by frames — they sit on top of frames
    if ((obj as any).isSmartObject || (obj as any).isProductCard) {
        if (obj.clipPath) {
            obj.set('clipPath', null);
            delete (obj as any)._frameClipOwner;
            obj.set('dirty', true);
            obj.setCoords();
        }
        return;
    }

    const frameId = (obj as any).parentFrameId as (string | undefined);
    const frame = frameId ? getFrameById(frameId) : null;
    const hasObjectMask = !!(obj as any).objectMaskEnabled && !!obj.clipPath;

    const hasCornerRadii = !!(frame?.cornerRadii && typeof frame.cornerRadii === 'object');
    const wantPathClip = hasCornerRadii;
    const kRectLocal = 1 - 0.5522847498;
    const clampR = (n: any, w: number, h: number) => {
        const v = Math.max(0, Number(n || 0));
        return Math.min(v, w / 2, h / 2);
    };
    const buildCornerPath = (w: number, h: number, radii: any) => {
        const x = -w / 2;
        const y = -h / 2;
        const tl = clampR(radii?.tl, w, h);
        const tr = clampR(radii?.tr, w, h);
        const br = clampR(radii?.br, w, h);
        const bl = clampR(radii?.bl, w, h);
        const parts = [
            `M ${x + tl} ${y}`,
            `L ${x + w - tr} ${y}`,
            tr ? `C ${x + w - kRectLocal * tr} ${y} ${x + w} ${y + kRectLocal * tr} ${x + w} ${y + tr}` : '',
            `L ${x + w} ${y + h - br}`,
            br ? `C ${x + w} ${y + h - kRectLocal * br} ${x + w - kRectLocal * br} ${y + h} ${x + w - br} ${y + h}` : '',
            `L ${x + bl} ${y + h}`,
            bl ? `C ${x + kRectLocal * bl} ${y + h} ${x} ${y + h - kRectLocal * bl} ${x} ${y + h - bl}` : '',
            `L ${x} ${y + tl}`,
            tl ? `C ${x} ${y + kRectLocal * tl} ${x + kRectLocal * tl} ${y} ${x + tl} ${y}` : '',
            'Z'
        ].filter(Boolean);
        return parts.join(' ');
    };
    const upsertFrameClip = (
        existingClip: any,
        transform: { left: number; top: number; scaleX: number; scaleY: number; angle: number; skewX?: number; skewY?: number },
        markAsFrameClip = false
    ) => {
        const canReuseClip = existingClip &&
            ((wantPathClip && existingClip.type === 'path') || (!wantPathClip && existingClip.type === 'rect'));
        const clipProps: any = {
            originX: 'center',
            originY: 'center',
            left: transform.left,
            top: transform.top,
            scaleX: transform.scaleX,
            scaleY: transform.scaleY,
            angle: transform.angle,
            skewX: Number.isFinite(Number(transform.skewX)) ? Number(transform.skewX) : 0,
            skewY: Number.isFinite(Number(transform.skewY)) ? Number(transform.skewY) : 0,
            absolutePositioned: false,
            selectable: false,
            evented: false,
            objectCaching: false
        };
        let clip = existingClip;
        if (canReuseClip) {
            if (!wantPathClip) {
                clipProps.width = frame.width;
                clipProps.height = frame.height;
                clipProps.rx = frame.rx ?? 0;
                clipProps.ry = frame.ry ?? 0;
            }
            clip.set(clipProps);
        } else {
            clip = wantPathClip
                ? new fabric.Path(buildCornerPath(frame.width, frame.height, frame.cornerRadii), clipProps)
                : new fabric.Rect({
                    ...clipProps,
                    width: frame.width,
                    height: frame.height,
                    rx: frame.rx ?? 0,
                    ry: frame.ry ?? 0
                });
        }
        if (markAsFrameClip) (clip as any).__isFrameClip = true;
        (clip as any)._objects = Array.isArray((clip as any)._objects) ? (clip as any)._objects : [];
        if (typeof clip.setCoords === 'function') clip.setCoords();
        clip.dirty = true;
        return clip;
    };

    // Se não tem frame pai ou clipContent desativado, remove clipPath
    if (!frame || !frame.clipContent) {
        if (hasObjectMask) {
            const maskClip: any = obj.clipPath;
            const nested = maskClip?.clipPath;
            if (nested && ((nested as any).__isFrameClip || !!(obj as any)._frameClipOwner)) {
                try { maskClip.set('clipPath', null); } catch { maskClip.clipPath = null; }
            }
            delete (obj as any)._frameClipOwner;
            obj.set('dirty', true);
            obj.setCoords();
            return;
        }
        if (obj.clipPath) {
            obj.set('clipPath', null);
            delete (obj as any)._frameClipOwner;
            obj.set('dirty', true);
            obj.setCoords();
        }
        return;
    }

    if (hasObjectMask) {
        const maskClip: any = obj.clipPath;
        const util = fabric?.util as any;
        const canUseMatrixMath = !!(
            util &&
            typeof util.invertTransform === 'function' &&
            typeof util.multiplyTransformMatrices === 'function' &&
            typeof util.qrDecompose === 'function' &&
            typeof obj?.calcTransformMatrix === 'function' &&
            typeof maskClip?.calcTransformMatrix === 'function' &&
            typeof frame?.calcTransformMatrix === 'function'
        );
        if (!canUseMatrixMath) {
            delete (obj as any)._frameClipOwner;
            obj.set('dirty', true);
            obj.setCoords();
            return;
        }

        const objWorldMatrix = obj.calcTransformMatrix();
        const maskLocalMatrix = maskClip.calcTransformMatrix();
        const frameWorldMatrix = frame.calcTransformMatrix();
        const maskWorldMatrix = util.multiplyTransformMatrices(objWorldMatrix, maskLocalMatrix);
        const invMaskWorldMatrix = util.invertTransform(maskWorldMatrix);
        const relativeFrameToMaskMatrix = util.multiplyTransformMatrices(invMaskWorldMatrix, frameWorldMatrix);
        const decomp = util.qrDecompose(relativeFrameToMaskMatrix);

        const nestedExisting = maskClip?.clipPath && (maskClip.clipPath as any).__isFrameClip
            ? maskClip.clipPath
            : null;
        const nestedFrameClip = upsertFrameClip(
            nestedExisting,
            {
                left: Number(decomp?.translateX) || 0,
                top: Number(decomp?.translateY) || 0,
                scaleX: Number.isFinite(Number(decomp?.scaleX)) ? Number(decomp.scaleX) : 1,
                scaleY: Number.isFinite(Number(decomp?.scaleY)) ? Number(decomp.scaleY) : 1,
                angle: Number(decomp?.angle) || 0,
                skewX: Number(decomp?.skewX) || 0,
                skewY: Number(decomp?.skewY) || 0
            },
            true
        );
        try { maskClip.set('clipPath', nestedFrameClip); } catch { maskClip.clipPath = nestedFrameClip; }
        maskClip.dirty = true;
        if (typeof maskClip.setCoords === 'function') maskClip.setCoords();

        (obj as any)._frameClipOwner = frame._customId;
        obj.set('dirty', true);
        obj.setCoords();
        return;
    }

    // ESTRATÉGIA: absolutePositioned: false (relativo ao objeto)
    // No Fabric.js v7, o cache do objeto tem tamanho limitado.
    // Com absolutePositioned: true, o clipPath layer canvas pode ser pequeno demais
    // para conter o clip em coordenadas globais, fazendo o clip falhar.
    // Com absolutePositioned: false, o clipPath fica relativo ao centro do objeto,
    // garantindo que esteja sempre dentro dos limites do layer canvas.
    const frameCenter = frame.getCenterPoint ? frame.getCenterPoint() : { x: frame.left, y: frame.top };
    const objCenter = obj.getCenterPoint ? obj.getCenterPoint() : { x: obj.left, y: obj.top };

    // Converter offset mundo → coordenadas locais do objeto (desrotacionar e desescalar)
    const dxWorld = frameCenter.x - objCenter.x;
    const dyWorld = frameCenter.y - objCenter.y;
    const objAngle = obj.angle || 0;
    const angleRad = -objAngle * Math.PI / 180;
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);
    const dxLocal = (dxWorld * cos - dyWorld * sin) / (obj.scaleX || 1);
    const dyLocal = (dxWorld * sin + dyWorld * cos) / (obj.scaleY || 1);
    // Escala do clip: frame visual size / object scale
    const clipScaleX = (frame.scaleX || 1) / (obj.scaleX || 1);
    const clipScaleY = (frame.scaleY || 1) / (obj.scaleY || 1);
    const clipAngle = (frame.angle || 0) - objAngle;
    const existingClip = obj.clipPath;
    const existingOwner = (obj as any)._frameClipOwner;
    const clip = upsertFrameClip(
        existingClip && existingOwner === frame._customId ? existingClip : null,
        { left: dxLocal, top: dyLocal, scaleX: clipScaleX, scaleY: clipScaleY, angle: clipAngle }
    );
    (frame as any).__clipRect = clip;

    // Aplicar clipPath
    obj.set('clipPath', clip);
    (obj as any)._frameClipOwner = frame._customId;
    obj.set('dirty', true);
    obj.setCoords();
};

const syncFrameClips = (frame: any) => {
    if (!canvas.value || !frame?._customId) return;
    getOrCreateFrameClipRect(frame);

    // Get ALL children that are inside the frame bounds, not just those with parentFrameId set
    const allObjects = canvas.value.getObjects().filter((o: any) => o !== frame && !o.isFrame);
    const frameBounds = frame.getBoundingRect ? frame.getBoundingRect() : null;

    const children = allObjects.filter((o: any) => {
        // First check explicit parentFrameId
        if (o.parentFrameId === frame._customId) return true;

        // ISOLAMENTO: Se o objeto já pertence a OUTRO frame, NÃO roubar
        if (o.parentFrameId && o.parentFrameId !== frame._customId) return false;

        // Then check if object is physically inside the frame
        if (frameBounds && typeof o.getBoundingRect === 'function') {
            const objBounds = o.getBoundingRect();
            // Check if object center is within frame bounds
            const objCenterX = objBounds.left + objBounds.width / 2;
            const objCenterY = objBounds.top + objBounds.height / 2;
            const insideX = objCenterX >= frameBounds.left && objCenterX <= frameBounds.left + frameBounds.width;
            const insideY = objCenterY >= frameBounds.top && objCenterY <= frameBounds.top + frameBounds.height;

            if (insideX && insideY) {
                // Auto-assign parentFrameId if not set
                if (!o.parentFrameId) {
                    o.parentFrameId = frame._customId;
                }
                return true;
            }
        }

        return false;
    });

    let hasChanges = false;
    children.forEach((child: any) => {
        const beforeClip = child.clipPath;
        syncObjectFrameClip(child);
        if (child.clipPath !== beforeClip) hasChanges = true;
    });

    // CRITICAL: Force re-render after clipPath changes
    if (hasChanges) {
        canvas.value.requestRenderAll();
    }
};

const maybeReparentToFrameOnDrop = (obj: any) => {
    if (!canvas.value || !obj || (obj as any).excludeFromExport) return;
    // Product cards inherit frame binding from their zone (avoid direct reparent here).
    if ((obj as any).isSmartObject || (obj as any).isProductCard) return;

    const currentParentFrameId = String((obj as any).parentFrameId || '').trim();
    const currentFrame = currentParentFrameId ? getFrameById(currentParentFrameId) : null;
    // Keep the current frame binding while there is any visual overlap.
    // Only detach when the object is fully outside.
    if (currentFrame && isObjectIntersectingFrame(obj, currentFrame)) {
        return;
    }

    const frame = findFrameUnderObject(obj);
    // If dropped outside of any frame, clear parenting so clipPath is removed.
    if (!frame || !frame._customId) {
        if ((obj as any).parentFrameId) {
            (obj as any).parentFrameId = undefined;
        }
        return;
    }
    if ((obj as any).parentFrameId !== frame._customId) {
        (obj as any).parentFrameId = frame._customId;
    }
};

const getFrameDescendants = (frame: any) => {
    if (!canvas.value || !frame?._customId) return [];
    const frameId = frame._customId;
    const objs = canvas.value.getObjects();

    const frameById = new Map<string, any>();
    objs.forEach((o: any) => {
        if (o?.isFrame && o._customId) frameById.set(o._customId, o);
    });

    const isDescendant = (obj: any) => {
        let id = obj?.parentFrameId as (string | undefined);
        let guard = 0;
        while (id && guard++ < 20) {
            if (id === frameId) return true;
            const parent = frameById.get(id);
            id = parent?.parentFrameId;
        }
        return false;
    };

    return objs.filter((o: any) => o !== frame && isDescendant(o));
};

const isObjectCenterInsideFrame = (obj: any, frame: any) => {
    if (!obj || !frame || typeof obj.getBoundingRect !== 'function' || typeof frame.getBoundingRect !== 'function') {
        return false;
    }
    const objBounds = obj.getBoundingRect(true);
    const frameBounds = frame.getBoundingRect(true);
    if (!objBounds || !frameBounds) return false;
    const cx = objBounds.left + (objBounds.width / 2);
    const cy = objBounds.top + (objBounds.height / 2);
    const minX = frameBounds.left;
    const maxX = frameBounds.left + frameBounds.width;
    const minY = frameBounds.top;
    const maxY = frameBounds.top + frameBounds.height;
    return cx >= minX && cx <= maxX && cy >= minY && cy <= maxY;
};

const isObjectVisuallyInsideFrame = (obj: any, frame: any) => {
    if (!obj || !frame || typeof obj.getBoundingRect !== 'function' || typeof frame.getBoundingRect !== 'function') {
        return false;
    }

    if (isObjectCenterInsideFrame(obj, frame)) return true;

    const objBounds = obj.getBoundingRect(true);
    const frameBounds = frame.getBoundingRect(true);
    if (!objBounds || !frameBounds) return false;

    const left = Math.max(objBounds.left, frameBounds.left);
    const top = Math.max(objBounds.top, frameBounds.top);
    const right = Math.min(objBounds.left + objBounds.width, frameBounds.left + frameBounds.width);
    const bottom = Math.min(objBounds.top + objBounds.height, frameBounds.top + frameBounds.height);
    const overlapW = Math.max(0, right - left);
    const overlapH = Math.max(0, bottom - top);
    const overlapArea = overlapW * overlapH;
    const objArea = Math.max(1, objBounds.width * objBounds.height);

    return overlapArea / objArea >= 0.2;
};

const isObjectIntersectingFrame = (obj: any, frame: any) => {
    if (!obj || !frame) return false;

    if (isObjectCenterInsideFrame(obj, frame)) return true;

    try {
        if (typeof frame.intersectsWithObject === 'function' && frame.intersectsWithObject(obj)) return true;
    } catch {
        // ignore intersection API failures and fallback to bounds
    }

    if (typeof obj.getBoundingRect !== 'function' || typeof frame.getBoundingRect !== 'function') {
        return false;
    }

    const objBounds = obj.getBoundingRect(true);
    const frameBounds = frame.getBoundingRect(true);
    if (!objBounds || !frameBounds) return false;

    const left = Math.max(objBounds.left, frameBounds.left);
    const top = Math.max(objBounds.top, frameBounds.top);
    const right = Math.min(objBounds.left + objBounds.width, frameBounds.left + frameBounds.width);
    const bottom = Math.min(objBounds.top + objBounds.height, frameBounds.top + frameBounds.height);
    const overlapW = Math.max(0, right - left);
    const overlapH = Math.max(0, bottom - top);
    const overlapArea = overlapW * overlapH;

    return overlapArea > 0;
};

const collectFrameVisibilityTargets = (rootFrame: any) => {
    if (!canvas.value || !rootFrame) return [rootFrame].filter(Boolean);

    const allObjects = canvas.value.getObjects();
    const targetSet = new Set<any>([rootFrame]);
    const visitedFrameIds = new Set<string>();
    const queue: any[] = [rootFrame];

    const enqueueFrame = (frameCandidate: any) => {
        const normalized = normalizeFrameRuntimeProps(frameCandidate);
        if (!normalized) return;
        targetSet.add(normalized);
        const id = String(normalized._customId || '').trim();
        if (!id || visitedFrameIds.has(id)) return;
        visitedFrameIds.add(id);
        queue.push(normalized);
    };

    enqueueFrame(rootFrame);

    while (queue.length > 0) {
        const frame = queue.shift();
        if (!frame) continue;

        const descendants = getFrameDescendants(frame);
        descendants.forEach((child: any) => {
            if (!child) return;
            targetSet.add(child);
            if (child.isFrame || isFrameLikeObject(child)) {
                enqueueFrame(child);
            }
        });

        const spatialChildren = allObjects.filter((candidate: any) => {
            if (!candidate || candidate === frame) return false;
            if (candidate.excludeFromExport) return false;
            if (isControlLikeObject(candidate) || isTransientCanvasObject(candidate)) return false;
            if (String(candidate.id || '') === 'artboard-bg') return false;
            if (targetSet.has(candidate)) return false;
            return isObjectVisuallyInsideFrame(candidate, frame);
        });

        spatialChildren.forEach((candidate: any) => {
            if (!candidate.parentFrameId && frame._customId) {
                candidate.parentFrameId = frame._customId;
            }
            targetSet.add(candidate);
            if (candidate.isFrame || isFrameLikeObject(candidate)) {
                enqueueFrame(candidate);
            }
        });
    }

    // Extra pass: include objects bound by metadata even when runtime parenting got stale.
    // This guarantees frame eye toggle affects product zones/cards that belong to the frame.
    let expanded = true;
    while (expanded) {
        expanded = false;

        const zoneIds = new Set<string>();
        targetSet.forEach((entry: any) => {
            if (!entry || !isLikelyProductZone(entry)) return;
            const zoneId = String(entry._customId || '').trim();
            if (zoneId) zoneIds.add(zoneId);
        });

        allObjects.forEach((candidate: any) => {
            if (!candidate || targetSet.has(candidate)) return;
            if (candidate.excludeFromExport) return;
            if (isControlLikeObject(candidate) || isTransientCanvasObject(candidate)) return;
            if (String(candidate.id || '') === 'artboard-bg') return;

            const candidateParentFrameId = String((candidate as any).parentFrameId || '').trim();
            const candidateZoneId = String((candidate as any).parentZoneId || (candidate as any)?._zoneSlot?.zoneId || '').trim();

            let shouldInclude = false;

            if (candidateParentFrameId && visitedFrameIds.has(candidateParentFrameId)) {
                shouldInclude = true;
            }

            if (!shouldInclude && candidateZoneId && zoneIds.has(candidateZoneId)) {
                shouldInclude = true;
            }

            if (!shouldInclude) return;

            targetSet.add(candidate);
            expanded = true;

            if (candidate.isFrame || isFrameLikeObject(candidate)) {
                enqueueFrame(candidate);
            }
        });
    }

    return Array.from(targetSet);
};

const applyObjectVisibility = (entry: any, visible: boolean) => {
    if (!entry) return;

    entry.set?.('visible', visible);
    entry.visible = visible;

    // Reduce interaction cost while hidden and restore previous state on show.
    if (!visible) {
        if ((entry as any).__prevEventedBeforeEyeToggle === undefined) {
            (entry as any).__prevEventedBeforeEyeToggle = entry.evented;
        }
        if ((entry as any).__prevSelectableBeforeEyeToggle === undefined) {
            (entry as any).__prevSelectableBeforeEyeToggle = entry.selectable;
        }
        entry.set?.('evented', false);
        entry.set?.('selectable', false);
        entry.evented = false;
        entry.selectable = false;
    } else {
        const prevEvented = (entry as any).__prevEventedBeforeEyeToggle;
        const prevSelectable = (entry as any).__prevSelectableBeforeEyeToggle;
        if (prevEvented !== undefined) {
            entry.set?.('evented', prevEvented);
            entry.evented = prevEvented;
            delete (entry as any).__prevEventedBeforeEyeToggle;
        } else {
            entry.set?.('evented', true);
            entry.evented = true;
        }
        if (prevSelectable !== undefined) {
            entry.set?.('selectable', prevSelectable);
            entry.selectable = prevSelectable;
            delete (entry as any).__prevSelectableBeforeEyeToggle;
        } else {
            entry.set?.('selectable', true);
            entry.selectable = true;
        }
    }

    entry.dirty = true;
    entry.setCoords?.();
};

const moveFrameDescendants = (frame: any, dx: number, dy: number, descendants?: any[]) => {
    if (!canvas.value) return;
    if (!dx && !dy) return;
    const list = Array.isArray(descendants) ? descendants : getFrameDescendants(frame);
    list.forEach((child: any) => {
        if (!child || child.excludeFromExport) return;
        child.set?.({
            left: (child.left ?? 0) + dx,
            top: (child.top ?? 0) + dy
        });
        child.setCoords?.();
    });
};

// --- Shape Utilities (Figma-ish) ---
const isRectObject = (obj: any) => String(obj?.type || '').toLowerCase() === 'rect';

const clampCornerRadii = (radii: any, w: number, h: number) => {
    const clamp = (n: any) => {
        const v = Math.max(0, Number(n || 0));
        return Math.min(v, w / 2, h / 2);
    };
    return {
        tl: clamp(radii?.tl),
        tr: clamp(radii?.tr),
        br: clamp(radii?.br),
        bl: clamp(radii?.bl)
    };
};

// Per-corner rounding by patching Fabric's Rect `_render` (keeps Rect behavior + resizing).
const applyRectCornerRadiiPatch = (rect: any) => {
    if (!rect || !isRectObject(rect) || typeof rect._renderPaintInOrder !== 'function') return;
    const radii = rect.cornerRadii;
    const has = !!(radii && typeof radii === 'object');

    if (!has) {
        // No custom corner radii - restore original render method
        // This allows Fabric.js's native rx/ry to work correctly
        if ((rect as any).__origRender) {
            rect._render = (rect as any).__origRender;
            delete (rect as any).__origRender;
            rect.dirty = true;
        }
        return;
    }

    if (!(rect as any).__origRender) (rect as any).__origRender = rect._render;

    rect._render = function (ctx: CanvasRenderingContext2D) {
        const w = this.width;
        const h = this.height;
        const x = -w / 2;
        const y = -h / 2;
        const k = 1 - 0.5522847498;
        const r = clampCornerRadii(this.cornerRadii, w, h);

        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        r.tr && ctx.bezierCurveTo(x + w - k * r.tr, y, x + w, y + k * r.tr, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        r.br && ctx.bezierCurveTo(x + w, y + h - k * r.br, x + w - k * r.br, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        r.bl && ctx.bezierCurveTo(x + k * r.bl, y + h, x, y + h - k * r.bl, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        r.tl && ctx.bezierCurveTo(x, y + k * r.tl, x + k * r.tl, y, x + r.tl, y);
        ctx.closePath();
        this._renderPaintInOrder(ctx);
    };
    // Avoid double rounding via rx/ry - ONLY when using custom cornerRadii
    // This ensures Fabric.js's native rx/ry works when not using custom radii
    rect.set?.({ rx: 0, ry: 0 });
    rect.dirty = true;
};

const isTransparentPaint = (v: any) => {
    if (v == null) return true;
    if (v === '' || v === 'transparent') return true;
    if (typeof v !== 'string') return false;
    return v.startsWith('rgba') && v.replace(/\s/g, '').endsWith(',0)');
};

const toggleFill = (obj: any, enabled: boolean) => {
    if (!obj) return;
    (obj as any).__fillEnabled = !!enabled;
    if (enabled) {
        const prev = (obj as any).__fillBackup;
        const next = !isTransparentPaint(prev) ? prev : (!isTransparentPaint(obj.fill) ? obj.fill : '#ffffff');
        obj.set?.('fill', next);
    } else {
        (obj as any).__fillBackup = obj.fill;
        obj.set?.('fill', 'rgba(0,0,0,0)');
    }
};

const toggleStroke = (obj: any, enabled: boolean) => {
    if (!obj) return;
    (obj as any).__strokeEnabled = !!enabled;
    if (enabled) {
        const strokePrev = (obj as any).__strokeBackup;
        const widthPrev = (obj as any).__strokeWidthBackup;
        const dashPrev = (obj as any).__strokeDashBackup;
        if (strokePrev) obj.set?.('stroke', strokePrev);
        if (widthPrev != null) obj.set?.('strokeWidth', Number(widthPrev) || 1);
        if (dashPrev != null) obj.set?.('strokeDashArray', dashPrev);
        if (!obj.stroke) obj.set?.('stroke', '#000000');
        if (!obj.strokeWidth || obj.strokeWidth <= 0) obj.set?.('strokeWidth', 1);
    } else {
        (obj as any).__strokeBackup = obj.stroke;
        (obj as any).__strokeWidthBackup = obj.strokeWidth;
        (obj as any).__strokeDashBackup = obj.strokeDashArray;
        obj.set?.({ stroke: 'rgba(0,0,0,0)', strokeWidth: 0, strokeDashArray: null });
    }
};

// ─── Sticker Outline (alpha-based contour) ───────────────────────────────
// Generates an outline that follows the alpha channel of PNGs (not a bounding-box border).
// Uses offscreen canvas + alpha dilation + color fill, cached for performance.

/** Detect whether an image has any transparent pixel (alpha < 255). */
const imageHasTransparency = (img: HTMLImageElement | HTMLCanvasElement): boolean => {
    try {
        const oc = document.createElement('canvas');
        const w = (img as any).naturalWidth || img.width;
        const h = (img as any).naturalHeight || img.height;
        if (!w || !h) return false;
        // Sample at reduced size for speed
        const maxDim = 256;
        const scale = Math.min(1, maxDim / Math.max(w, h));
        oc.width = Math.ceil(w * scale);
        oc.height = Math.ceil(h * scale);
        const octx = oc.getContext('2d', { willReadFrequently: true });
        if (!octx) return false;
        octx.drawImage(img, 0, 0, oc.width, oc.height);
        const data = octx.getImageData(0, 0, oc.width, oc.height).data;
        for (let i = 3; i < data.length; i += 4) {
            if (data[i]! < 250) return true;
        }
        return false;
    } catch { return false; }
};

/**
 * Generate a professional sticker outline canvas from source alpha.
 *
 * KEY TECHNIQUES for smooth, jagged-free outlines:
 *   1. Supersampling 2x — compute distance field at double resolution, then
 *      downsample with bilinear filtering for natural anti-aliasing.
 *   2. Alpha-weighted initial distances — instead of a binary inside/outside mask,
 *      use the actual alpha values (0-1) as sub-pixel offsets in the EDT.
 *      This preserves the anti-aliasing of the source image edges.
 *   3. Quintic smoothstep (6t⁵ − 15t⁴ + 10t³) — smoother C² transition
 *      vs the cubic hermite (3t² − 2t³) used before.
 *   4. Wider soft edge — the fade-out zone is proportional to the outline
 *      width, giving thick outlines a softer, more natural look.
 */
const generateStickerOutlineCanvas = (
    img: HTMLImageElement | HTMLCanvasElement,
    outlineWidth: number,
    outlineColor: string,
    outlineOpacity: number,
    outlineMode: 'outside' | 'inside' = 'outside'
): HTMLCanvasElement | null => {
    try {
        // If the image element isn't ready yet, return null and let the caller retry.
        if (img && (img as any).tagName === 'IMG') {
            const im = img as HTMLImageElement;
            if (!im.complete || (im.naturalWidth || 0) <= 0 || (im.naturalHeight || 0) <= 0) {
                return null;
            }
        }

        const srcW = (img as any).naturalWidth || img.width;
        const srcH = (img as any).naturalHeight || img.height;
        if (!srcW || !srcH || outlineWidth <= 0) return null;

        // ── Supersampling factor ──────────────────────────────────────────
        // 2x removes visible stair-stepping; fall back to 1x for very large
        // images to keep memory under control (< 16 M pixels in the grid).
        let ssScale = 2;
        const ssW = srcW * ssScale;
        const ssH = srcH * ssScale;
        const wSs = outlineWidth * ssScale;
        const softSs = Math.max(1.5 * ssScale, wSs * 0.35);
        let padSs = Math.ceil(wSs + softSs + ssScale * 3);
        let gridW = ssW + padSs * 2;
        let gridH = ssH + padSs * 2;
        if (gridW * gridH > 16_000_000) {
            // Image too large for 2x — fall back to 1x supersampling
            ssScale = 1;
        }

        // Recalculate dimensions with final ssScale
        const finalSsW = srcW * ssScale;
        const finalSsH = srcH * ssScale;
        const wScaled = outlineWidth * ssScale;
        const softScaled = Math.max(1.5 * ssScale, wScaled * 0.35);
        padSs = Math.ceil(wScaled + softScaled + ssScale * 3);
        const cw = finalSsW + padSs * 2;
        const ch = finalSsH + padSs * 2;
        const size = cw * ch;

        // ── 1) Draw source at supersampled resolution ─────────────────────
        const srcCanvas = document.createElement('canvas');
        srcCanvas.width = finalSsW;
        srcCanvas.height = finalSsH;
        const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
        if (!srcCtx) return null;
        srcCtx.imageSmoothingEnabled = true;
        srcCtx.imageSmoothingQuality = 'high';
        srcCtx.drawImage(img, 0, 0, finalSsW, finalSsH);
        const srcData = srcCtx.getImageData(0, 0, finalSsW, finalSsH).data;

        // ── 2) Build alpha map (float 0–1) preserving AA edge data ────────
        const alphaMap = new Float32Array(size);
        for (let y = 0; y < finalSsH; y++) {
            const srcRow = y * finalSsW;
            const dstRow = (y + padSs) * cw;
            for (let x = 0; x < finalSsW; x++) {
                alphaMap[dstRow + (x + padSs)] = (srcData[(srcRow + x) * 4 + 3] as number) / 255;
            }
        }

	        // `inside`: any non-zero alpha counts as "inside" so the outline never bleeds
	        // through anti-aliased edges (alpha=1 is 1/255 ≈ 0.00392).
	        const inside = new Uint8Array(size);
	        for (let i = 0; i < size; i++) {
	            if (alphaMap[i]! > 0) inside[i] = 1;
	        }

	        // `barrier`: a stronger mask for flood-fill so the "outside" region can't leak
	        // into internal holes through tiny AA gaps. We dilate by 1px to seal.
	        const barrier = new Uint8Array(size);
	        const barrierThreshold = 16 / 255; // ~0.0627
	        for (let i = 0; i < size; i++) {
	            if (alphaMap[i]! >= barrierThreshold) barrier[i] = 1;
	        }
	        // 1px dilation (8-neighborhood)
	        const barrierDilated = new Uint8Array(size);
	        for (let i = 0; i < size; i++) {
	            if (!barrier[i]) continue;
	            barrierDilated[i] = 1;
	            const x = i % cw;
	            const y = (i / cw) | 0;
	            for (let dy = -1; dy <= 1; dy++) {
	                const yy = y + dy;
	                if (yy < 0 || yy >= ch) continue;
	                const row = yy * cw;
	                for (let dx = -1; dx <= 1; dx++) {
	                    const xx = x + dx;
	                    if (xx < 0 || xx >= cw) continue;
	                    barrierDilated[row + xx] = 1;
	                }
	            }
	        }

        // ── 3) Flood-fill external background ─────────────────────────────
        // Prevents outline from appearing inside internal "holes" (professional sticker style).
	        const outside = new Uint8Array(size);
	        const queue = new Int32Array(size);
	        let qh = 0;
	        let qt = 0;
	        const tryEnqueue = (idx: number) => {
	            if (idx < 0 || idx >= size || outside[idx] || barrierDilated[idx]) return;
	            outside[idx] = 1;
	            queue[qt++] = idx;
	        };
        for (let x = 0; x < cw; x++) { tryEnqueue(x); tryEnqueue((ch - 1) * cw + x); }
        for (let y = 1; y < ch - 1; y++) { tryEnqueue(y * cw); tryEnqueue(y * cw + cw - 1); }
        while (qh < qt) {
            const idx = queue[qh++]!;
            const x = idx % cw;
            const y = (idx / cw) | 0;
            if (x > 0) tryEnqueue(idx - 1);
            if (x < cw - 1) tryEnqueue(idx + 1);
            if (y > 0) tryEnqueue(idx - cw);
            if (y < ch - 1) tryEnqueue(idx + cw);
        }

        // ── 4) Euclidean Distance Transform (EDT) ─────────────────────────
        // Alpha-weighted initial distances: fully opaque → 0, semi-transparent
        // edge → small sub-pixel offset, fully transparent → INF.
        const INF = 1e20;
        const maxN = Math.max(cw, ch);
        const f = new Float64Array(maxN);
        const d = new Float64Array(maxN);
        const v = new Int32Array(maxN);
        const z = new Float64Array(maxN + 1);

        const edt1d = (n: number) => {
            let k = 0;
            v[0] = 0;
            z[0] = -INF;
            z[1] = INF;
            for (let q = 1; q < n; q++) {
                let s = ((f[q]! + q * q) - (f[v[k]!]! + v[k]! * v[k]!)) / (2 * (q - v[k]!));
                while (k > 0 && s <= z[k]!) {
                    k--;
                    s = ((f[q]! + q * q) - (f[v[k]!]! + v[k]! * v[k]!)) / (2 * (q - v[k]!));
                }
                k++;
                v[k] = q;
                z[k] = s;
                z[k + 1] = INF;
            }
            k = 0;
            for (let q = 0; q < n; q++) {
                while (z[k + 1]! < q) k++;
                const dx = q - v[k]!;
                d[q] = dx * dx + f[v[k]!]!;
            }
        };

        const computeDistSq = (initFn: (idx: number) => number) => {
            // Row pass
            const rowDT = new Float32Array(size);
            for (let y = 0; y < ch; y++) {
                const row = y * cw;
                for (let x = 0; x < cw; x++) f[x] = initFn(row + x);
                edt1d(cw);
                for (let x = 0; x < cw; x++) rowDT[row + x] = d[x] as number;
            }
            // Column pass
            const distSq = new Float32Array(size);
            for (let x = 0; x < cw; x++) {
                for (let y = 0; y < ch; y++) f[y] = rowDT[y * cw + x] as number;
                edt1d(ch);
                for (let y = 0; y < ch; y++) distSq[y * cw + x] = d[y] as number;
            }
            return distSq;
        };

        // Distance to nearest "inside" — alpha-weighted for sub-pixel accuracy.
        const distSqToInside = computeDistSq((idx) => {
            const a = alphaMap[idx]!;
            if (a >= 0.99) return 0;
            if (a > 0.01) return (1 - a) * (1 - a); // sub-pixel offset proportional to transparency
            return INF;
        });

        // Distance to nearest "outside-connected" pixel (for inside-mode outline).
        const distSqToOutside = outlineMode === 'inside'
            ? computeDistSq((idx) => outside[idx] ? 0 : INF)
            : null;

        // ── 5) Render outline at supersampled resolution ──────────────────
        const ssOutCanvas = document.createElement('canvas');
        ssOutCanvas.width = cw;
        ssOutCanvas.height = ch;
        const ssOutCtx = ssOutCanvas.getContext('2d');
        if (!ssOutCtx) return null;

        const outImgData = ssOutCtx.createImageData(cw, ch);

        // Parse outline color via a 1×1 canvas (supports any CSS color string).
        const tmpC = document.createElement('canvas');
        tmpC.width = 1;
        tmpC.height = 1;
        const tmpCtx = tmpC.getContext('2d')!;
        tmpCtx.fillStyle = outlineColor || '#000000';
        tmpCtx.fillRect(0, 0, 1, 1);
        const cd = tmpCtx.getImageData(0, 0, 1, 1).data;
        const cr = cd[0] as number;
        const cg = cd[1] as number;
        const cb = cd[2] as number;
        const baseAlpha = Math.min(1, Math.max(0, outlineOpacity));

        const maxDist = wScaled + softScaled;
        const maxDistSq = maxDist * maxDist;

        for (let i = 0; i < size; i++) {
            const isIn = !!inside[i];

            if (outlineMode === 'outside') {
                // Preenche TUDO que não é "inside" (inclui buracos internos de letras
                // como R, O, D, G etc.) — efeito sticker sólido sem vazios.
                if (isIn) continue;
            } else {
                if (!isIn) continue;
            }

            const dsq = outlineMode === 'inside'
                ? (distSqToOutside ? distSqToOutside[i]! : INF)
                : distSqToInside[i]!;
            if (dsq > maxDistSq) continue;

            const dist = Math.sqrt(dsq);
            // Quintic smoothstep: 6t⁵ − 15t⁴ + 10t³ — C² continuous, much smoother.
            const raw = (maxDist - dist) / softScaled;
            const t = raw <= 0 ? 0 : raw >= 1 ? 1 : raw;
            const smoothT = t * t * t * (t * (t * 6 - 15) + 10);
            const a = Math.round(baseAlpha * smoothT * 255);
            if (a <= 0) continue;

            const o = i * 4;
            outImgData.data[o] = cr;
            outImgData.data[o + 1] = cg;
            outImgData.data[o + 2] = cb;
            outImgData.data[o + 3] = a;
        }

        ssOutCtx.putImageData(outImgData, 0, 0);

        // ── 6) Downsample to native resolution ────────────────────────────
        // The bilinear/bicubic downsampling acts as a free anti-aliasing pass.
        // CRITICAL: finalPad MUST equal padSs/ssScale so that the image-to-padding
        // ratio is identical in both the supersampled and final canvases.
        // Using an independent formula causes the outline to be displaced.
        const finalPad = Math.ceil(padSs / ssScale);
        const finalW = srcW + finalPad * 2;
        const finalH = srcH + finalPad * 2;

        const outCanvas = document.createElement('canvas');
        outCanvas.width = finalW;
        outCanvas.height = finalH;
        const outCtx = outCanvas.getContext('2d')!;
        if (!outCtx) return null;
        outCtx.imageSmoothingEnabled = true;
        outCtx.imageSmoothingQuality = 'high';
        outCtx.drawImage(ssOutCanvas, 0, 0, cw, ch, 0, 0, finalW, finalH);

        // Store effective padding + source dimensions so the render patch
        // can align the outline pixel-perfectly even if obj.width differs.
        (outCanvas as any).__outlinePad = finalPad;
        (outCanvas as any).__outlineSrcW = srcW;
        (outCanvas as any).__outlineSrcH = srcH;

        return outCanvas;
    } catch (e) {
        console.error('[StickerOutline] Erro ao gerar outline:', e);
        return null;
    }
};

/** Apply or remove the sticker outline render patch on a fabric.Image object. */
	const applyStickerOutlinePatch = (obj: any) => {
	    if (!obj || String(obj.type || '').toLowerCase() !== 'image') return;

	    const enabled = !!(obj as any).__stickerOutlineEnabled;
	    const width = Number((obj as any).__stickerOutlineWidth) || 4;
	    const color = (obj as any).__stickerOutlineColor || '#FFFFFF';
	    const opacity = (obj as any).__stickerOutlineOpacity ?? 1;
	    const mode: 'outside' | 'inside' = ((obj as any).__stickerOutlineMode === 'inside') ? 'inside' : 'outside';
	    if (!(obj as any).__stickerOutlineMode) (obj as any).__stickerOutlineMode = mode;

	    // Clear cache when params change
	    const cacheKey = `${enabled}|${mode}|${width}|${color}|${opacity}|${obj.width}|${obj.height}`;
	    if ((obj as any).__stickerCacheKey !== cacheKey) {
	        (obj as any).__stickerOutlineCache = null;
	        (obj as any).__stickerCacheKey = cacheKey;
	    }

	    if (!enabled) {
	        // Restore caching behavior (outline draws outside bounds; we disable caching while enabled to avoid clipping).
	        if ((obj as any).__stickerOrigObjectCaching !== undefined) {
	            obj.objectCaching = (obj as any).__stickerOrigObjectCaching;
	            delete (obj as any).__stickerOrigObjectCaching;
	        }
	        // Clear any stale cache canvas that may have been created while caching was enabled.
	        try {
	            (obj as any)._cacheCanvas = null;
	            (obj as any)._cacheContext = null;
	        } catch {
	            // ignore
	        }
	        // Remove patch, restore original drawObject
	        if ((obj as any).__origDrawObjectSticker) {
	            obj.drawObject = (obj as any).__origDrawObjectSticker;
	            delete (obj as any).__origDrawObjectSticker;
	        }
	        // Remove render patch, restore original render
	        if ((obj as any).__origRenderSticker) {
	            obj.render = (obj as any).__origRenderSticker;
	            delete (obj as any).__origRenderSticker;
	        }
	        (obj as any).__stickerOutlineCache = null;
	        obj.dirty = true;
	        return;
	    }

	    // CRITICAL: Fabric caches objects into a bounded offscreen canvas.
	    // Our sticker outline deliberately draws outside the image bounds and would get clipped.
	    // Disable caching while enabled for correctness.
	    if ((obj as any).__stickerOrigObjectCaching === undefined) {
	        (obj as any).__stickerOrigObjectCaching = obj.objectCaching;
	    }
	    obj.objectCaching = false;
	    // Ensure any previously computed cache gets dropped immediately.
	    try {
	        (obj as any)._cacheCanvas = null;
	        (obj as any)._cacheContext = null;
	    } catch {
	        // ignore
	    }

    // Patch drawObject — called by render() AFTER ctx transform is applied
    // Pipeline: render() → ctx.save() → transform(ctx) → drawObject(ctx) → ctx.restore()
    // So inside drawObject, we're in the object's local coordinate space.
    if (!(obj as any).__origDrawObjectSticker) {
        (obj as any).__origDrawObjectSticker = obj.drawObject;
    }

    obj.drawObject = function (ctx: CanvasRenderingContext2D, forClipping: boolean, context: any) {
	        const drawOutline = () => {
	            if (forClipping || !this.__stickerOutlineEnabled || !this.__stickerOutlineCache) return;
                // Never draw outline for hidden objects (or hidden parent groups/frames).
                if (this.visible === false || Number(this.opacity ?? 1) <= 0) return;
                let ancestor: any = this.group;
                let guard = 0;
                while (ancestor && guard++ < 20) {
                    if (ancestor.visible === false || Number(ancestor.opacity ?? 1) <= 0) return;
                    ancestor = ancestor.group;
                }
                // If parent frame is hidden, suppress sticker outline as well.
                const parentFrameId = String((this as any).parentFrameId || '').trim();
                if (parentFrameId && canvas.value) {
                    const parentFrame = canvas.value.getObjects().find((o: any) => String(o?._customId || '') === parentFrameId);
                    if (parentFrame && parentFrame.visible === false) return;
                }
	            try {
	                const cache = this.__stickerOutlineCache;
	                const pad = (cache as any).__outlinePad || (Math.ceil(Number(this.__stickerOutlineWidth) || 4) + 2);
	                const cacheW = cache.width;
	                const cacheH = cache.height;
	                const srcW = (cache as any).__outlineSrcW || (cacheW - pad * 2);
	                const srcH = (cache as any).__outlineSrcH || (cacheH - pad * 2);
	                const w = this.width;
	                const h = this.height;
	                const sx = w / srcW;
	                const sy = h / srcH;
	                const drawW = cacheW * sx;
	                const drawH = cacheH * sy;
	                ctx.drawImage(
	                    cache,
	                    -drawW / 2,
	                    -drawH / 2,
	                    drawW,
	                    drawH
	                );
	            } catch {
	                // Silent — never break image rendering
	            }
	        };

	        // INSIDE mode: draw outline on top of image (dentro do clip context).
	        // OUTSIDE mode: NÃO desenha aqui — é desenhado no render() fora do clipPath.
	        const res = (this as any).__origDrawObjectSticker.call(this, ctx, forClipping, context);

	        const mode: 'outside' | 'inside' = (this as any).__stickerOutlineMode === 'inside' ? 'inside' : 'outside';
	        if (mode === 'inside') drawOutline();
	        return res;
	    };

    // Patch render — para outside mode, desenha o contorno FORA do clipPath context.
    // Isso garante que o contorno se estenda além dos limites do frame/artboard.
    if (!(obj as any).__origRenderSticker) {
        (obj as any).__origRenderSticker = obj.render;
    }

    obj.render = function (ctx: CanvasRenderingContext2D) {
        // Respect visibility before any custom outside-outline draw.
        if (this.visible === false || Number(this.opacity ?? 1) <= 0) return;
        let ancestor: any = this.group;
        let guard = 0;
        while (ancestor && guard++ < 20) {
            if (ancestor.visible === false || Number(ancestor.opacity ?? 1) <= 0) return;
            ancestor = ancestor.group;
        }
        const parentFrameId = String((this as any).parentFrameId || '').trim();
        if (parentFrameId && canvas.value) {
            const parentFrame = canvas.value.getObjects().find((o: any) => String(o?._customId || '') === parentFrameId);
            if (parentFrame && parentFrame.visible === false) return;
        }

        // Render normal (com clipPath/frame clipping aplicado)
        (this as any).__origRenderSticker.call(this, ctx);

        // OUTSIDE mode: desenha o contorno APÓS o render completo,
        // em seu próprio save/restore — sem herdar o clipPath.
        // O outline cache só contém pixels onde a imagem é transparente,
        // então desenhar por cima não cobre o conteúdo da imagem.
        const mode: 'outside' | 'inside' = (this as any).__stickerOutlineMode === 'inside' ? 'inside' : 'outside';
        if (mode === 'outside' && this.__stickerOutlineEnabled && this.__stickerOutlineCache) {
            try {
                const cache = this.__stickerOutlineCache;
                const cacheW = cache.width;
                const cacheH = cache.height;
                const pad = (cache as any).__outlinePad || 0;
                const srcW = (cache as any).__outlineSrcW || (cacheW - pad * 2);
                const srcH = (cache as any).__outlineSrcH || (cacheH - pad * 2);
                const w = this.width;
                const h = this.height;
                const sx = w / srcW;
                const sy = h / srcH;
                const drawW = cacheW * sx;
                const drawH = cacheH * sy;

                ctx.save();
                // Aplica a mesma transformação do objeto (posição, escala, rotação)
                const m = this.calcTransformMatrix();
                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                // Respeitar opacidade do objeto
                ctx.globalAlpha *= (this.opacity || 1);
                ctx.drawImage(
                    cache,
                    -drawW / 2,
                    -drawH / 2,
                    drawW,
                    drawH
                );
                ctx.restore();
            } catch {
                // Silent — never break image rendering
            }
        }
    };

    obj.dirty = true;

    // Generate outline canvas — with retry mechanism for images not yet loaded
    const tryGenerate = (attempt: number) => {
        const el = obj._element || obj.getElement?.();
        const maxAttempts = 6;
        const delays = [80, 180, 350, 700, 1500, 3000];

        const isImgEl = el && (el as any).tagName === 'IMG';
        const ready =
            !!el &&
            (!isImgEl ||
                (((el as HTMLImageElement).complete) &&
                    (((el as HTMLImageElement).naturalWidth || 0) > 0) &&
                    (((el as HTMLImageElement).naturalHeight || 0) > 0)));

        if (!ready) {
            if (attempt < maxAttempts) {
                setTimeout(() => {
                    if ((obj as any).__stickerOutlineEnabled) tryGenerate(attempt + 1);
                }, delays[attempt] ?? 1000);
            }
            return;
        }

	        try {
	            const outCanvas = generateStickerOutlineCanvas(el, width, color, opacity, mode);
	            if (outCanvas) {
	                (obj as any).__stickerOutlineCache = outCanvas;
	                obj.dirty = true;
	                canvas.value?.renderAll?.();
                return;
            }
        } catch (e) {
            console.warn('[StickerOutline] Erro ao gerar outline:', e);
        }

        // Generation can fail while the image is still decoding; retry a few times.
        if (attempt < maxAttempts) {
            setTimeout(() => {
                if ((obj as any).__stickerOutlineEnabled) tryGenerate(attempt + 1);
            }, delays[attempt] ?? 1000);
        }
    };

    if (!(obj as any).__stickerOutlineCache) {
        setTimeout(() => tryGenerate(0), 30);
    }
};

/** Invalidate sticker outline cache and regenerate asynchronously. */
const invalidateStickerOutlineCache = (obj: any) => {
    if (!obj) return;
    (obj as any).__stickerOutlineCache = null;
    (obj as any).__stickerCacheKey = null;
    obj.dirty = true;

    // Regenerate async if enabled
    if ((obj as any).__stickerOutlineEnabled) {
        const el = obj._element || obj.getElement?.();
        // Let `applyStickerOutlinePatch` handle retry/backoff reliably.
        setTimeout(() => {
            try {
                applyStickerOutlinePatch(obj);
            } catch {
                // ignore
            }
        }, el ? 50 : 120);
    }
};

const setTool = (tool: 'select' | 'draw' | 'pen') => {
    if (!canvas.value) return;

    // Reset States
    isNodeEditing.value = false;
    exitNodeEditing();
    isPenMode.value = false;
    penPathPoints.value = [];
    currentPenPath.value = null;
    
    if (tool === 'draw') {
        isDrawing.value = true;
        canvas.value.isDrawingMode = true;
        canvas.value.discardActiveObject();
        canvas.value.requestRenderAll();

        // Setup Brush
        if (!canvas.value.freeDrawingBrush) {
            canvas.value.freeDrawingBrush = new fabric.PencilBrush(canvas.value);
        }
        // Ensure defaults or keep previous
        if(!canvas.value.freeDrawingBrush.width) canvas.value.freeDrawingBrush.width = 5;
        if(!canvas.value.freeDrawingBrush.color) canvas.value.freeDrawingBrush.color = "#ffffff";

        // Create a Proxy Object for Properties Panel
        // This allows the user to edit the Brush using the existing sidebar
        const brushProxy = {
            _customId: 'brush-settings',
            type: 'brush-proxy', // Custom type for logic
            name: 'Configurações do Pincel',
            stroke: canvas.value.freeDrawingBrush.color,
            strokeWidth: canvas.value.freeDrawingBrush.width,
            strokeLineCap: (canvas.value.freeDrawingBrush as any).strokeLineCap || 'round',
            strokeLineJoin: (canvas.value.freeDrawingBrush as any).strokeLineJoin || 'round',
            strokeDashArray: (canvas.value.freeDrawingBrush as any).strokeDashArray || null,
            fill: canvas.value.freeDrawingBrush.color, // Mirror color to fill for UI convenience
            opacity: 1,
            visible: true,
            lockMovementX: false,
            // Mock methods to prevent UI errors
            getBoundingRect: () => ({ top: 0, left: 0, width: 0, height: 0 }),
            getScaledWidth: () => 0,
            getScaledHeight: () => 0,
            set: (key: string, val: any) => { /* handled in updateObjectProperty */ }
        };
        
        selectedObjectRef.value = brushProxy;
        triggerRef(selectedObjectRef);
        
    } else if (tool === 'pen') {
        // Pen Tool Mode (Vector Path Creation)
        isPenMode.value = true;
        isDrawing.value = false;
        canvas.value.isDrawingMode = false;
        canvas.value.discardActiveObject();
        canvas.value.defaultCursor = 'crosshair';
        canvas.value.selection = false; // Disable rubber-band selection in pen mode
        // Make all objects non-selectable during pen mode
        canvas.value.getObjects().forEach((o: any) => {
            o._prevEvented = o.evented;
            o.evented = false;
        });
        canvas.value.requestRenderAll();
        
    } else {
        // Select Mode
        isDrawing.value = false;
        canvas.value.isDrawingMode = false;
        canvas.value.defaultCursor = 'default';
        canvas.value.selection = true; // Re-enable rubber-band selection
        // Restore evented state for all objects
        canvas.value.getObjects().forEach((o: any) => {
            if (o._prevEvented !== undefined) {
                o.evented = o._prevEvented;
                delete o._prevEvented;
            } else {
                o.evented = true;
            }
        });
        selectedObjectRef.value = null;
        triggerRef(selectedObjectRef);
    }
}

const toggleDrawing = () => {
    if (isDrawing.value) setTool('select');
    else setTool('draw');
}

const togglePenMode = () => {
    if (isPenMode.value) {
        // Finish current path if exists
        finishPenPath();
        currentMousePos.value = null;
        setTool('select');
    } else {
        setTool('pen');
    }
}

// ============================================================================
// PEN TOOL - Vector Path Creation & Editing (Figma Style)
// ============================================================================

const getTargetVectorPath = (): any | null => {
    if (!canvas.value) return null;
    const active = canvas.value.getActiveObject?.();
    if (active?.isVectorPath) return active;
    if (isNodeEditing.value && currentEditingPath.value?.isVectorPath) return currentEditingPath.value;
    return null;
};

const isPathCloseCommand = (segment: any): boolean => {
    if (Array.isArray(segment)) {
        return String(segment[0] || '').toLowerCase() === 'z';
    }
    return String(segment || '').toLowerCase() === 'z';
};

const isVectorPathClosed = (pathObj: any): boolean => {
    if (!pathObj) return false;
    if (pathObj.isClosedPath === true) return true;
    const segments = Array.isArray(pathObj.path) ? pathObj.path : [];
    return segments.some(isPathCloseCommand);
};

const buildPathStringFromPenData = (pathData: any[], closed = false): string => {
    if (!Array.isArray(pathData) || pathData.length === 0) return '';
    let pathString = '';
    pathData.forEach((point: any, index: number) => {
        if (index === 0) {
            pathString += `M ${point.x} ${point.y}`;
        } else {
            const prevPoint = pathData[index - 1];
            if (prevPoint && point?.handles?.in) {
                const cp1x = prevPoint?.handles?.out?.x ?? prevPoint.x;
                const cp1y = prevPoint?.handles?.out?.y ?? prevPoint.y;
                const cp2x = point.handles.in.x;
                const cp2y = point.handles.in.y;
                pathString += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${point.x} ${point.y}`;
            } else {
                pathString += ` L ${point.x} ${point.y}`;
            }
        }
    });
    if (closed && pathData.length > 2) pathString += ' Z';
    return pathString;
};

const createVectorPathFromPenData = (
    pathData: any[],
    opts: { closed?: boolean; source?: any } = {}
): any | null => {
    const normalized = JSON.parse(JSON.stringify(Array.isArray(pathData) ? pathData : []));
    if (normalized.length < 2) return null;
    const closed = !!opts.closed;
    const pathString = buildPathStringFromPenData(normalized, closed);
    if (!pathString) return null;
    const source = opts.source || {};
    return new fabric.Path(pathString, {
        fill: source.fill ?? 'transparent',
        stroke: source.stroke ?? '#0d99ff',
        strokeWidth: Number(source.strokeWidth ?? penStrokeWidth.value ?? 3),
        strokeLineCap: source.strokeLineCap ?? 'round',
        strokeLineJoin: source.strokeLineJoin ?? 'round',
        strokeDashArray: Array.isArray(source.strokeDashArray) ? [...source.strokeDashArray] : null,
        selectable: true,
        evented: true,
        opacity: Number.isFinite(Number(source.opacity)) ? Number(source.opacity) : 1,
        _customId: Math.random().toString(36).substr(2, 9),
        name: source.name || 'Vector Path',
        isVectorPath: true,
        isClosedPath: closed,
        penPathData: normalized
    });
};

const getPenPreviewStrokeWidth = () => Math.max(1, Number(penStrokeWidth.value || 3) * 0.67);

// Finish current pen path
const finishPenPath = () => {
    if (!canvas.value || penPathPoints.value.length < 2) {
        // Remove preview path if exists
        if (currentPenPath.value) {
            canvas.value.remove(currentPenPath.value);
            currentPenPath.value = null;
        }
        penPathPoints.value = [];
        return;
    }
    
    // Remove preview path before creating final path
    if (currentPenPath.value) {
        canvas.value.remove(currentPenPath.value);
        currentPenPath.value = null;
    }
    
    const path = createVectorPathFromPenData(penPathPoints.value, { closed: false });
    if (!path) {
        penPathPoints.value = [];
        currentMousePos.value = null;
        if (currentPenPoint.value) {
            canvas.value.remove(currentPenPoint.value);
            currentPenPoint.value = null;
        }
        canvas.value.requestRenderAll();
        return;
    }
    
    canvas.value.add(path);
    canvas.value.setActiveObject(path);
    selectedObjectRef.value = path;
    triggerRef(selectedObjectRef);
    
    // Reset
    penPathPoints.value = [];
    if (currentPenPath.value) {
        canvas.value.remove(currentPenPath.value);
        currentPenPath.value = null;
    }
    if (currentPenPoint.value) {
        canvas.value.remove(currentPenPoint.value);
        currentPenPoint.value = null;
    }
    currentMousePos.value = null;
    canvas.value.requestRenderAll();
    saveCurrentState();
}

// Add point to current pen path
const addPenPoint = (point: {x: number, y: number}, withHandles = false) => {
    if (!isPenMode.value) return;
    
    // Check if clicking near the first point to close the path
    if (penPathPoints.value.length >= 2) {
        const firstPoint = penPathPoints.value[0];
        if (!firstPoint) return;
        const distance = Math.sqrt(
            Math.pow(point.x - firstPoint.x, 2) +
            Math.pow(point.y - firstPoint.y, 2)
        );
        const threshold = 15; // pixels - adjust as needed
        
        if (distance < threshold) {
            // Close the path and finish
            closePath();
            // Reset pen mode to stop creating new lines
            penPathPoints.value = [];
            currentPenPath.value = null;
            currentMousePos.value = null;
            if (canvas.value) {
                canvas.value.requestRenderAll();
            }
            return;
        }
    }
    
    penPathPoints.value.push({
        ...point,
        handles: withHandles ? {
            in: { x: point.x - 20, y: point.y },
            out: { x: point.x + 20, y: point.y }
        } : undefined
    });
    
    // Update preview path
    updatePenPreview();
}

// Update preview path while drawing - REAL-TIME without rastros
const updatePenPreview = () => {
    if (!canvas.value || penPathPoints.value.length < 1) return;
    
    if (penPathPoints.value.length < 2) {
        // Show first point + preview line to mouse position
        const firstPoint = penPathPoints.value[0];
        if (!firstPoint) return;

        // Create/update point circle (only once)
        if (!currentPenPoint.value) {
            currentPenPoint.value = new fabric.Circle({
                left: firstPoint.x,
                top: firstPoint.y,
                radius: 4,
                fill: '#0d99ff',
                stroke: '#ffffff',
                strokeWidth: 1,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                excludeFromExport: true
            });
            canvas.value.add(currentPenPoint.value);
        }
        
        // Only show preview line if mouse position is available
        if (currentMousePos.value) {
            // Ensure coordinates are valid numbers
            const endX = typeof currentMousePos.value.x === 'number' ? currentMousePos.value.x : 0;
            const endY = typeof currentMousePos.value.y === 'number' ? currentMousePos.value.y : 0;
            
            // Update existing preview line OR create new one
            if (currentPenPath.value) {
                // UPDATE existing line path (no create/remove = no rastro!)
                const newPathString = `M ${firstPoint.x} ${firstPoint.y} L ${endX} ${endY}`;
                try {
                    currentPenPath.value.set('path', fabric.util.parsePath(newPathString));
                    currentPenPath.value.setCoords();
                    // Ensure no clipping
                    currentPenPath.value.set('clipTo', undefined);
                    // Force immediate render for smooth preview
                    safeRequestRenderAll();
                } catch (e) {
                    // If update fails, recreate the path
                    canvas.value.remove(currentPenPath.value);
                    currentPenPath.value = new fabric.Path(newPathString, {
                        fill: 'transparent',
                        stroke: '#0d99ff',
                        strokeWidth: getPenPreviewStrokeWidth(),
                        selectable: false,
                        evented: false,
                        excludeFromExport: true,
                        // IMPORTANT: Allow path to render outside viewport bounds
                        clipTo: undefined,
                        objectCaching: false, // Disable caching for real-time updates
                    });
                    canvas.value.add(currentPenPath.value);
                    safeRequestRenderAll();
                }
            } else {
                // CREATE new preview line (only once)
                const newPathString = `M ${firstPoint.x} ${firstPoint.y} L ${endX} ${endY}`;
                currentPenPath.value = new fabric.Path(newPathString, {
                    fill: 'transparent',
                    stroke: '#0d99ff',
                    strokeWidth: getPenPreviewStrokeWidth(),
                    selectable: false,
                    evented: false,
                    excludeFromExport: true,
                    // IMPORTANT: Allow path to render outside viewport bounds
                    clipTo: undefined,
                    objectCaching: false, // Disable caching for real-time updates
                });
                canvas.value.add(currentPenPath.value);
                safeRequestRenderAll();
            }
        } else {
            // Remove preview line if no mouse position
            if (currentPenPath.value) {
                canvas.value.remove(currentPenPath.value);
                currentPenPath.value = null;
                safeRequestRenderAll();
            }
        }
        return;
    }
    
    // Create preview path for multiple points + live line to cursor
    let pathString = '';
    penPathPoints.value.forEach((point, index) => {
        if (index === 0) {
            pathString += `M ${point.x} ${point.y}`;
        } else {
            const prevPoint = penPathPoints.value[index - 1];
            if (prevPoint && point.handles && point.handles.in) {
                const cp1x = prevPoint.handles?.out?.x ?? prevPoint.x;
                const cp1y = prevPoint.handles?.out?.y ?? prevPoint.y;
                const cp2x = point.handles.in.x;
                const cp2y = point.handles.in.y;
                pathString += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${point.x} ${point.y}`;
            } else {
                pathString += ` L ${point.x} ${point.y}`;
            }
        }
    });
    
    // Add live preview line from last point to cursor (Figma-style)
    if (currentMousePos.value) {
        const endX = typeof currentMousePos.value.x === 'number' ? currentMousePos.value.x : 0;
        const endY = typeof currentMousePos.value.y === 'number' ? currentMousePos.value.y : 0;
        pathString += ` L ${endX} ${endY}`;
    }
    
    // Update existing preview OR create new one
    if (currentPenPath.value) {
        try {
            currentPenPath.value.set('path', fabric.util.parsePath(pathString));
            currentPenPath.value.setCoords();
            safeRequestRenderAll();
        } catch (e) {
            canvas.value.remove(currentPenPath.value);
            currentPenPath.value = new fabric.Path(pathString, {
                fill: 'transparent',
                stroke: '#0d99ff',
                strokeWidth: getPenPreviewStrokeWidth(),
                strokeDashArray: null,
                selectable: false,
                evented: false,
                excludeFromExport: true,
                objectCaching: false,
            });
            canvas.value.add(currentPenPath.value);
            safeRequestRenderAll();
        }
    } else {
        currentPenPath.value = new fabric.Path(pathString, {
            fill: 'transparent',
            stroke: '#0d99ff',
            strokeWidth: getPenPreviewStrokeWidth(),
            strokeDashArray: null,
            selectable: false,
            evented: false,
            excludeFromExport: true,
            objectCaching: false,
        });
        canvas.value.add(currentPenPath.value);
        safeRequestRenderAll();
    }
}

// Clear preview when exiting pen mode
watch(isPenMode, (newVal) => {
    if (!newVal && canvas.value) {
        currentMousePos.value = null;
        penPathPoints.value = [];
        
        // Remove preview path
        if (currentPenPath.value) {
            try {
                canvas.value.remove(currentPenPath.value);
            } catch (e) {
                // Ignore if already removed
            }
            currentPenPath.value = null;
        }
        
        // Remove preview point
        if (currentPenPoint.value) {
            try {
                canvas.value.remove(currentPenPoint.value);
            } catch (e) {
                // Ignore if already removed
            }
            currentPenPoint.value = null;
        }
        
        // AGGRESSIVE cleanup: Remove ALL temporary/preview/control objects
        const toRemove = canvas.value.getObjects().filter((o: any) => {
            return isTransientCanvasObject(o);
        });
        
        if (toRemove.length > 0) {
            console.log(`🧹 Limpando ${toRemove.length} objeto(s) de preview/controle ao sair do pen mode`);
            toRemove.forEach((obj: any) => {
                try {
                    canvas.value.remove(obj);
                } catch (e) {
                    // Ignore errors
                }
            });
        }
        
        // Force update canvasObjects to refresh LayersPanel
        refreshCanvasObjects();
        canvas.value.requestRenderAll();
    }
});

// Enter node editing mode for vector paths
const enterPathNodeEditing = (pathObj: any) => {
    if (!pathObj || !pathObj.isVectorPath) return;
    
    isNodeEditing.value = true;
    currentEditingPath.value = pathObj;
    selectedPathNodeIndex.value = null;
    canvas.value.discardActiveObject();
    
    // Restore pen path data if available
    const pathData = pathObj.penPathData || [];
    
    // Create control points for each node
    const vpt = canvas.value.viewportTransform;
    const zoom = canvas.value.getZoom();
    
    pathData.forEach((point: any, index: number) => {
        const canvasX = point.x * zoom + vpt[4];
        const canvasY = point.y * zoom + vpt[5];
        
        // Node point - make it clickable for selection
        const nodeControl = new fabric.Circle({
            left: canvasX,
            top: canvasY,
            radius: 5,
            fill: '#ffffff',
            stroke: '#0d99ff',
            strokeWidth: 2,
            hasControls: false,
            hasBorders: false,
            originX: 'center',
            originY: 'center',
            name: 'path_node',
            data: { index, parentPath: pathObj, type: 'node' },
            selectable: true,
            evented: true,
            excludeFromExport: true // CRITICAL: Don't show in LayersPanel
        });
        
        canvas.value.add(nodeControl);
        
        // Bezier handles if they exist
        if (point.handles) {
            // In handle
            if (point.handles.in) {
                const handleIn = new fabric.Circle({
                    left: point.handles.in.x * zoom + vpt[4],
                    top: point.handles.in.y * zoom + vpt[5],
                    radius: 3,
                    fill: '#ff6b6b',
                    stroke: '#ffffff',
                    strokeWidth: 1,
                    hasControls: false,
                    hasBorders: false,
                    originX: 'center',
                    originY: 'center',
                    name: 'bezier_handle',
                    data: { index, parentPath: pathObj, type: 'handle_in' },
                    excludeFromExport: true // CRITICAL: Don't show in LayersPanel
                });
                canvas.value.add(handleIn);
                
                // Line from node to handle
                const handleLine = new fabric.Line(
                    [canvasX, canvasY, point.handles.in.x * zoom + vpt[4], point.handles.in.y * zoom + vpt[5]],
                    {
                        stroke: '#666666',
                        strokeWidth: 1,
                        strokeDashArray: [3, 3],
                        selectable: false,
                        evented: false,
                        name: 'handle_line',
                        data: { index, parentPath: pathObj },
                        excludeFromExport: true
                    }
                );
                canvas.value.add(handleLine);
            }
            
            // Out handle
            if (point.handles.out) {
                const handleOut = new fabric.Circle({
                    left: point.handles.out.x * zoom + vpt[4],
                    top: point.handles.out.y * zoom + vpt[5],
                    radius: 3,
                    fill: '#4ecdc4',
                    stroke: '#ffffff',
                    strokeWidth: 1,
                    hasControls: false,
                    hasBorders: false,
                    originX: 'center',
                    originY: 'center',
                    name: 'bezier_handle',
                    data: { index, parentPath: pathObj, type: 'handle_out' },
                    excludeFromExport: true // CRITICAL: Don't show in LayersPanel
                });
                canvas.value.add(handleOut);
                
                // Line from node to handle
                const handleLine = new fabric.Line(
                    [canvasX, canvasY, point.handles.out.x * zoom + vpt[4], point.handles.out.y * zoom + vpt[5]],
                    {
                        stroke: '#666666',
                        strokeWidth: 1,
                        strokeDashArray: [3, 3],
                        selectable: false,
                        evented: false,
                        name: 'handle_line',
                        data: { index, parentPath: pathObj },
                        excludeFromExport: true
                    }
                );
                canvas.value.add(handleLine);
            }
        }
    });
    
    pathObj.selectable = false;
    pathObj.evented = false;
    canvas.value.requestRenderAll();
}

// Select a path node
const selectPathNode = (index: number, pathObj: any) => {
    selectedPathNodeIndex.value = index;
    
    // Update visual feedback for selected node
    const nodes = canvas.value.getObjects().filter((o: any) => 
        o.name === 'path_node' && o.data.parentPath === pathObj
    );
    
    nodes.forEach((node: any) => {
        if (node.data.index === index) {
            // Selected node - larger and different color
            node.set({
                radius: 7,
                fill: '#0d99ff',
                stroke: '#ffffff',
                strokeWidth: 3
            });
        } else {
            // Unselected nodes
            node.set({
                radius: 5,
                fill: '#ffffff',
                stroke: '#0d99ff',
                strokeWidth: 2
            });
        }
    });
    
    canvas.value.requestRenderAll();
}

// Clear path node selection
const clearPathNodeSelection = () => {
    selectedPathNodeIndex.value = null;
    if (currentEditingPath.value) {
        const nodes = canvas.value.getObjects().filter((o: any) => 
            o.name === 'path_node' && o.data.parentPath === currentEditingPath.value
        );
        nodes.forEach((node: any) => {
            node.set({
                radius: 5,
                fill: '#ffffff',
                stroke: '#0d99ff',
                strokeWidth: 2
            });
        });
        canvas.value.requestRenderAll();
    }
}

// Update handle lines visually during editing
const updateHandleLines = (pathObj: any) => {
    const vpt = canvas.value.viewportTransform;
    const zoom = canvas.value.getZoom();
    
    // Remove old handle lines
    const oldLines = canvas.value.getObjects().filter((o: any) => 
        o.name === 'handle_line' && o.data.parentPath === pathObj
    );
    oldLines.forEach((line: any) => canvas.value.remove(line));
    
    // Get current nodes and handles
    const nodes = canvas.value.getObjects()
        .filter((o: any) => o.name === 'path_node' && o.data.parentPath === pathObj)
        .sort((a: any, b: any) => a.data.index - b.data.index);
    
    const handles = canvas.value.getObjects()
        .filter((o: any) => o.name === 'bezier_handle' && o.data.parentPath === pathObj);
    
    // Recreate handle lines
    nodes.forEach((node: any) => {
        const handleIn = handles.find((h: any) => 
            h.data.index === node.data.index && h.data.type === 'handle_in'
        );
        const handleOut = handles.find((h: any) => 
            h.data.index === node.data.index && h.data.type === 'handle_out'
        );
        
        if (handleIn) {
            const line = new fabric.Line(
                [node.left, node.top, handleIn.left, handleIn.top],
                {
                    stroke: '#666666',
                    strokeWidth: 1,
                    strokeDashArray: [3, 3],
                    selectable: false,
                    evented: false,
                    name: 'handle_line',
                    data: { index: node.data.index, parentPath: pathObj },
                    excludeFromExport: true
                }
            );
            canvas.value.add(line);
        }
        
        if (handleOut) {
            const line = new fabric.Line(
                [node.left, node.top, handleOut.left, handleOut.top],
                {
                    stroke: '#666666',
                    strokeWidth: 1,
                    strokeDashArray: [3, 3],
                    selectable: false,
                    evented: false,
                    name: 'handle_line',
                    data: { index: node.data.index, parentPath: pathObj },
                    excludeFromExport: true
                }
            );
            canvas.value.add(line);
        }
    });
}

// Path operations
const closePath = () => {
    // If we're currently drawing a path (penPathPoints has points), close it
    if (penPathPoints.value.length >= 2) {
        // Remove preview
        if (currentPenPath.value) {
            if (Array.isArray(currentPenPath.value)) {
                currentPenPath.value.forEach((obj: any) => {
                    if (canvas.value) canvas.value.remove(obj);
                });
            } else {
                if (canvas.value) canvas.value.remove(currentPenPath.value);
            }
            currentPenPath.value = null;
        }
        const path = createVectorPathFromPenData(penPathPoints.value, { closed: true });
        if (!path) return;
        
        canvas.value.add(path);
        canvas.value.setActiveObject(path);
        selectedObjectRef.value = path;
        triggerRef(selectedObjectRef);
        
        // Reset - this stops creating new lines
        penPathPoints.value = [];
        currentPenPath.value = null;
        currentMousePos.value = null;
        canvas.value.requestRenderAll();
        saveCurrentState();
        updateSelection();
        return;
    }
    
    // Otherwise, close an existing selected path
    const active = getTargetVectorPath();
    if (!active || !active.isVectorPath) return;
    
    const pathData = active.penPathData || [];
    if (pathData.length < 2) return;
    active.isClosedPath = true;
    rebuildPathFromData(active);
    if (isNodeEditing.value && currentEditingPath.value === active) {
        exitNodeEditing();
        enterPathNodeEditing(active);
    }
    updateSelection();
}

const simplifyPath = () => {
    const active = getTargetVectorPath();
    if (!active || !active.isVectorPath) return;
    
    // Simplify path by reducing points (basic implementation)
    const pathData = active.penPathData || [];
    if (pathData.length <= 2) return;
    const wasClosed = isVectorPathClosed(active);
    
    // Remove intermediate points that are too close
    const simplified: any[] = [pathData[0]];
    const threshold = 10; // pixels
    
    for (let i = 1; i < pathData.length - 1; i++) {
        const prev = simplified[simplified.length - 1];
        const curr = pathData[i];
        const next = pathData[i + 1];
        
        const dist1 = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));
        const dist2 = Math.sqrt(Math.pow(next.x - curr.x, 2) + Math.pow(next.y - curr.y, 2));
        
        if (dist1 > threshold || dist2 > threshold) {
            simplified.push(curr);
        }
    }
    
    simplified.push(pathData[pathData.length - 1]);
    active.penPathData = simplified;
    active.isClosedPath = wasClosed && simplified.length > 2;
    rebuildPathFromData(active);
    updateSelection();
}

const splitPath = () => {
    const active = getTargetVectorPath();
    if (!active || !active.isVectorPath || !canvas.value) return;

    if (!isNodeEditing.value) {
        enterPathNodeEditing(active);
        return;
    }

    const splitIndex = selectedPathNodeIndex.value;
    const pathData = Array.isArray(active.penPathData)
        ? JSON.parse(JSON.stringify(active.penPathData))
        : [];

    if (splitIndex === null || splitIndex < 0 || splitIndex >= pathData.length || pathData.length < 3) {
        return;
    }

    const wasClosed = isVectorPathClosed(active);

    // Closed path: split means opening the contour at the selected node.
    if (wasClosed) {
        const rotated = [...pathData.slice(splitIndex), ...pathData.slice(0, splitIndex)];
        active.penPathData = rotated;
        active.isClosedPath = false;
        rebuildPathFromData(active);
        exitNodeEditing();
        enterPathNodeEditing(active);
        selectPathNode(0, active);
        updateSelection();
        return;
    }

    // Open path: split into two independent paths.
    if (splitIndex <= 0 || splitIndex >= pathData.length - 1) {
        return;
    }

    const firstSegment = pathData.slice(0, splitIndex + 1);
    const secondSegment = pathData.slice(splitIndex);

    active.penPathData = firstSegment;
    active.isClosedPath = false;
    const firstPathString = buildPathStringFromPenData(firstSegment, false);
    if (firstPathString) {
        active.set('path', fabric.util.parsePath(firstPathString));
        active.setCoords();
    }

    const secondPath = createVectorPathFromPenData(secondSegment, {
        closed: false,
        source: active
    });
    if (!secondPath) {
        rebuildPathFromData(active);
        return;
    }

    canvas.value.add(secondPath);
    exitNodeEditing();
    canvas.value.setActiveObject(secondPath);
    selectedObjectRef.value = secondPath;
    triggerRef(selectedObjectRef);
    canvas.value.requestRenderAll();
    saveCurrentState();
    updateSelection();
}

// --- Node Editing Logic ---
const enterNodeEditing = (obj: any) => {
    if (!obj || (obj.type !== 'polygon' && obj.type !== 'polyline')) return;
    
    isNodeEditing.value = true;
    canvas.value.discardActiveObject(); // Deselect main object to focus on points
    
    const matrix = obj.calcTransformMatrix();
    const points = obj.points;
    
    points.forEach((point: any, index: number) => {
        // Transform point coordinates to canvas coordinates
        const p = fabric.util.transformPoint({ x: point.x - obj.pathOffset.x, y: point.y - obj.pathOffset.y }, matrix);
        
        const control = new fabric.Circle({
            left: p.x,
            top: p.y,
            radius: 4,
            fill: '#ffffff',
            stroke: '#0d99ff',
            strokeWidth: 1,
            hasControls: false,
            hasBorders: false,
            originX: 'center',
            originY: 'center',
            name: 'control_point',
            data: { index: index, parentObj: obj }, // Link to parent
            excludeFromExport: true // CRITICAL: Don't show in LayersPanel
        });
        
        canvas.value.add(control);
    });
    
    obj.selectable = false; // Lock parent while editing
    obj.evented = false;
    canvas.value.requestRenderAll();
}



const createPriceLayout = (product: any, width: number, top: number) => {
    // Basic Stub for Price Layout - usa preço principal dinâmico
    const group = new fabric.Group([], { left: 0, top: top });
    const availablePrices = getAvailablePrices(product);
    const priceText = new fabric.Text(availablePrices.mainPrice || '0,00', { fontSize: 40, fill: 'red' });
    safeAddWithUpdate(group, priceText);
    return group;
}

const exitNodeEditing = () => {
    if (!canvas.value) return;
    
    isNodeEditing.value = false;
    selectedPathNodeIndex.value = null;
    currentEditingPath.value = null;
    
    // Remove ALL control points, handles, and orphaned objects
    const toRemove = canvas.value.getObjects().filter((o: any) => {
        return isTransientCanvasObject(o);
    });
    
    toRemove.forEach((ctrl: any) => {
        try {
            canvas.value.remove(ctrl);
        } catch (e) {
            // Ignore errors if object was already removed
        }
    });
    
    // Re-enable parent objects
    canvas.value.getObjects().forEach((obj: any) => {
        if (obj.selectable === false && (obj.type === 'polygon' || obj.type === 'polyline' || obj.isVectorPath)) {
            obj.selectable = true;
            obj.evented = true;
        }
    });
    
    // Force update canvasObjects to refresh LayersPanel
    refreshCanvasObjects();
    canvas.value.requestRenderAll();
}

// Update polygon when control point moves
const handleInteraction = () => {
    // Reduced work during interaction to avoid lag
    // Scrollbars and Properties panel will update on 'mouse:up' or 'object:modified'
};

const safeAddWithUpdate = (group: any, object?: any) => {
    if (!group) return;
    
    // CRITICAL: Validate object is a proper Fabric object before adding
    if (object) {
        const isValid = object && typeof object === 'object' && typeof object.setCoords === 'function';
        if (!isValid) {
            console.error('❌ [safeAddWithUpdate] Tentativa de adicionar objeto inválido ao grupo!', {
                objectType: typeof object,
                objectValue: object,
                hasSetCoords: typeof object?.setCoords === 'function',
                groupId: group._customId || group.id
            });
            return; // BLOCK invalid objects
        }
    }
    
    if (typeof group.addWithUpdate === 'function') {
        if (object) group.addWithUpdate(object);
        else group.addWithUpdate();
        return;
    }
    if (object && typeof group.add === 'function') {
        group.add(object);
    }
    // Fabric v7+: groups use LayoutManager; `triggerLayout()` replaces `addWithUpdate/_calcBounds`.
    if (typeof group.triggerLayout === 'function') {
        group.triggerLayout();
    } else {
        if (typeof group._calcBounds === 'function') group._calcBounds();
        if (typeof group._updateObjectsCoords === 'function') group._updateObjectsCoords();
    }
    if (typeof group.setCoords === 'function') group.setCoords();
    group.dirty = true;
};

const groupLocalToCanvasPoint = (group: any, x: number, y: number): { x: number; y: number } => {
    try {
        if (!group || !fabric) return { x, y };
        const hasMatrix = typeof group.calcTransformMatrix === 'function';
        if (!hasMatrix || !fabric?.util?.transformPoint || !fabric?.Point) return { x, y };
        const m = group.calcTransformMatrix();
        const p = new fabric.Point(Number(x) || 0, Number(y) || 0);
        const out = fabric.util.transformPoint(p, m);
        return { x: Number(out?.x) || 0, y: Number(out?.y) || 0 };
    } catch {
        return { x, y };
    }
};

// === GLOBAL HELPER: Find parent group for an object (used by delete and other operations) ===
const findParentGroupForObjectGlobal = (obj: any): any => {
    if (!obj || !canvas.value) return null;
    
    // First check if object has direct group reference
    if (obj.group) return obj.group;
    
    const allObjects = canvas.value.getObjects();
    
    // Search function that finds the IMMEDIATE parent group containing the object
    const searchInGroup = (group: any, depth: number = 0): { group: any, depth: number } | null => {
        if (!group || typeof group.getObjects !== 'function') return null;
        
        const children = group.getObjects() || [];
        
        for (const child of children) {
            // Direct match
            if (child === obj || (obj._customId && child._customId === obj._customId)) {
                return { group, depth };
            }
            
            // If child is also a group, search deeper
            if (child.type === 'group' || child.type === 'Group') {
                const deeper = searchInGroup(child, depth + 1);
                if (deeper) {
                    return deeper; // Return the deepest match (immediate parent)
                }
            }
        }
        
        return null;
    };
    
    // Look for groups that are in ACTIVE edit mode first
    for (const canvasObj of allObjects) {
        if (canvasObj.type === 'group' || canvasObj.type === 'Group') {
            const isInteractive = canvasObj.interactive === true || canvasObj.subTargetCheck === true;
            
            if (isInteractive) {
                const result = searchInGroup(canvasObj, 0);
                if (result) return result.group;
            }
        }
    }
    
    // Fallback: search all groups
    for (const canvasObj of allObjects) {
        if (canvasObj.type === 'group' || canvasObj.type === 'Group') {
            const result = searchInGroup(canvasObj, 0);
            if (result) return result.group;
        }
    }
    
    return null;
};

// === ALT/OPTION + DRAG DUPLICATE (Figma/Canva-like) ===
// When user Alt-drags an object, we keep the original in place and drag a clone.
const setupAltDragDuplicate = () => {
    if (!canvas.value || !fabric) return;

    const isValidFabricObject = (o: any) => {
        if (!o || typeof o !== 'object') return false;
        return typeof o.set === 'function' && typeof o.render === 'function' && typeof o.setCoords === 'function';
    };

    const assignNewIdsDeep = (obj: any) => {
        if (!obj || typeof obj !== 'object') return;
        if (typeof obj.set !== 'function') return;
        obj._customId = Math.random().toString(36).substr(2, 9);
        if (typeof obj.getObjects === 'function') {
            (obj.getObjects() || []).forEach((c: any) => {
                if (c && typeof c.set === 'function') {
                    c._customId = Math.random().toString(36).substr(2, 9);
                }
            });
        }
    };

    const state = {
        armed: false,
        cloning: false,
        didDuplicate: false,
        cloneRequestSeq: 0,
        activeCloneRequestId: 0,
        original: null as any,
        clone: null as any,
        parentGroup: null as any,
        cloneInGroup: false,
        startLeft: 0,
        startTop: 0,
        origLockX: false,
        origLockY: false,
        // Track current pointer during async clone for smooth positioning
        lastPointerX: 0,
        lastPointerY: 0,
        pointerDownX: 0,
        pointerDownY: 0,
        manualFollowClone: false,
    };

    const restoreOriginalLocks = (obj: any) => {
        if (!obj || typeof obj.set !== 'function') return;
        obj.set({
            lockMovementX: !!state.origLockX,
            lockMovementY: !!state.origLockY,
        });
        obj.setCoords?.();
    };

    const isEligibleTarget = (obj: any) => {
        if (!obj) return false;
        if (obj.excludeFromExport) return false;
        if (isPenMode.value || isNodeEditing.value || isDrawing.value) return false;
        if (isLikelyProductZone(obj)) return false;
        if (String(obj.type || '').toLowerCase() === 'activeselection') return false;
        return true;
    };

    const pickAltDragSource = (opt: any) => {
        const candidates: any[] = [];
        const seen = new Set<any>();
        const push = (obj: any) => {
            if (!obj || seen.has(obj)) return;
            seen.add(obj);
            candidates.push(obj);
        };

        if (Array.isArray(opt?.subTargets)) {
            opt.subTargets.forEach((obj: any) => push(obj));
        }
        push(opt?.subTarget);
        push(opt?.target);

        const tr: any = (canvas.value as any)?._currentTransform;
        push(tr?.target);

        const active = canvas.value?.getActiveObject?.();
        push((active as any)?._activeObject);
        push(active);

        return candidates.find((obj: any) => isEligibleTarget(obj)) || null;
    };

    const resolveSourceFromTransform = (source: any, transformTarget: any) => {
        if (!isEligibleTarget(transformTarget)) return source;
        if (!source) return transformTarget;
        if (transformTarget === source) return source;

        const sourceType = String(source?.type || '').toLowerCase();
        const sourceIsGroup = sourceType === 'group';
        if (sourceIsGroup && transformTarget.group === source) {
            return transformTarget;
        }

        const sourceParent = source?.group;
        if (sourceParent && transformTarget === sourceParent) {
            // User may be deep-selecting a child while Fabric reports parent group as transform target.
            return source;
        }
        if (sourceParent && transformTarget.group === sourceParent) {
            return transformTarget;
        }

        return source;
    };

    const isTransformRelatedToSource = (source: any, transformTarget: any) => {
        if (!source || !transformTarget) return false;
        if (transformTarget === source) return true;
        const sourceType = String(source?.type || '').toLowerCase();
        if (sourceType === 'group' && transformTarget.group === source) return true;
        const sourceParent = source?.group;
        if (sourceParent && (transformTarget === sourceParent || transformTarget.group === sourceParent)) return true;
        return false;
    };

    const syncCloneToPointerDelta = () => {
        if (!state.clone || !isValidFabricObject(state.clone)) return;
        if (!Number.isFinite(state.pointerDownX) || !Number.isFinite(state.pointerDownY)) return;

        const worldDx = Number(state.lastPointerX || 0) - Number(state.pointerDownX || 0);
        const worldDy = Number(state.lastPointerY || 0) - Number(state.pointerDownY || 0);

        let localDx = worldDx;
        let localDy = worldDy;
        const parentGroup = (state.clone as any)?.group;
        if (parentGroup) {
            const angle = (Number((parentGroup as any)?.angle) || 0) * (Math.PI / 180);
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const rotatedX = worldDx * cos - worldDy * sin;
            const rotatedY = worldDx * sin + worldDy * cos;
            const scaleX = Number((parentGroup as any)?.scaleX) || 1;
            const scaleY = Number((parentGroup as any)?.scaleY) || 1;
            localDx = rotatedX / (scaleX || 1);
            localDy = rotatedY / (scaleY || 1);
        }

        state.clone.set({
            left: Number(state.startLeft || 0) + localDx,
            top: Number(state.startTop || 0) + localDy,
        });
        state.clone.setCoords?.();
        if (shouldApplyContainmentConstraints(state.clone)) {
            applyContainmentConstraints(state.clone);
        }
    };

    const getScenePointerFromEvent = (evt: any): { x: number; y: number } | null => {
        if (!canvas.value || !evt) return null;
        try {
            // Use scene/world coords first (matches object left/top space).
            const scene = canvas.value.getScenePoint?.(evt);
            if (scene && Number.isFinite(scene.x) && Number.isFinite(scene.y)) {
                return { x: Number(scene.x), y: Number(scene.y) };
            }
            const viewport = canvas.value.getViewportPoint?.(evt);
            if (viewport && Number.isFinite(viewport.x) && Number.isFinite(viewport.y)) {
                return { x: Number(viewport.x), y: Number(viewport.y) };
            }
        } catch {
            // ignore
        }
        return null;
    };

    canvas.value.on('mouse:down', (opt: any) => {
        const evt: MouseEvent | undefined = opt?.e;
        if (!evt || evt.button !== 0 || !evt.altKey) {
            state.armed = false;
            state.activeCloneRequestId = 0;
            state.manualFollowClone = false;
            return;
        }
        const source = pickAltDragSource(opt);
        if (!isEligibleTarget(source)) {
            state.armed = false;
            state.activeCloneRequestId = 0;
            state.manualFollowClone = false;
            return;
        }

        // FIGMA BEHAVIOR: When user deep-selects a child inside a product card
        // (e.g., product image, title text), ALT+drag should duplicate JUST that child,
        // NOT the entire card group. The child will be cloned inside the same parent group.
        // If the user wants to duplicate the whole card, they select the card group itself.

        state.armed = true;
        state.cloning = false;
        state.didDuplicate = false;
        state.manualFollowClone = false;
        state.activeCloneRequestId = 0;
        state.original = source;
        state.startLeft = Number(source.left || 0);
        state.startTop = Number(source.top || 0);
        // Initialize pointer tracking at mousedown position
        const ptr = getScenePointerFromEvent(evt);
        if (ptr) {
            state.lastPointerX = ptr.x;
            state.lastPointerY = ptr.y;
            state.pointerDownX = ptr.x;
            state.pointerDownY = ptr.y;
        } else {
            state.lastPointerX = state.startLeft;
            state.lastPointerY = state.startTop;
            state.pointerDownX = state.startLeft;
            state.pointerDownY = state.startTop;
        }
    });

    canvas.value.on('mouse:move:before', (opt: any) => {
        if (!state.armed || state.cloning) return;
        if (!canvas.value) return;

        // Track pointer continuously for smooth clone positioning
        try {
            const evt = opt?.e;
            if (evt) {
                const ptr = getScenePointerFromEvent(evt);
                if (ptr) { state.lastPointerX = ptr.x; state.lastPointerY = ptr.y; }
            }
        } catch { /* ignore */ }

        if (state.didDuplicate) {
            if (state.manualFollowClone && state.clone) {
                syncCloneToPointerDelta();
                canvas.value.requestRenderAll();
            }
            return;
        }

        const tr: any = (canvas.value as any)._currentTransform;
        const transformTarget = tr?.target;
        const resolvedSource = resolveSourceFromTransform(state.original, transformTarget);
        if (resolvedSource && resolvedSource !== state.original) {
            state.original = resolvedSource;
            state.startLeft = Number(resolvedSource.left || 0);
            state.startTop = Number(resolvedSource.top || 0);
            // Re-anchor drag delta when Fabric swaps parent->child target to avoid jump.
            if (Number.isFinite(state.lastPointerX) && Number.isFinite(state.lastPointerY)) {
                state.pointerDownX = Number(state.lastPointerX);
                state.pointerDownY = Number(state.lastPointerY);
            }
        }

        // For interactive groups (product cards with subTargetCheck=true), Fabric may report
        // transform target as either the child or its parent group depending on hit-test timing.
        if (!isTransformRelatedToSource(state.original, transformTarget)) {
            const sourceGroup = state.original?.group;
            const inInteractiveGroup = !!(
                sourceGroup &&
                (sourceGroup.interactive || sourceGroup.subTargetCheck)
            );
            if (!inInteractiveGroup || !tr) return;
        }

        // Start cloning (runs once)
        state.cloning = true;
        const original = state.original;
        const origLeft = state.startLeft;
        const origTop = state.startTop;

        // Fabric can occasionally keep the transform bound to the parent group even when
        // user is dragging a deep-selected child. Re-bind to child so clone handoff is stable.
        const sourceParentGroup = (original as any)?.group;
        if (tr && sourceParentGroup && tr.target === sourceParentGroup && tr.target !== original) {
            tr.target = original;
            if (tr.original && typeof tr.original === 'object') {
                tr.original.left = origLeft;
                tr.original.top = origTop;
            }
        }

        // Lock original IMMEDIATELY to prevent it from moving while clone is being created.
        // This is critical because doClone() is async (fabric.clone / enlivenObjects return Promises).
        // Without this, the original moves with the mouse for 1-2 frames before the clone takes over.
        state.origLockX = !!original.lockMovementX;
        state.origLockY = !!original.lockMovementY;
        original.set({ lockMovementX: true, lockMovementY: true });
        original.set({ left: origLeft, top: origTop });
        original.setCoords?.();
        const cloneRequestId = ++state.cloneRequestSeq;
        state.activeCloneRequestId = cloneRequestId;

        // Clone via Fabric's native clone
        const CLONE_PROPS = [
            '_customId', 'isFrame', 'layerName', 'clipContent', 'parentFrameId', 'parentZoneId',
            'objectMaskEnabled',
            'isSmartObject', 'isProductCard', 'name', 'smartGridId', 'unitLabel',
            'price', 'pricePack', 'priceUnit', 'priceSpecial', 'priceSpecialUnit', 'specialCondition',
            'priceWholesale', 'wholesaleTrigger', 'wholesaleTriggerUnit', 'packQuantity', 'packUnit', 'packageLabel',
            'unit', 'limit', '_productData', '_cardWidth', '_cardHeight', 'subTargetCheck', 'interactive',
            '__preserveManualLayout', '__isCustomTemplate', '__forceAtacarejoCanonical',
            '__manualTemplateBaseW', '__manualTemplateBaseH', '__manualGapSingle', '__manualGapRetail', '__manualGapWholesale',
            '__atacValueVariants', '__atacVariantGroups'
        ];

        const doClone = async () => {
            let cloned: any = null;

            // For groups, prefer serialize+enliven — fabric.clone() on groups sometimes
            // produces children that lose critical methods (getRelativeCenterPoint etc.)
            // because prototypes don't survive a shallow copy.
            const isGroup = original.type === 'group';
            
            if (isGroup) {
                try {
                    const json = typeof original.toObject === 'function' ? original.toObject(CLONE_PROPS) : null;
                    if (json && fabric?.util?.enlivenObjects) {
                        const objs = await fabric.util.enlivenObjects([json]);
                        cloned = Array.isArray(objs) && objs.length > 0 ? objs[0] : null;
                    }
                } catch (e) {
                    console.warn('[alt-drag-duplicate] serialize+enliven fallback for group failed', e);
                    cloned = null;
                }
            }

            // For non-groups (or if serialize failed), try native clone
            if (!isValidFabricObject(cloned)) {
                try {
                    if (typeof original.clone === 'function') {
                        const result = original.clone(CLONE_PROPS);
                        if (result && typeof result.then === 'function') {
                            cloned = await result;
                        }
                    }
                } catch { /* ignore */ }
            }

            // Final fallback: serialize + enliven (for non-groups that failed native clone)
            if (!isValidFabricObject(cloned) && !isGroup) {
                try {
                    const json = typeof original.toObject === 'function' ? original.toObject(CLONE_PROPS) : null;
                    if (json && fabric?.util?.enlivenObjects) {
                        const objs = await fabric.util.enlivenObjects([json]);
                        cloned = Array.isArray(objs) && objs.length > 0 ? objs[0] : null;
                    }
                } catch { /* ignore */ }
            }

            // Validate group children have proper methods before proceeding
            if (isValidFabricObject(cloned) && cloned.type === 'group' && typeof cloned.getObjects === 'function') {
                const children = cloned.getObjects();
                const allValid = children.every((c: any) => c && typeof c === 'object' && typeof c.getRelativeCenterPoint === 'function');
                if (!allValid) {
                    console.warn('[alt-drag-duplicate] Cloned group has invalid children, retrying via serialize');
                    cloned = null;
                    try {
                        const json = typeof original.toObject === 'function' ? original.toObject(CLONE_PROPS) : null;
                        if (json && fabric?.util?.enlivenObjects) {
                            const objs = await fabric.util.enlivenObjects([json]);
                            cloned = Array.isArray(objs) && objs.length > 0 ? objs[0] : null;
                        }
                    } catch { /* ignore */ }
                }
            }

            const cloneWasCancelled = cloneRequestId !== state.activeCloneRequestId || !state.armed;
            if (cloneWasCancelled || !isValidFabricObject(cloned) || !canvas.value) {
                state.activeCloneRequestId = 0;
                state.armed = false;
                restoreOriginalLocks(original);
                state.cloning = false;
                return;
            }

            assignNewIdsDeep(cloned);

            // Copy metadata — only for top-level objects or card groups.
            // When cloning a CHILD element inside a card (e.g., a product image),
            // do NOT copy card-level meta to the child clone.
            const isCloneACard = cloned.type === 'group' && (cloned.isSmartObject || cloned.isProductCard || isLikelyProductCard(cloned));
            if (isCloneACard) {
                for (const k of ['parentFrameId', 'parentZoneId', 'isSmartObject', 'isProductCard', 'unitLabel', 'smartGridId', '_cardWidth', '_cardHeight']) {
                    if ((original as any)[k] != null) (cloned as any)[k] = (original as any)[k];
                }
            } else if (!original.group || !(original.group.isSmartObject || original.group.isProductCard || isLikelyProductCard(original.group))) {
                // Only copy frame/zone binding for non-card-child objects
                for (const k of ['parentFrameId']) {
                    if ((original as any)[k] != null) (cloned as any)[k] = (original as any)[k];
                }
            }

            // Ensure cloned product card groups have correct child flags
            if ((cloned.isSmartObject || cloned.isProductCard) && cloned.type === 'group' && typeof cloned.getObjects === 'function') {
                cloned.set({ subTargetCheck: true, interactive: true });
                cloned.getObjects().forEach((child: any) => {
                    const isBackground = child.name === 'offerBackground' || child.name === 'price_bg';
                    child.set({
                        selectable: !isBackground,
                        evented: !isBackground,
                        hasControls: !isBackground,
                        hasBorders: !isBackground,
                    });
                });
            }

            // Check if original is inside a group (e.g. product card inside product zone)
            const parentGroup = (original as any).group;
            const isInsideGroup = parentGroup && String(parentGroup.type || '').toLowerCase() !== 'activeselection';
            state.parentGroup = isInsideGroup ? parentGroup : null;
            state.cloneInGroup = false;

            // ── Position & insert the clone ──
            if (isInsideGroup && parentGroup) {
                // INSIDE GROUP: insert clone directly into parent group at same local coords.
                // This keeps the clone logically inside the product card/zone.
                cloned.set({
                    left: origLeft,
                    top: origTop,
                    originX: original.originX || 'left',
                    originY: original.originY || 'top',
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    hasBorders: true,
                    objectCaching: false,
                    dirty: true,
                });

                // SILENT insertion: disable LayoutManager to prevent position recalculation
                const lm = (parentGroup as any).layoutManager;
                const origPerformLayout = lm?.performLayout;
                if (lm) lm.performLayout = () => {};

                const groupObjects = typeof parentGroup.getObjects === 'function'
                    ? parentGroup.getObjects()
                    : (Array.isArray((parentGroup as any)._objects) ? (parentGroup as any)._objects : []);
                const originalIndexInGroup = Array.isArray(groupObjects) ? groupObjects.indexOf(original) : -1;
                const insertIndex = originalIndexInGroup >= 0
                    ? Math.min(originalIndexInGroup + 1, groupObjects.length)
                    : -1;

                if (insertIndex >= 0 && typeof (parentGroup as any).insertAt === 'function') {
                    (parentGroup as any).insertAt(insertIndex, cloned);
                } else if (Array.isArray((parentGroup as any)._objects)) {
                    if (insertIndex >= 0) {
                        (parentGroup as any)._objects.splice(insertIndex, 0, cloned);
                    } else {
                        (parentGroup as any)._objects.push(cloned);
                    }
                    (cloned as any).group = parentGroup;
                    cloned.canvas = canvas.value;
                } else if (typeof parentGroup.add === 'function') {
                    parentGroup.add(cloned);
                }

                if (lm && origPerformLayout) lm.performLayout = origPerformLayout;

                cloned.setCoords?.();
                parentGroup.set('dirty', true);
                if (shouldApplyContainmentConstraints(cloned)) {
                    applyContainmentConstraints(cloned);
                }
                state.cloneInGroup = true;

            } else {
                // CANVAS LEVEL: same left/top/origin
                cloned.set({
                    left: origLeft,
                    top: origTop,
                    originX: original.originX || 'left',
                    originY: original.originY || 'top',
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    hasBorders: true,
                    objectCaching: false,
                    dirty: true,
                });
                cloned.setCoords?.();

                canvas.value.add(cloned);

                // Z-order: place clone right above the original
                const canvasObjs = canvas.value.getObjects();
                const origIdx = canvasObjs.indexOf(original);
                if (origIdx >= 0 && typeof (canvas.value as any).moveTo === 'function') {
                    (canvas.value as any).moveTo(cloned, origIdx + 1);
                }
            }

            // FIGMA/CANVA BEHAVIOR: original stays in place, CLONE follows mouse.
            // Swap Fabric's internal transform target from original → clone.
            const tr: any = (canvas.value as any)._currentTransform;
            let didSwapTransform = false;
            if (tr) {
                const parentGroup = (original as any)?.group;
                const shouldSwap = isTransformRelatedToSource(original, tr.target)
                    || (isInsideGroup && parentGroup && tr.target === parentGroup);

                if (shouldSwap) {
                    tr.target = cloned;
                    // offsetX/Y: keep original offsets since clone has same coords & origin
                    if (tr.original && typeof tr.original === 'object') {
                        tr.original.left = cloned.left;
                        tr.original.top = cloned.top;
                    }
                    didSwapTransform = true;
                }
            }

            // Ensure original is still pinned (was locked before doClone, reinforce here)
            original.set({ left: origLeft, top: origTop });
            original.setCoords?.();

            // Select the clone (it follows the mouse)
            canvas.value.setActiveObject(cloned);
            
            state.clone = cloned;
            state.didDuplicate = true;
            state.manualFollowClone = !didSwapTransform;

            // Always align clone to the current pointer delta on the first frame.
            // This avoids the visual "jump" when async clone creation finishes.
            syncCloneToPointerDelta();

            // If Fabric transform was swapped, keep transform origin in sync with
            // the corrected clone coordinates to avoid a follow-up snap.
            if (didSwapTransform) {
                const tr2: any = (canvas.value as any)?._currentTransform;
                if (tr2?.original && typeof tr2.original === 'object') {
                    tr2.original.left = cloned.left;
                    tr2.original.top = cloned.top;
                }
            }
            state.cloning = false;

            canvas.value.requestRenderAll();
        };

        doClone();
    });

    canvas.value.on('mouse:up', () => {
        if (!state.didDuplicate || !canvas.value) {
            state.activeCloneRequestId = 0;
            restoreOriginalLocks(state.original);
            state.armed = false;
            state.cloning = false;
            state.didDuplicate = false;
            state.manualFollowClone = false;
            state.original = null;
            state.clone = null;
            state.pointerDownX = 0;
            state.pointerDownY = 0;
            return;
        }

        const original = state.original;
        const clone = state.clone;
        const pg = state.parentGroup;

        // Unlock original (restore previous lock state)
        if (original) {
            restoreOriginalLocks(original);
        }

        // Clone is already in the correct parent (group or canvas). Just finalize.
        if (clone && pg) {
            pg.set('dirty', true);
            if (typeof pg.setCoords === 'function') pg.setCoords();
        }

        // Select the clone (the one the user just placed)
        if (clone) {
            clone.setCoords?.();
            if (pg) {
                pg.set({ subTargetCheck: true, interactive: true });
            }
            canvas.value.setActiveObject(clone);
        }

        canvas.value.requestRenderAll();

        // Update objects list
        refreshCanvasObjects();

        // Reset state
        state.activeCloneRequestId = 0;
        state.armed = false;
        state.cloning = false;
        state.didDuplicate = false;
        state.manualFollowClone = false;
        state.original = null;
        state.clone = null;
        state.parentGroup = null;
        state.cloneInGroup = false;
        state.pointerDownX = 0;
        state.pointerDownY = 0;

        saveCurrentState();
    });
};

type ArrangeMode = 'bring-to-front' | 'bring-forward' | 'send-backward' | 'send-to-back';

const computeArrangedOrder = (list: any[], selected: Set<any>, mode: ArrangeMode) => {
    const arr = list.slice();
    if (arr.length < 2) return arr;

    if (mode === 'bring-to-front') {
        const nonSel = arr.filter(o => !selected.has(o));
        const sel = arr.filter(o => selected.has(o));
        return [...nonSel, ...sel];
    }
    if (mode === 'send-to-back') {
        const nonSel = arr.filter(o => !selected.has(o));
        const sel = arr.filter(o => selected.has(o));
        return [...sel, ...nonSel];
    }
    if (mode === 'bring-forward') {
        const out = arr.slice();
        for (let i = out.length - 2; i >= 0; i--) {
            if (selected.has(out[i]) && !selected.has(out[i + 1])) {
                const tmp = out[i];
                out[i] = out[i + 1];
                out[i + 1] = tmp;
            }
        }
        return out;
    }
    // send-backward
    const out = arr.slice();
    for (let i = 1; i < out.length; i++) {
        if (selected.has(out[i]) && !selected.has(out[i - 1])) {
            const tmp = out[i];
            out[i] = out[i - 1];
            out[i - 1] = tmp;
        }
    }
    return out;
};

const applyArrangedOrder = (container: any, newOrder: any[]) => {
    if (!container || !Array.isArray(newOrder)) return;
    
    // CRITICAL: Filter out invalid objects before applying order
    const validObjects = newOrder.filter((o: any) => {
        const isValid = o && typeof o === 'object' && typeof o.setCoords === 'function';
        if (!isValid) {
            console.error('❌ [applyArrangedOrder] Objeto inválido detectado e removido!', {
                objectType: typeof o,
                objectValue: o,
                containerId: container._customId || container.id
            });
        }
        return isValid;
    });
    
    if (validObjects.length !== newOrder.length) {
        console.warn(`⚠️ [applyArrangedOrder] Removidos ${newOrder.length - validObjects.length} objetos inválidos`);
    }
    
    // Fabric keeps render order in the internal `_objects` array for both Canvas and Group.
    const internal = (container as any)._objects;
    if (Array.isArray(internal)) {
        internal.length = 0;
        validObjects.forEach(o => internal.push(o));
        if (typeof container._onStackOrderChanged === 'function') container._onStackOrderChanged();
    } else if (typeof container.getObjects === 'function' && typeof container.remove === 'function' && typeof container.add === 'function') {
        // Fallback: rebuild by remove/add (can be slower, but safe).
        const cur = container.getObjects().slice();
        cur.forEach((o: any) => container.remove(o));
        validObjects.forEach((o: any) => container.add(o));
    }

    if (container === canvas.value) {
        canvas.value.requestRenderAll();
    } else {
        safeAddWithUpdate(container);
        canvas.value?.requestRenderAll?.();
    }
};

const isValidFabricCanvasObject = (o: any): boolean => {
    if (!o || typeof o !== 'object') return false;
    return (
        typeof o.render === 'function' &&
        typeof o.setCoords === 'function' &&
        typeof o.set === 'function' &&
        typeof o.toObject === 'function'
    );
};

const sanitizeCanvasObjectStack = (canvasInstance: any, reason: string = 'unknown'): number => {
    if (!canvasInstance) return 0;
    const visited = new Set<any>();
    const visitedClipPaths = new Set<any>();
    const clearOwnerClipPath = (owner: any) => {
        if (!owner) return;
        try {
            if (typeof owner.set === 'function') owner.set('clipPath', null);
            else owner.clipPath = null;
        } catch {
            owner.clipPath = null;
        }
        if (owner?._frameClipOwner) {
            try { delete owner._frameClipOwner; } catch { /* ignore */ }
        }
    };

    const sanitizeContainer = (container: any, tag: string): number => {
        if (!container || visited.has(container)) return 0;
        visited.add(container);

        let removedTotal = 0;
        const internal = (container as any)._objects;
        if (Array.isArray(internal)) {
            const before = internal.length;
            const valid = internal.filter((o: any) => isValidFabricCanvasObject(o));
            const removedHere = before - valid.length;
            if (removedHere > 0) {
                internal.length = 0;
                valid.forEach((o: any) => internal.push(o));
                if (typeof (container as any)._onStackOrderChanged === 'function') {
                    try { (container as any)._onStackOrderChanged(); } catch { /* ignore */ }
                }
                console.debug(`⚠️ [sanitizeCanvasObjectStack] Removidos ${removedHere} item(ns) inválido(s) em ${tag} (${reason})`);
            }

            removedTotal += removedHere;
            valid.forEach((child: any, idx: number) => {
                removedTotal += sanitizeContainer(child, `${tag}.group[${idx}]`);
            });
        }

        removedTotal += sanitizeClipPath(container, tag);
        return removedTotal;
    };

    const sanitizeClipPath = (owner: any, tag: string): number => {
        const clip = owner?.clipPath;
        if (!clip) return 0;
        if (visitedClipPaths.has(clip)) return 0;
        visitedClipPaths.add(clip);

        if (!isValidFabricCanvasObject(clip)) {
            clearOwnerClipPath(owner);
            console.debug(`⚠️ [sanitizeCanvasObjectStack] clipPath inválido removido em ${tag} (${reason})`);
            return 1;
        }

        const internal = (clip as any)._objects;
        if (internal !== undefined && !Array.isArray(internal)) {
            (clip as any)._objects = [];
            console.debug(`⚠️ [sanitizeCanvasObjectStack] clipPath._objects corrigido em ${tag} (${reason})`);
        }

        let removed = sanitizeContainer(clip, `${tag}.clipPath`);
        if (clip?.clipPath) {
            removed += sanitizeClipPath(clip, `${tag}.clipPath`);
        }
        return removed;
    };

    return sanitizeContainer(canvasInstance, 'canvas');
};

function arrangeActiveObjects(mode: ArrangeMode) {
    if (!canvas.value) return;
    const selected = (canvas.value.getActiveObjects?.() || []).filter((o: any) => !!o);
    if (selected.length === 0) return;

    // Group selection by parent container (canvas or group) to preserve Figma-like behavior.
    const byContainer = new Map<any, any[]>();
    selected.forEach((o: any) => {
        const grp = o.group;
        const container = grp && grp.type === 'group' ? grp : canvas.value;
        const list = byContainer.get(container) || [];
        list.push(o);
        byContainer.set(container, list);
    });

    byContainer.forEach((objs: any[], container: any) => {
        const all = typeof container.getObjects === 'function' ? container.getObjects() : [];

        // Keep non-export/system overlays (guides, etc.) pinned on top.
        const pinnedTop = container === canvas.value ? all.filter((o: any) => !!o?.excludeFromExport) : [];
        const list = container === canvas.value ? all.filter((o: any) => !o?.excludeFromExport) : all;

        const set = new Set(objs.filter((o: any) => !o?.excludeFromExport));
        const next = computeArrangedOrder(list, set, mode);
        applyArrangedOrder(container, container === canvas.value ? [...next, ...pinnedTop] : next);
    });

    // Keep selection intact after reordering.
    try {
        canvas.value.discardActiveObject();
        if (selected.length === 1) {
            canvas.value.setActiveObject(selected[0]);
        } else if (fabric?.ActiveSelection) {
            const sel = new fabric.ActiveSelection(selected, { canvas: canvas.value });
            canvas.value.setActiveObject(sel);
        }
    } catch (_) {}

    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    saveCurrentState();
}

const updateNodePosition = (e: any) => {
    const target = e.target;
    if (target.name === 'control_point') {
        const parent = target.data.parentObj;
        const index = target.data.index;
        
        // We need to inverse transform the point back to object local space
        // This is complex math, simplifying by assuming object hasn't rotated significantly during edit
        // Or better: Re-calculate all points based on current canvas positions of controls?
        
        // Strategy: Get all controls, map to new points array, update object.
        const controls = canvas.value.getObjects().filter((o: any) => o.name === 'control_point' && o.data.parentObj === parent);
        controls.sort((a: any, b: any) => a.data.index - b.data.index); // Ensure order
        
        // This is a simplified approach. Ideally we use fabric.util.invertTransform
        // But for a "Lite" version, let's try to update just visual for now or full rebuild?
        
        // Limitations: Updating 'points' directly on Polygon doesn't always re-render correctly in Fabric without reset.
        // Let's defer full implementation to complex math block if needed.
        // For now, let's just allow moving the dots to show "Proof of Concept".
    }
}

// ... (existing code)
import { parseProductList } from '~/lib/utils'
import { calculateGridLayout } from '~/utils/product-zone-helpers'
import { DEFAULT_GLOBAL_STYLES, DEFAULT_PRODUCT_ZONE } from '~/types/product-zone'
import type { ProductZone, GlobalStyles } from '~/types/product-zone'
import { useProject } from '~/composables/useProject'
import { useUpload } from '~/composables/useUpload'
import { useAuth } from '~/composables/useAuth'

import { GOOGLE_WEBFONT_FAMILIES } from '~/utils/font-catalog'

// Import fabric type for TS (optional if we had types, using any for now to be fast)
// import { fabric } from 'fabric'

const {
  project,
  activePage,
  initProject,
  updatePageData,
  updatePageThumbnail,
  deletePage,
  resizePage,
  saveProjectDB,
  triggerAutoSave,
  cancelAutoSave,
  flushAutoSave,
  isSaving,
  saveStatus,
  lastSavedAt,
  isProjectLoaded,
  hasUnsavedChanges
} = useProject()
const auth = useAuth()
const { getApiAuthHeaders } = useApiAuth()

// Users state
const currentUser = computed(() => auth.user.value)
const collaborators = ref<any[]>([])

// Generate color from string (consistent color for same name/email)
const getColorFromString = (str: string): string => {
  const colors: string[] = [
    'bg-green-500', 'bg-purple-500', 'bg-blue-500', 'bg-pink-500',
    'bg-yellow-500', 'bg-indigo-500', 'bg-red-500', 'bg-teal-500',
    'bg-orange-500', 'bg-cyan-500'
  ]
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i)
    if (!isNaN(code)) {
      hash = code + ((hash << 5) - hash)
    }
  }
  return colors[Math.abs(hash) % colors.length] ?? 'bg-gray-500'
}

// Get initial from name
const getInitial = (name: string | null | undefined): string => {
  if (!name) return '?'
  const parts = name.trim().split(' ')
  const firstPart = parts[0]
  const lastPart = parts[parts.length - 1]
  if (parts.length >= 2 && firstPart && lastPart) {
    const first = firstPart[0]
    const last = lastPart[0]
    if (first && last) {
      return (first + last).toUpperCase()
    }
  }
  return name[0]?.toUpperCase() ?? '?'
}

// Load collaborators (users who have access to this project)
let collaboratorsLoadPromise: Promise<void> | null = null
let collaboratorsLoadedAt = 0
let collaboratorsLoadedUserId: string | null = null
const COLLABORATORS_CACHE_MS = 15_000

const loadCollaborators = async (force = false) => {
  const currentUserId = currentUser.value?.id ?? null
  const cacheValid = !force &&
    collaborators.value.length > 0 &&
    collaboratorsLoadedUserId === currentUserId &&
    (Date.now() - collaboratorsLoadedAt) < COLLABORATORS_CACHE_MS

  if (cacheValid) return
  if (collaboratorsLoadPromise) return collaboratorsLoadPromise

  collaboratorsLoadPromise = (async () => {
    try {
      const usersToShow: any[] = []

      // Always include current user
      if (currentUser.value) {
        usersToShow.push(currentUser.value)
      }

      // Load other users from profiles table (for now, limit to 2 more)
      // In the future, you can add a project_collaborators table for real collaboration
      try {
        const headers = await getApiAuthHeaders()
        const allUsers = await $fetch<any[]>('/api/profiles', {
          headers,
          query: { limit: 3, exclude_self: 1 }
        })

        if (Array.isArray(allUsers) && allUsers.length > 0) {
          // Filter out current user and add others
          const otherUsers = allUsers.filter((u: any) => u.id !== currentUser.value?.id)
          usersToShow.push(...otherUsers.slice(0, 2))
        }
      } catch (err) {
        console.warn('Could not load other users:', err)
      }

      collaborators.value = usersToShow.slice(0, 3) // Max 3 avatares
    } catch (error) {
      console.error('Error loading collaborators:', error)
      // Fallback to just current user
      if (currentUser.value) {
        collaborators.value = [currentUser.value]
      }
    } finally {
      collaboratorsLoadedAt = Date.now()
      collaboratorsLoadedUserId = currentUser.value?.id ?? null
      collaboratorsLoadPromise = null
    }
  })()

  return collaboratorsLoadPromise
}

// Watch for project changes to reload collaborators
watch(() => project.id, () => {
  if (project.id) {
    loadCollaborators()
  }
})

// Watch for current user to load collaborators
watch(() => currentUser.value, () => {
  if (currentUser.value) {
    loadCollaborators()
  }
}, { immediate: true })

const canvas = shallowRef<any>(null)
const canvasEl = ref<HTMLCanvasElement | null>(null)
const wrapperEl = ref<HTMLDivElement | null>(null)
const isProcessing = ref(false)
// Separate from isHistoryProcessing: we only want a UX loader during (initial) design/page load,
// not during undo/redo or other history operations.
const isDesignLoading = ref(false)
const currentZoom = ref(100) // Zoom state
let isCanvasJsonLoadInProgress = false
const isInitialCanvasHydrationDone = ref(false)
const isInitialDesignLoadDone = ref(false)
let isBulkProductMutation = false
let lastTransformMutationAt = 0
let activePageLoadSessionId = 0
let lastLoadedPageKey: string | null = null
const pageReloadToken = ref(0)
const storageDegraded = ref(false)
const storageDegradedHint = ref<string>('')
const storageDegradedFailedCount = ref<number | null>(null)
const designLoadExpectedCounts = ref<{ objects: number; images: number } | null>(null)
const designLoadActualCounts = ref<{ objects: number; images: number } | null>(null)
const designLoadImageProgress = ref<{ expected: number; loaded: number; failed: number } | null>(null)

type ImageLoadTracker = {
    sessionId: number
    expected: number
    loaded: number
    failed: number
    remainingBySrc: Map<string, number>
}

let activeImageLoadTracker: ImageLoadTracker | null = null
let imageProgressRafId: number | null = null
let originalFabricLoadImage: any = null

const scheduleImageProgressFlush = () => {
    if (typeof window === 'undefined') return
    if (imageProgressRafId != null) return
    imageProgressRafId = window.requestAnimationFrame(() => {
        imageProgressRafId = null
        const tracker = activeImageLoadTracker
        if (!tracker) return
        // Ignore stale sessions
        if (tracker.sessionId !== activePageLoadSessionId) return
        designLoadImageProgress.value = {
            expected: tracker.expected,
            loaded: tracker.loaded,
            failed: tracker.failed
        }
    })
}

const collectTrackableImageSrcCounts = (canvasData: any): Map<string, number> => {
    const counts = new Map<string, number>()
    const visited = new Set<any>()

    const isTrackableSrc = (src: string): boolean => {
        const s = String(src || '').trim()
        if (!s) return false
        // We only track remote-ish images; data URLs are instant and would just spam the counter.
        if (s.startsWith('data:')) return false
        if (s.startsWith('blob:')) return false
        return true
    }

    const walk = (node: any) => {
        if (!node) return
        if (typeof node === 'object') {
            if (visited.has(node)) return
            visited.add(node)
        }

        if (Array.isArray(node)) {
            node.forEach(walk)
            return
        }

        if (typeof node !== 'object') return

        const t = String((node as any).type || '').toLowerCase()
        if (t === 'image') {
            const src = String((node as any).src || (node as any).__originalSrc || '').trim()
            if (src && isTrackableSrc(src)) {
                counts.set(src, (counts.get(src) || 0) + 1)
            }
        }

        const children = (node as any).objects
        if (Array.isArray(children)) walk(children)
        const clip = (node as any).clipPath
        if (clip && typeof clip === 'object') walk(clip)
    }

    walk(canvasData)
    return counts
}

const startImageLoadTracking = (sessionId: number, canvasData: any) => {
    const counts = collectTrackableImageSrcCounts(canvasData)
    let expected = 0
    counts.forEach((n) => { expected += Number(n || 0) || 0 })
    if (!expected) {
        activeImageLoadTracker = null
        designLoadImageProgress.value = null
        return
    }

    activeImageLoadTracker = {
        sessionId,
        expected,
        loaded: 0,
        failed: 0,
        remainingBySrc: new Map(counts)
    }
    designLoadImageProgress.value = { expected, loaded: 0, failed: 0 }
}

const stopImageLoadTracking = (sessionId: number) => {
    if (activeImageLoadTracker?.sessionId === sessionId) {
        // Keep last known progress for the overlay, but stop counting new loads.
        activeImageLoadTracker = null
    }
}

const patchFabricLoadImageProgress = () => {
    try {
        const util = (fabric as any)?.util
        if (!util || (util as any).__jobvarejoPatchedLoadImage) return
        if (typeof util.loadImage !== 'function') return
        // Fabric v7 ESM exports freeze util (non-writable/non-configurable), so patching is impossible.
        // Detect and skip quietly to avoid noisy console warnings.
        try {
            const d = Object.getOwnPropertyDescriptor(util, 'loadImage')
            if (!Object.isExtensible(util) || Object.isFrozen(util) || (d && d.writable === false && d.configurable === false)) {
                ;(util as any).__jobvarejoPatchedLoadImage = true
                return
            }
        } catch {
            // If descriptor probing fails, proceed best-effort.
        }
        originalFabricLoadImage = util.loadImage

        util.loadImage = function (url: any, ...rest: any[]) {
            const tracker = activeImageLoadTracker
            const urlStr = String(url || '').trim()
            let shouldCount = false
            let sessionAtCall = 0

            if (tracker && urlStr) {
                const remaining = tracker.remainingBySrc.get(urlStr) || 0
                if (remaining > 0) {
                    shouldCount = true
                    sessionAtCall = tracker.sessionId
                    tracker.remainingBySrc.set(urlStr, remaining - 1)
                }
            }

            const countDone = (ok: boolean) => {
                const t = activeImageLoadTracker
                // Only count if the same session is still active.
                if (!shouldCount || !t || t.sessionId !== sessionAtCall) return
                if (ok) t.loaded += 1
                else t.failed += 1
                scheduleImageProgressFlush()
            }

            // Callback-style
            const cbIdx = rest.findIndex((a: any) => typeof a === 'function')
            if (cbIdx >= 0) {
                const origCb = rest[cbIdx]
                const wrapped = (img: any, ...cbRest: any[]) => {
                    countDone(!!img)
                    return origCb(img, ...cbRest)
                }
                const nextArgs = rest.slice()
                nextArgs[cbIdx] = wrapped
                try {
                    return originalFabricLoadImage.call(this, url, ...nextArgs)
                } catch (e) {
                    countDone(false)
                    throw e
                }
            }

            // Promise-style
            try {
                const res = originalFabricLoadImage.call(this, url, ...rest)
                if (res && typeof res.then === 'function') {
                    return res
                        .then((img: any) => {
                            countDone(!!img)
                            return img
                        })
                        .catch((err: any) => {
                            countDone(false)
                            throw err
                        })
                }
                return res
            } catch (e) {
                countDone(false)
                throw e
            }
        }

        ;(util as any).__jobvarejoPatchedLoadImage = true
        console.log('🩹 Fabric patch aplicado: image load progress (util.loadImage)')
    } catch (e) {
        // Best-effort only; never block editor boot on this telemetry patch.
    }
}

const ENABLE_LEGACY_WATCH_EFFECT_LOADER = false

const designLoadMessage = computed(() => {
    if (!isProjectLoaded.value) return 'Carregando projeto...'
    if (!isFabricReady.value) return 'Preparando editor...'
    if (!canvas.value) return 'Preparando canvas...'
    if (isDesignLoading.value || isCanvasJsonLoadInProgress) return 'Carregando design...'
    if (!isInitialDesignLoadDone.value) return 'Carregando design...'
    return 'Carregando...'
})

const designLoadProgressLine = computed(() => {
    const exp = designLoadExpectedCounts.value
    if (!exp) return ''
    const parts: string[] = []
    if (Number.isFinite(exp.objects) && exp.objects > 0) parts.push(`${exp.objects} objeto(s)`)
    const imgProg = designLoadImageProgress.value
    if (imgProg && imgProg.expected > 0) {
        const done = Math.min(imgProg.loaded + imgProg.failed, imgProg.expected)
        const tail = imgProg.failed > 0 ? ` (${imgProg.failed} falha)` : ''
        parts.push(`Imagens ${done}/${imgProg.expected}${tail}`)
    } else if (Number.isFinite(exp.images) && exp.images > 0) {
        parts.push(`${exp.images} imagem(ns)`)
    }
    const main = parts.join(', ')
    if (!main) return ''
    const act = designLoadActualCounts.value
    if (act && (act.objects > 0 || act.images > 0)) {
        const actParts: string[] = []
        if (Number.isFinite(act.objects) && act.objects > 0) actParts.push(`${act.objects} carregados`)
        // Only show image counts if we are not already showing live image progress.
        if ((!imgProg || imgProg.expected <= 0) && Number.isFinite(act.images) && act.images > 0) actParts.push(`${act.images} imagens`)
        const actStr = actParts.join(', ')
        return actStr ? `${main} (${actStr})` : main
    }
    return main
})

const showDesignLoaderOverlay = computed(() => {
    if (!isProjectLoaded.value) return true
    if (!isFabricReady.value) return true
    if (!canvas.value) return true
    if (!isInitialDesignLoadDone.value) return true
    if (isDesignLoading.value) return true
    if (isCanvasJsonLoadInProgress) return true
    return false
})

const showStorageDegradedBanner = computed(() => storageDegraded.value && !showDesignLoaderOverlay.value)

const retryStorageReload = () => {
    storageDegraded.value = false
    storageDegradedHint.value = ''
    storageDegradedFailedCount.value = null
    // Force re-run of the page loader watch even if the page id didn't change.
    lastLoadedPageKey = null
    pageReloadToken.value++
}

const canRecoverLatestNonEmpty = computed(() => {
    const pid = String(project.id || '').trim()
    const pageId = String(activePage.value?.id || '').trim()
    return !!pid && !pid.startsWith('proj_') && !!pageId
})

const isRecoveringLatestNonEmpty = ref(false)
const recoverLatestNonEmptyForActivePage = async () => {
    if (!canRecoverLatestNonEmpty.value || isRecoveringLatestNonEmpty.value) return
    const pid = String(project.id || '').trim()
    const pageId = String(activePage.value?.id || '').trim()
    if (!pid || !pageId) return
    const capturedPageId = pageId

    const ok = typeof window !== 'undefined'
        ? window.confirm('Recuperar a ultima versao nao-vazia desta pagina? Isso pode desfazer alteracoes recentes.')
        : true
    if (!ok) return

    isRecoveringLatestNonEmpty.value = true
    try {
        const headers = await getApiAuthHeaders()
        const result: any = await $fetch('/api/storage/recover-latest-non-empty', {
            method: 'POST',
            headers,
            body: { projectId: pid, pageId }
        })
	        if (result?.json) {
	            // Sync the specific page that initiated the recovery (avoid overwriting a different
	            // page if the user switched tabs/pages while this request was in-flight).
		            const idx = findPageIndexById(project.pages, capturedPageId, project.activePageIndex)
	            if (idx >= 0) {
	                updatePageData(idx, result.json, { source: 'system', markUnsaved: false })
	                const page = project.pages?.[idx]
	                if (page) page.canvasDataPath = String(result.key || page.canvasDataPath || '')
	            }
	            // Only force-reload the Fabric canvas if we're still on the same page.
	            if (getActiveProjectPageId() === capturedPageId) {
	                retryStorageReload()
	            }
	        }
    } catch (e: any) {
        console.warn('[recovery] Falha ao recuperar versao nao-vazia:', e?.message || e)
        storageDegraded.value = true
        storageDegradedHint.value = 'Falha ao recuperar versao nao-vazia.'
    } finally {
        isRecoveringLatestNonEmpty.value = false
    }
}

type PageHistoryItem = {
    source: 'version' | 'history'
    key: string
    versionId?: string | null
    lastModified: string
    size?: number | null
    objectCount?: number | null
}

const showHistoryModal = ref(false)
const historyLoading = ref(false)
const historyError = ref<string>('')
const historyItems = ref<PageHistoryItem[]>([])
const formatHistoryDateTime = (value: string) => {
    const d = new Date(value)
    if (Number.isNaN(d.getTime())) return value
    return d.toLocaleString('pt-BR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    })
}

const openHistoryModal = async () => {
    if (!canRecoverLatestNonEmpty.value) return
    const pid = String(project.id || '').trim()
    const pageId = String(activePage.value?.id || '').trim()
    if (!pid || !pageId) return

    showHistoryModal.value = true
    historyLoading.value = true
    historyError.value = ''
    historyItems.value = []

    try {
        const headers = await getApiAuthHeaders()
        const res: any = await $fetch('/api/storage/history', {
            method: 'GET',
            headers,
            query: { projectId: pid, pageId }
        })
        historyItems.value = Array.isArray(res?.items) ? res.items : []
    } catch (e: any) {
        historyError.value = String(e?.statusMessage || e?.message || 'Falha ao carregar histórico')
    } finally {
        historyLoading.value = false
    }
}

const restoringHistoryKey = ref<string>('')
const restoreFromHistoryItem = async (item: PageHistoryItem) => {
    if (!item?.key || restoringHistoryKey.value) return
    if (!canRecoverLatestNonEmpty.value) return

    const ok = typeof window !== 'undefined'
        ? window.confirm('Restaurar esta versao? Isso vai substituir o conteudo atual desta pagina.')
        : true
    if (!ok) return

    restoringHistoryKey.value = `${item.source}:${item.key}:${item.versionId || ''}`
    try {
        const pid = String(project.id || '').trim()
        const pageId = String(activePage.value?.id || '').trim()
        const headers = await getApiAuthHeaders()
        const result: any = await $fetch('/api/storage/restore', {
            method: 'POST',
            headers,
            body: {
                projectId: pid,
                pageId,
                source: {
                    kind: item.source,
                    key: item.key,
                    versionId: item.source === 'version' ? (item.versionId || null) : null
                }
            }
        })
        if (result?.ok) {
            showHistoryModal.value = false
            retryStorageReload()
        }
    } catch (e: any) {
        historyError.value = String(e?.statusMessage || e?.message || 'Falha ao restaurar')
    } finally {
        restoringHistoryKey.value = ''
    }
}
const getHistoryRestoreKey = (item: PageHistoryItem) => `${item.source}:${item.key}:${item.versionId || ''}`
const handleOpenPageHistoryEvent = () => {
    if (!canRecoverLatestNonEmpty.value) return
    void openHistoryModal()
}

const countCanvasJsonObjectsAndImages = (canvasData: any): { objects: number; images: number } => {
    const visited = new Set<any>()
    let objects = 0
    let images = 0

    const walk = (node: any) => {
        if (!node) return
        if (visited.has(node)) return
        if (typeof node === 'object') visited.add(node)

        if (Array.isArray(node)) {
            node.forEach(walk)
            return
        }

        if (typeof node !== 'object') return

        const t = String((node as any).type || '').toLowerCase()
        if (t) objects++
        if (t === 'image') images++

        const children = (node as any).objects
        if (Array.isArray(children)) walk(children)

        const clip = (node as any).clipPath
        if (clip && typeof clip === 'object') walk(clip)
    }

    walk(canvasData)
    return { objects, images }
}

const countFabricObjectsAndImages = (fabricCanvas: any): { objects: number; images: number } => {
    let objects = 0
    let images = 0
    const visited = new Set<any>()

    const walk = (obj: any) => {
        if (!obj) return
        if (visited.has(obj)) return
        visited.add(obj)

        const t = String(obj.type || '').toLowerCase()
        if (t) objects++
        if (t === 'image') images++

        if (typeof obj.getObjects === 'function') {
            try {
                const kids = obj.getObjects() || []
                kids.forEach(walk)
            } catch {
                // ignore
            }
        }
        const clip = (obj as any).clipPath
        if (clip && typeof clip === 'object') walk(clip)
    }

    try {
        const top = fabricCanvas?.getObjects?.() || []
        top.forEach(walk)
    } catch {
        // ignore
    }

    return { objects, images }
}

const loadFromJSONWithImageProgress = async (json: any, sessionId: number): Promise<void> => {
    if (!canvas.value) throw new Error('Canvas indisponível para loadFromJSON')
    // Reset progress for each attempt; it reflects the current load pipeline.
    startImageLoadTracking(sessionId, json)
    scheduleImageProgressFlush()
    try {
        await canvas.value.loadFromJSON(json)
    } finally {
        // Ensure the UI shows the final numbers for this attempt before we clear tracker.
        scheduleImageProgressFlush()
        stopImageLoadTracking(sessionId)
    }
}

const getActiveProjectPageId = (): string => {
    const page = project.pages?.[project.activePageIndex]
    return String(page?.id || '').trim()
}

const scheduleIdleStatePersistence = (opts: any, timeoutMs = 2200) => {
    const scheduledForPageId = getActiveProjectPageId()
    const run = () => {
        if (isCanvasDestroyed.value) return

        if (scheduledForPageId) {
            const currentPageId = getActiveProjectPageId()
            if (!currentPageId || currentPageId !== scheduledForPageId) {
                return
            }
        }

        const nextOpts = { ...(opts || {}) }
        if (scheduledForPageId && !nextOpts.expectedPageId) {
            nextOpts.expectedPageId = scheduledForPageId
        }
        saveCurrentState(nextOpts)
    }

    if (typeof window === 'undefined') {
        run();
        return;
    }

    const ric = (window as any).requestIdleCallback;
    if (typeof ric === 'function') {
        ric(() => run(), { timeout: timeoutMs });
        return;
    }

    window.setTimeout(run, Math.min(1200, timeoutMs));
}

const scheduleIdleWork = (work: () => void, timeoutMs = 2200) => {
    if (typeof window === 'undefined') {
        work();
        return;
    }

    const ric = (window as any).requestIdleCallback;
    if (typeof ric === 'function') {
        ric(() => work(), { timeout: timeoutMs });
        return;
    }

    window.setTimeout(work, Math.min(1200, timeoutMs));
}

const pageSettings = ref({
    backgroundColor: '#1e1e1e' // Match default dark workspace
})

// === Frame Label Overlays (clickable HTML labels for all frames) ===
const frameLabels = ref<Array<{ id: string; name: string; x: number; y: number; dimX: number; dimY: number; dims: string; isSelected: boolean; frameRef: any }>>([]);

let frameLabelUpdatePending = false;
let frameLabelUpdateTimer: ReturnType<typeof setTimeout> | null = null;
let lastFrameLabelUpdateAt = 0;
let lastKnownFrameLabelCount = 0;
const getFrameLabelUpdateIntervalMs = () => {
    const count = lastKnownFrameLabelCount;
    if (count > 240) return 280;
    if (count > 120) return 180;
    if (count > 60) return 120;
    return 80;
};
const throttledUpdateFrameLabels = () => {
    if (frameLabelUpdatePending) return;

    const run = () => {
        if (frameLabelUpdatePending) return;
        frameLabelUpdatePending = true;
        requestAnimationFrame(() => {
            updateFrameLabels();
            lastFrameLabelUpdateAt = performance.now();
            frameLabelUpdatePending = false;
        });
    };

    const intervalMs = getFrameLabelUpdateIntervalMs();
    const now = performance.now();
    const elapsed = now - lastFrameLabelUpdateAt;
    if (elapsed >= intervalMs) {
        run();
        return;
    }

    if (frameLabelUpdateTimer) return;
    frameLabelUpdateTimer = setTimeout(() => {
        frameLabelUpdateTimer = null;
        run();
    }, Math.max(0, intervalMs - elapsed));
};

const updateFrameLabels = () => {
    if (!canvas.value || !wrapperEl.value || isCanvasDestroyed.value) {
        frameLabels.value = [];
        return;
    }
    const frames = getAllFrames();
    lastKnownFrameLabelCount = frames.length;
    if (!frames.length) {
        frameLabels.value = [];
        return;
    }
    const zoomVal = Number(canvas.value.getZoom?.() || 1);
    // Performance guard: with many frames and zoomed far out, labels become unreadable and expensive.
    if (frames.length > 180 && zoomVal < 0.35) {
        frameLabels.value = [];
        return;
    }
    const vpt = canvas.value.viewportTransform;
    if (!vpt) { frameLabels.value = []; return; }
    const activeObj = canvas.value.getActiveObject();
    const fmt = (n: number) => {
        if (!Number.isFinite(n)) return '0';
        const rounded = Math.round(n);
        if (Math.abs(n - rounded) < 0.01) return String(rounded);
        return n.toFixed(2);
    };
    const labels: typeof frameLabels.value = [];
    for (const frame of frames) {
        if (frame?.visible === false) continue;
        try {
            const bounds = typeof frame.getBoundingRect === 'function'
                ? frame.getBoundingRect(true, true)
                : frame.getBoundingRect();
            const p_tl = fabric.util.transformPoint({ x: bounds.left, y: bounds.top }, vpt);
            // Dimensões reais do frame
            const w = frame.width * (frame.scaleX || 1);
            const h = frame.height * (frame.scaleY || 1);
            // Posição do badge de dimensões (center-bottom do frame)
            const center = frame.getCenterPoint();
            const p_bc_raw = { x: center.x, y: center.y + (h / 2) };
            const p_bc = fabric.util.transformPoint(p_bc_raw, vpt);
            labels.push({
                id: frame._customId || '',
                name: (frame.layerName || frame.name || 'Frame').toString(),
                x: Math.max(4, p_tl.x),
                y: Math.max(4, p_tl.y - 22),
                dimX: p_bc.x,
                dimY: p_bc.y + 8,
                dims: `${fmt(w)} × ${fmt(h)}`,
                isSelected: activeObj === frame,
                frameRef: frame,
            });
        } catch { /* skip invalid frame */ }
    }
    frameLabels.value = labels;
};

const handleFrameLabelClick = (label: typeof frameLabels.value[0], e: MouseEvent) => {
    e.stopPropagation();
    e.preventDefault();
    if (!canvas.value || !label.frameRef) return;
    canvas.value.setActiveObject(label.frameRef);
    canvas.value.requestRenderAll();
    updateSelection();
    refreshCanvasObjects();
};

const handleFrameLabelMouseDown = (label: typeof frameLabels.value[0], e: MouseEvent) => {
    e.stopPropagation();
    e.preventDefault();
    if (!canvas.value || !label.frameRef) return;
    const frame = label.frameRef;

    // Select frame first
    canvas.value.setActiveObject(frame);
    canvas.value.requestRenderAll();
    updateSelection();

    // Start drag tracking
    const startX = e.clientX;
    const startY = e.clientY;
    const zoom = canvas.value.getZoom() || 1;
    const startLeft = frame.left;
    const startTop = frame.top;
    let moved = false;

    // Get descendants once
    const descendants = getFrameDescendants(frame);

    let frameLabelDragRaf = 0;
    const onMouseMove = (moveEvt: MouseEvent) => {
        const dx = (moveEvt.clientX - startX) / zoom;
        const dy = (moveEvt.clientY - startY) / zoom;
        if (!moved && Math.abs(dx) < 2 && Math.abs(dy) < 2) return;
        moved = true;
        
        if (frameLabelDragRaf) cancelAnimationFrame(frameLabelDragRaf);
        frameLabelDragRaf = requestAnimationFrame(() => {
            frame.set({ left: startLeft + dx, top: startTop + dy });
            frame.setCoords();
            // Reset to absolute positions for descendants
            descendants.forEach((d: any) => {
                if ((d as any).__dragStart) {
                    d.set({ left: (d as any).__dragStart.left + dx, top: (d as any).__dragStart.top + dy });
                    d.setCoords();
                }
            });
            canvas.value.requestRenderAll();
            throttledUpdateFrameLabels();
        });
    };

    const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        descendants.forEach((d: any) => { delete (d as any).__dragStart; });
        if (moved) {
            // Sync clips after move
            if (frame.clipContent) {
                syncFrameClips(frame);
            }
            canvas.value.requestRenderAll();
            refreshCanvasObjects();
            saveCurrentState();
        }
    };

    // Store initial positions
    descendants.forEach((d: any) => { (d as any).__dragStart = { left: d.left, top: d.top }; });

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
};

// Virtual Scrollbars State
const scrollV = ref({ top: 0, height: 0, visible: false })
const scrollH = ref({ left: 0, width: 0, visible: false })
const SCROLLBAR_PADDING = 100
const SCROLLBAR_IGNORED_IDS = new Set(['artboard-bg', 'guide-vertical', 'guide-horizontal'])

type ScrollbarContentBounds = {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    pageWidth: number;
    pageHeight: number;
};

let scrollbarBoundsDirty = true
let scrollbarBoundsCache: ScrollbarContentBounds | null = null
let lastScrollbarSanitizeAt = 0
const SCROLLBAR_SANITIZE_INTERVAL_MS = 1200

const invalidateScrollbarBounds = () => {
    scrollbarBoundsDirty = true
}

const isScrollbarRelevantObject = (obj: any): boolean => {
    if (!isValidFabricCanvasObject(obj)) return false
    if (obj.excludeFromExport) return false
    if (SCROLLBAR_IGNORED_IDS.has(String(obj.id || ''))) return false
    return true
}

const getScrollbarContentBounds = (): ScrollbarContentBounds => {
    const pageWidth = activePage.value?.width || 1080
    const pageHeight = activePage.value?.height || 1920

    if (
        !scrollbarBoundsDirty &&
        scrollbarBoundsCache &&
        scrollbarBoundsCache.pageWidth === pageWidth &&
        scrollbarBoundsCache.pageHeight === pageHeight
    ) {
        return scrollbarBoundsCache
    }

    const canvasInstance = canvas.value as any
    if (scrollbarBoundsDirty && canvasInstance) {
        const now = Date.now()
        const objectCount = Number(canvasInstance?.getObjects?.()?.length || 0)
        const adaptiveSanitizeInterval =
            objectCount > 600 ? 5000 :
            objectCount > 250 ? 2500 :
            SCROLLBAR_SANITIZE_INTERVAL_MS
        if (now - lastScrollbarSanitizeAt > adaptiveSanitizeInterval) {
            sanitizeCanvasObjectStack(canvasInstance, 'scrollbar-bounds')
            lastScrollbarSanitizeAt = now
        }
    }
    const objects = canvasInstance?.getObjects?.() || []
    let minX = Infinity
    let minY = Infinity
    let maxX = -Infinity
    let maxY = -Infinity
    let hasRelevantObjects = false

    for (const obj of objects) {
        if (!isScrollbarRelevantObject(obj)) continue
        if (typeof obj.getBoundingRect !== 'function') continue
        hasRelevantObjects = true
        const bounds = obj.getBoundingRect(true, true)
        if (!bounds || !Number.isFinite(bounds.left) || !Number.isFinite(bounds.top) || !Number.isFinite(bounds.width) || !Number.isFinite(bounds.height)) {
            continue
        }
        const oMinX = bounds.left
        const oMinY = bounds.top
        const oMaxX = bounds.left + bounds.width
        const oMaxY = bounds.top + bounds.height
        if (oMinX < minX) minX = oMinX
        if (oMinY < minY) minY = oMinY
        if (oMaxX > maxX) maxX = oMaxX
        if (oMaxY > maxY) maxY = oMaxY
    }

    if (!hasRelevantObjects) {
        minX = 0
        minY = 0
        maxX = pageWidth
        maxY = pageHeight
    }

    scrollbarBoundsCache = { minX, minY, maxX, maxY, pageWidth, pageHeight }
    scrollbarBoundsDirty = false
    return scrollbarBoundsCache
}

// Throttle for scrollbar updates
let scrollbarUpdatePending = false
const throttledUpdateScrollbars = () => {
    if (scrollbarUpdatePending) return
    scrollbarUpdatePending = true
    requestAnimationFrame(() => {
        updateScrollbars()
        scrollbarUpdatePending = false
    })
}

const updateScrollbars = () => {
    if (!canvas.value || !wrapperEl.value) return;

    const vpt = canvas.value.viewportTransform;
    const zoom = canvas.value.getZoom();
    const width = canvas.value.getWidth();
    const height = canvas.value.getHeight();

    const { minX, minY, maxX, maxY } = getScrollbarContentBounds()

    // Padding for the "Infinite" feel
    const contentWidth = maxX - minX + SCROLLBAR_PADDING * 2;
    const contentHeight = maxY - minY + SCROLLBAR_PADDING * 2;
    
    // Viewport dimensions in canvas coordinates
    const viewportWidth = width / zoom;
    const viewportHeight = height / zoom;
    const viewportLeft = -vpt[4] / zoom;
    const viewportTop = -vpt[5] / zoom;
    const viewportRight = viewportLeft + viewportWidth;
    const viewportBottom = viewportTop + viewportHeight;

    // Content boundaries with padding
    const contentLeft = minX - SCROLLBAR_PADDING;
    const contentRight = maxX + SCROLLBAR_PADDING;
    const contentTop = minY - SCROLLBAR_PADDING;
    const contentBottom = maxY + SCROLLBAR_PADDING;

    // VERTICAL SCROLLBAR - Show if content is taller than viewport OR viewport is panned (infinite canvas)
    const needsVerticalScroll = contentHeight > viewportHeight;
    const hasContentAbove = contentTop < viewportTop;
    const hasContentBelow = contentBottom > viewportBottom;
    const isPannedVertically = Math.abs(vpt[5]) > 5; // Viewport is panned (lower threshold)
    
    // Always show vertical scrollbar when content is taller or when panned
    scrollV.value.visible = needsVerticalScroll || isPannedVertically;
    
    if (scrollV.value.visible) {
        // For infinite canvas, use a larger virtual content area when panned
        const effectiveContentHeight = isPannedVertically && !needsVerticalScroll 
            ? Math.max(contentHeight, viewportHeight * 2) 
            : contentHeight;
        
        // Calculate scrollbar thumb height and position
        const scrollbarHeight = Math.max(40, (viewportHeight / effectiveContentHeight) * height);
        const scrollableHeight = effectiveContentHeight - viewportHeight;
        // Anchor the virtual space to the content bounds (stable) so the thumb moves while panning.
        const effectiveContentTop = isPannedVertically && !needsVerticalScroll
            ? contentTop - (effectiveContentHeight - contentHeight) / 2
            : contentTop;
        const scrollProgress = scrollableHeight > 0 ? Math.max(0, Math.min(1, (viewportTop - effectiveContentTop) / scrollableHeight)) : 0;
        scrollV.value.height = scrollbarHeight;
        scrollV.value.top = scrollProgress * (height - scrollbarHeight);
    }

    // HORIZONTAL SCROLLBAR - Show if content is wider than viewport OR viewport is panned (infinite canvas)
    const needsHorizontalScroll = contentWidth > viewportWidth;
    const hasContentLeft = contentLeft < viewportLeft;
    const hasContentRight = contentRight > viewportRight;
    const isPannedHorizontally = Math.abs(vpt[4]) > 5; // Viewport is panned (lower threshold)
    
    // Always show horizontal scrollbar when content is wider or when panned
    scrollH.value.visible = needsHorizontalScroll || isPannedHorizontally;
    
    if (scrollH.value.visible) {
        // For infinite canvas, use a larger virtual content area when panned
        const effectiveContentWidth = isPannedHorizontally && !needsHorizontalScroll 
            ? Math.max(contentWidth, viewportWidth * 2) 
            : contentWidth;
        
        // Calculate scrollbar thumb width and position
        const scrollbarWidth = Math.max(40, (viewportWidth / effectiveContentWidth) * width);
        const scrollableWidth = effectiveContentWidth - viewportWidth;
        // Anchor the virtual space to the content bounds (stable) so the thumb moves while panning.
        const effectiveContentLeft = isPannedHorizontally && !needsHorizontalScroll
            ? contentLeft - (effectiveContentWidth - contentWidth) / 2
            : contentLeft;
        const scrollProgress = scrollableWidth > 0 ? Math.max(0, Math.min(1, (viewportLeft - effectiveContentLeft) / scrollableWidth)) : 0;
        scrollH.value.width = scrollbarWidth;
        scrollH.value.left = scrollProgress * (width - scrollbarWidth);
    }

    // Do not trigger viewport culling from scrollbar recalculation; this path runs
    // very often and may cause render oscillation ("tremor") on some browsers.
    // Culling still runs on wheel/pan/object-move paths.
}

const VIEWPORT_CULL_MIN_OBJECTS = 1200
const VIEWPORT_CULL_PADDING = 240
const VIEWPORT_CULL_INTERVAL_MS = 140
const EDITOR_PERF_STORAGE_KEY = 'editor:perf-metrics:v1'
const EDITOR_PERF_RENDER_COMMIT_INTERVAL_MS = 120
const editorPerfMetricsEnabled = ref(true)
const editorPerfMetrics = shallowRef({
    enabled: true,
    cullRuns: 0,
    cullReason: 'idle',
    objectCount: 0,
    visibleObjects: 0,
    culledObjects: 0,
    changedObjects: 0,
    restoredObjects: 0,
    cullDurationMs: 0,
    cullAvgMs: 0,
    cullMaxMs: 0,
    fps: 0,
    fpsAvg: 0,
    fpsMin: 0,
    fpsMax: 0,
    renderFrames: 0,
    updatedAt: 0
})
let viewportCullRafId: number | null = null
let viewportCullTimer: ReturnType<typeof setTimeout> | null = null
let lastViewportCullAt = 0
let lastViewportCullSignature = ''
let editorPerfLastRenderAt = 0
let editorPerfLastRenderCommitAt = 0
let editorPerfRenderFrames = 0
let editorPerfFpsAvg = 0
let editorPerfFpsMin = Number.POSITIVE_INFINITY
let editorPerfFpsMax = 0

const getEditorPerfNow = () => (
    typeof performance !== 'undefined' && typeof performance.now === 'function'
        ? performance.now()
        : Date.now()
)

const roundEditorPerf = (value: number) => Number(Number.isFinite(value) ? value.toFixed(2) : '0')

const persistEditorPerfPreference = (enabled: boolean) => {
    if (!import.meta.client) return
    try {
        localStorage.setItem(EDITOR_PERF_STORAGE_KEY, enabled ? '1' : '0')
    } catch {
        // ignore
    }
}

const resetEditorRenderPerfCounters = () => {
    editorPerfLastRenderAt = 0
    editorPerfLastRenderCommitAt = 0
    editorPerfRenderFrames = 0
    editorPerfFpsAvg = 0
    editorPerfFpsMin = Number.POSITIVE_INFINITY
    editorPerfFpsMax = 0
}

const setEditorPerfMetricsEnabled = (enabled: boolean) => {
    const normalized = !!enabled
    editorPerfMetricsEnabled.value = normalized
    persistEditorPerfPreference(normalized)
    resetEditorRenderPerfCounters()
    editorPerfMetrics.value = {
        ...editorPerfMetrics.value,
        enabled: normalized,
        updatedAt: Date.now()
    }
}

const loadEditorPerfPreference = () => {
    if (!import.meta.client) return
    try {
        const raw = localStorage.getItem(EDITOR_PERF_STORAGE_KEY)
        if (raw === null) {
            setEditorPerfMetricsEnabled(true)
            return
        }
        setEditorPerfMetricsEnabled(raw !== '0')
    } catch {
        setEditorPerfMetricsEnabled(true)
    }
}

const publishEditorPerfBridge = () => {
    if (typeof window === 'undefined') return
    ;(window as any).__editorPerf = {
        __owner: 'EditorCanvas',
        get snapshot() {
            return editorPerfMetrics.value
        },
        enable: () => setEditorPerfMetricsEnabled(true),
        disable: () => setEditorPerfMetricsEnabled(false),
        toggle: () => setEditorPerfMetricsEnabled(!editorPerfMetricsEnabled.value),
        print: () => console.table(editorPerfMetrics.value)
    }
}

const clearEditorPerfBridge = () => {
    if (typeof window === 'undefined') return
    const bridge = (window as any).__editorPerf
    if (bridge && bridge.__owner === 'EditorCanvas') {
        delete (window as any).__editorPerf
    }
}

const updateViewportCullPerf = (
    reason: string,
    objects: any[],
    changedObjects: number,
    restoredObjects: number,
    durationMs: number
) => {
    if (!editorPerfMetricsEnabled.value) return
    let visibleObjects = 0
    let culledObjects = 0
    for (const obj of objects) {
        if (!obj || typeof obj !== 'object') continue
        if (obj.visible !== false) visibleObjects++
        if ((obj as any).__viewportCulled) culledObjects++
    }

    const prev = editorPerfMetrics.value
    const cullRuns = Number(prev.cullRuns || 0) + 1
    const cullAvgMs = cullRuns <= 1
        ? durationMs
        : (((Number(prev.cullAvgMs || 0) * (cullRuns - 1)) + durationMs) / cullRuns)
    const cullMaxMs = Math.max(Number(prev.cullMaxMs || 0), durationMs)

    editorPerfMetrics.value = {
        ...prev,
        enabled: true,
        cullReason: reason,
        cullRuns,
        objectCount: objects.length,
        visibleObjects,
        culledObjects,
        changedObjects,
        restoredObjects,
        cullDurationMs: roundEditorPerf(durationMs),
        cullAvgMs: roundEditorPerf(cullAvgMs),
        cullMaxMs: roundEditorPerf(cullMaxMs),
        updatedAt: Date.now()
    }
}

const handleAfterRenderPerf = () => {
    if (!editorPerfMetricsEnabled.value) return
    const now = getEditorPerfNow()
    if (editorPerfLastRenderAt <= 0) {
        editorPerfLastRenderAt = now
        return
    }

    const delta = now - editorPerfLastRenderAt
    editorPerfLastRenderAt = now
    if (delta <= 0 || delta > 2200) return

    const fps = 1000 / delta
    editorPerfRenderFrames += 1
    editorPerfFpsAvg = editorPerfRenderFrames <= 1
        ? fps
        : (((editorPerfFpsAvg * (editorPerfRenderFrames - 1)) + fps) / editorPerfRenderFrames)
    editorPerfFpsMin = Math.min(editorPerfFpsMin, fps)
    editorPerfFpsMax = Math.max(editorPerfFpsMax, fps)

    const shouldCommit = (now - editorPerfLastRenderCommitAt) >= EDITOR_PERF_RENDER_COMMIT_INTERVAL_MS
    if (!shouldCommit) return

    editorPerfLastRenderCommitAt = now
    const prev = editorPerfMetrics.value
    editorPerfMetrics.value = {
        ...prev,
        enabled: true,
        fps: roundEditorPerf(fps),
        fpsAvg: roundEditorPerf(editorPerfFpsAvg),
        fpsMin: roundEditorPerf(editorPerfFpsMin === Number.POSITIVE_INFINITY ? fps : editorPerfFpsMin),
        fpsMax: roundEditorPerf(editorPerfFpsMax),
        renderFrames: editorPerfRenderFrames,
        updatedAt: Date.now()
    }
}

onMounted(() => {
    loadEditorPerfPreference()
    publishEditorPerfBridge()
})

onUnmounted(() => {
    clearEditorPerfBridge()
    resetEditorRenderPerfCounters()
})

const getViewportCullRect = () => {
    if (!canvas.value) return null
    const c = canvas.value
    const vpt = c.viewportTransform || [1, 0, 0, 1, 0, 0]
    const zoom = Math.max(0.0001, Number(c.getZoom?.() || 1) || 1)
    const width = Number(c.getWidth?.() || 0) / zoom
    const height = Number(c.getHeight?.() || 0) / zoom
    const left = (-Number(vpt[4] || 0) / zoom) - VIEWPORT_CULL_PADDING
    const top = (-Number(vpt[5] || 0) / zoom) - VIEWPORT_CULL_PADDING
    return {
        left,
        top,
        right: left + width + (VIEWPORT_CULL_PADDING * 2),
        bottom: top + height + (VIEWPORT_CULL_PADDING * 2)
    }
}

const isObjectIntersectingCullRect = (obj: any, rect: { left: number; top: number; right: number; bottom: number }) => {
    if (!obj || !rect || typeof obj.getBoundingRect !== 'function') return true
    try {
        const b = obj.getBoundingRect(true, true)
        if (!b) return true
        const right = b.left + b.width
        const bottom = b.top + b.height
        if (right < rect.left) return false
        if (b.left > rect.right) return false
        if (bottom < rect.top) return false
        if (b.top > rect.bottom) return false
        return true
    } catch {
        return true
    }
}

const shouldSkipViewportCullObject = (obj: any, activeSet: Set<any>) => {
    if (!obj || typeof obj !== 'object') return true
    if (obj.group) return true
    if (activeSet.has(obj)) return true
    if (obj.isEditing) return true
    if (obj.id === 'artboard-bg') return true
    if (isControlLikeObject(obj) || isTransientCanvasObject(obj)) return true
    return false
}

const restoreViewportCulledObjects = (objects: any[]) => {
    let restored = 0
    objects.forEach((obj: any) => {
        if (!obj || !(obj as any).__viewportCulled) return
        const prevVisible = (obj as any).__viewportCullPrevVisible
        const prevEvented = (obj as any).__viewportCullPrevEvented
        const prevSelectable = (obj as any).__viewportCullPrevSelectable
        obj.set?.('visible', prevVisible === undefined ? true : prevVisible)
        obj.set?.('evented', prevEvented === undefined ? true : prevEvented)
        obj.set?.('selectable', prevSelectable === undefined ? true : prevSelectable)
        obj.visible = prevVisible === undefined ? true : prevVisible
        obj.evented = prevEvented === undefined ? true : prevEvented
        obj.selectable = prevSelectable === undefined ? true : prevSelectable
        obj.dirty = true
        delete (obj as any).__viewportCullPrevVisible
        delete (obj as any).__viewportCullPrevEvented
        delete (obj as any).__viewportCullPrevSelectable
        delete (obj as any).__viewportCulled
        restored++
    })
    return restored
}

const applyViewportCulling = (reason: string = 'unknown') => {
    if (!canvas.value || isCanvasDestroyed.value) return
    const c = canvas.value
    const objects = c.getObjects?.() || []
    const startedAt = editorPerfMetricsEnabled.value ? getEditorPerfNow() : 0

    if (objects.length < VIEWPORT_CULL_MIN_OBJECTS) {
        const restored = restoreViewportCulledObjects(objects)
        if (restored > 0) {
            safeRequestRenderAll(c)
            refreshCanvasObjects()
        }
        if (startedAt > 0) {
            updateViewportCullPerf(reason, objects, restored, restored, getEditorPerfNow() - startedAt)
        }
        return
    }

    const rect = getViewportCullRect()
    if (!rect) return

    const vpt = c.viewportTransform || [1, 0, 0, 1, 0, 0]
    const zoom = Number(c.getZoom?.() || 1) || 1
    const signature = [
        Number(vpt[4] || 0).toFixed(1),
        Number(vpt[5] || 0).toFixed(1),
        zoom.toFixed(4),
        String(objects.length)
    ].join('|')

    const allowSignatureShortCircuit = reason === 'scrollbars'
    if (allowSignatureShortCircuit && signature === lastViewportCullSignature) return
    lastViewportCullSignature = signature

    const activeObjects = c.getActiveObjects?.() || []
    const activeSet = new Set<any>(activeObjects)
    const singleActive = c.getActiveObject?.()
    if (singleActive) activeSet.add(singleActive)

    let changed = 0
    let restored = 0
    objects.forEach((obj: any) => {
        if (shouldSkipViewportCullObject(obj, activeSet)) return
        const inView = isObjectIntersectingCullRect(obj, rect)
        const wasCulled = !!(obj as any).__viewportCulled

        if (!inView) {
            if (!wasCulled) {
                ;(obj as any).__viewportCulled = true
                ;(obj as any).__viewportCullPrevVisible = obj.visible
                ;(obj as any).__viewportCullPrevEvented = obj.evented
                ;(obj as any).__viewportCullPrevSelectable = obj.selectable
            }
            if (obj.visible !== false) {
                obj.set?.('visible', false)
                obj.visible = false
                changed++
            }
            if (obj.evented !== false) {
                obj.set?.('evented', false)
                obj.evented = false
            }
            if (obj.selectable !== false) {
                obj.set?.('selectable', false)
                obj.selectable = false
            }
            obj.dirty = true
            return
        }

        if (!wasCulled) return
        const prevVisible = (obj as any).__viewportCullPrevVisible
        const prevEvented = (obj as any).__viewportCullPrevEvented
        const prevSelectable = (obj as any).__viewportCullPrevSelectable
        obj.set?.('visible', prevVisible === undefined ? true : prevVisible)
        obj.set?.('evented', prevEvented === undefined ? true : prevEvented)
        obj.set?.('selectable', prevSelectable === undefined ? true : prevSelectable)
        obj.visible = prevVisible === undefined ? true : prevVisible
        obj.evented = prevEvented === undefined ? true : prevEvented
        obj.selectable = prevSelectable === undefined ? true : prevSelectable
        obj.dirty = true
        delete (obj as any).__viewportCullPrevVisible
        delete (obj as any).__viewportCullPrevEvented
        delete (obj as any).__viewportCullPrevSelectable
        delete (obj as any).__viewportCulled
        changed++
        restored++
    })

    if (changed > 0) {
        safeRequestRenderAll(c)
        refreshCanvasObjects()
    }

    if (startedAt > 0) {
        updateViewportCullPerf(reason, objects, changed, restored, getEditorPerfNow() - startedAt)
    }
}

const scheduleViewportCulling = (reason: string = 'unknown') => {
    if (!canvas.value || isCanvasDestroyed.value) return
    if (typeof window === 'undefined') {
        applyViewportCulling(reason)
        return
    }

    const run = () => {
        if (viewportCullRafId !== null) return
        viewportCullRafId = requestAnimationFrame(() => {
            viewportCullRafId = null
            lastViewportCullAt = performance.now()
            applyViewportCulling(reason)
        })
    }

    const now = performance.now()
    const elapsed = now - lastViewportCullAt
    if (elapsed >= VIEWPORT_CULL_INTERVAL_MS) {
        run()
        return
    }

    if (viewportCullTimer) return
    viewportCullTimer = setTimeout(() => {
        viewportCullTimer = null
        run()
    }, Math.max(0, VIEWPORT_CULL_INTERVAL_MS - elapsed))
}

// Scrollbar drag handlers
const handleVerticalScrollbarDrag = (e: MouseEvent) => {
    if (!canvas.value || !wrapperEl.value) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const startY = e.clientY;
    const startTop = scrollV.value.top;
    const height = wrapperEl.value.clientHeight;
    const vpt = canvas.value.viewportTransform;
    const zoom = canvas.value.getZoom();
    
    const { minY, maxY } = getScrollbarContentBounds()
    
    const contentHeight = maxY - minY + SCROLLBAR_PADDING * 2;
    const viewportHeight = height / zoom;
    const viewportTop = -vpt[5] / zoom;
    const isPannedVertically = Math.abs(vpt[5]) > 10;
    const needsVerticalScroll = contentHeight > viewportHeight;
    
    // For infinite canvas, use a larger virtual content area when panned
    const effectiveContentHeight = isPannedVertically && !needsVerticalScroll 
        ? Math.max(contentHeight, viewportHeight * 2) 
        : contentHeight;
    const contentTop = minY - SCROLLBAR_PADDING;
    const effectiveContentTop = isPannedVertically && !needsVerticalScroll
        ? contentTop - (effectiveContentHeight - contentHeight) / 2
        : contentTop;
    const scrollableHeight = effectiveContentHeight - viewportHeight;
    
    const onMouseMove = (moveEvent: MouseEvent) => {
        const deltaY = moveEvent.clientY - startY;
        const newTop = Math.max(0, Math.min(height - scrollV.value.height, startTop + deltaY));
        scrollV.value.top = newTop;
        
        // Calculate new viewport position
        const scrollProgress = scrollableHeight > 0 ? newTop / (height - scrollV.value.height) : 0;
        const newViewportTop = effectiveContentTop + (scrollProgress * scrollableHeight);
        vpt[5] = -newViewportTop * zoom;
        
        safeRequestRenderAll();
        throttledUpdateScrollbars();
        scheduleViewportStateSave('scrollbar-vertical');
    };
    
    const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        flushViewportStateSave('scrollbar-vertical-end');
    };
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
};

const handleHorizontalScrollbarDrag = (e: MouseEvent) => {
    if (!canvas.value || !wrapperEl.value) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const startX = e.clientX;
    const startLeft = scrollH.value.left;
    const width = wrapperEl.value.clientWidth;
    const vpt = canvas.value.viewportTransform;
    const zoom = canvas.value.getZoom();
    
    const { minX, maxX } = getScrollbarContentBounds()
    
    const contentWidth = maxX - minX + SCROLLBAR_PADDING * 2;
    const viewportWidth = width / zoom;
    const viewportLeft = -vpt[4] / zoom;
    const isPannedHorizontally = Math.abs(vpt[4]) > 10;
    const needsHorizontalScroll = contentWidth > viewportWidth;
    
    // For infinite canvas, use a larger virtual content area when panned
    const effectiveContentWidth = isPannedHorizontally && !needsHorizontalScroll 
        ? Math.max(contentWidth, viewportWidth * 2) 
        : contentWidth;
    const contentLeft = minX - SCROLLBAR_PADDING;
    const effectiveContentLeft = isPannedHorizontally && !needsHorizontalScroll
        ? contentLeft - (effectiveContentWidth - contentWidth) / 2
        : contentLeft;
    const scrollableWidth = effectiveContentWidth - viewportWidth;
    
    const onMouseMove = (moveEvent: MouseEvent) => {
        const deltaX = moveEvent.clientX - startX;
        const newLeft = Math.max(0, Math.min(width - scrollH.value.width, startLeft + deltaX));
        scrollH.value.left = newLeft;
        
        // Calculate new viewport position
        const scrollProgress = scrollableWidth > 0 ? newLeft / (width - scrollH.value.width) : 0;
        const newViewportLeft = effectiveContentLeft + (scrollProgress * scrollableWidth);
        vpt[4] = -newViewportLeft * zoom;
        
        safeRequestRenderAll();
        throttledUpdateScrollbars();
        scheduleViewportStateSave('scrollbar-horizontal');
    };
    
    const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        flushViewportStateSave('scrollbar-horizontal-end');
    };
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
};

// View Controls
const updateZoomState = (opts?: { immediate?: boolean }) => {
    if (!canvas.value) return;
    const nextZoom = Math.round(canvas.value.getZoom() * 100);
    if (currentZoom.value !== nextZoom) {
        currentZoom.value = nextZoom;
    }
    if (opts?.immediate) {
        updateScrollbars();
    } else {
        throttledUpdateScrollbars();
    }
}

const persistViewportStateNow = (reason: string = 'change') => {
    if (!canvas.value || isCanvasDestroyed.value) return;
    try {
        saveCurrentState({
            reason: `viewport:${String(reason || 'change')}`,
            skipIfUnchanged: true
        });
    } catch (err) {
        console.warn('[viewport] Falha ao persistir estado de viewport:', err);
    }
};

const scheduleViewportStateSave = (
    reason: string = 'change',
    opts: { delayMs?: number; immediate?: boolean } = {}
) => {
    if (isCanvasDestroyed.value) return;
    if (opts.immediate) {
        if (viewportStateSaveTimer) {
            clearTimeout(viewportStateSaveTimer);
            viewportStateSaveTimer = null;
        }
        persistViewportStateNow(reason);
        return;
    }
    const delayMs = Math.max(0, Number(opts.delayMs ?? 240) || 240);
    if (viewportStateSaveTimer) {
        clearTimeout(viewportStateSaveTimer);
        viewportStateSaveTimer = null;
    }
    viewportStateSaveTimer = setTimeout(() => {
        viewportStateSaveTimer = null;
        persistViewportStateNow(reason);
    }, delayMs);
};

const flushViewportStateSave = (reason: string = 'flush') => {
    if (viewportStateSaveTimer) {
        clearTimeout(viewportStateSaveTimer);
        viewportStateSaveTimer = null;
    }
    persistViewportStateNow(reason);
};

// Close zoom menu when clicking outside
let zoomMenuOutsideClickHandler: ((e: MouseEvent) => void) | null = null
onMounted(() => {
    if (!zoomMenuOutsideClickHandler) {
        zoomMenuOutsideClickHandler = (e: MouseEvent) => {
        if (showZoomMenu.value && !(e.target as HTMLElement).closest('.group')) {
            showZoomMenu.value = false
        }
        }
    }
    document.addEventListener('click', zoomMenuOutsideClickHandler)
})
onUnmounted(() => {
    if (zoomMenuOutsideClickHandler) {
        document.removeEventListener('click', zoomMenuOutsideClickHandler)
        zoomMenuOutsideClickHandler = null
    }
})

const handleZoomIn = () => {
    if (!canvas.value) return;
    let zoom = canvas.value.getZoom();
    zoom *= 1.2;
    if (zoom > 20) zoom = 20;
    
    let point = { x: canvas.value.getWidth() / 2, y: canvas.value.getHeight() / 2 };
    
    const activeObject = canvas.value.getActiveObject();
    if (activeObject) {
         const center = activeObject.getCenterPoint();
         const vpt = canvas.value.viewportTransform;
         point = {
             x: center.x * vpt[0] + vpt[4],
             y: center.y * vpt[3] + vpt[5]
         };
    }

    canvas.value.zoomToPoint(point, zoom);
    updateZoomState();
    scheduleViewportStateSave('zoom-in');
}

const handleZoomOut = () => {
    if (!canvas.value) return;
    let zoom = canvas.value.getZoom();
    zoom *= 0.8;
    if (zoom < 0.01) zoom = 0.01;
    
    let point = { x: canvas.value.getWidth() / 2, y: canvas.value.getHeight() / 2 };
    
    const activeObject = canvas.value.getActiveObject();
    if (activeObject) {
         const center = activeObject.getCenterPoint();
         const vpt = canvas.value.viewportTransform;
         point = {
             x: center.x * vpt[0] + vpt[4],
             y: center.y * vpt[3] + vpt[5]
         };
    }

    canvas.value.zoomToPoint(point, zoom);
    updateZoomState();
    scheduleViewportStateSave('zoom-out');
}

const handleZoom100 = () => {
    if (!canvas.value) return;
    // Reset viewport transform to 1, but keep center?
    // Usually 100% means 1 pixel = 1 pixel.
    canvas.value.setZoom(1);

    // Center logic (optional)
    const vpw = canvas.value.getWidth();
    const vph = canvas.value.getHeight();
    // Assuming A4 or standard size, we center the viewport
    // canvas.value.viewportTransform[4] = (vpw - (activePage.value.width))/2; // simplified
    // canvas.value.viewportTransform[5] = (vph - (activePage.value.height))/2;

    canvas.value.requestRenderAll();
    updateZoomState();
    scheduleViewportStateSave('zoom-100');
}

const handleZoom50 = () => {
    if (!canvas.value) return;
    canvas.value.setZoom(0.5);
    canvas.value.requestRenderAll();
    updateZoomState();
    scheduleViewportStateSave('zoom-50');
}

const handleZoom200 = () => {
    if (!canvas.value) return;
    canvas.value.setZoom(2);
    canvas.value.requestRenderAll();
    updateZoomState();
    scheduleViewportStateSave('zoom-200');
}

const handleZoom400 = () => {
    if (!canvas.value) return;
    canvas.value.setZoom(4);
    canvas.value.requestRenderAll();
    updateZoomState();
    scheduleViewportStateSave('zoom-400');
}

const handleZoomToSelection = () => {
    if (!canvas.value || !selectedObjectRef.value) return;
    const obj = selectedObjectRef.value;
    // Zoom to fit the selected object
    const padding = 20;
    const vpw = canvas.value.getWidth();
    const vph = canvas.value.getHeight();
    const objWidth = (obj.width || 1) * (obj.scaleX || 1);
    const objHeight = (obj.height || 1) * (obj.scaleY || 1);
    const scaleX = (vpw - padding * 2) / objWidth;
    const scaleY = (vph - padding * 2) / objHeight;
    const zoom = Math.min(scaleX, scaleY, 2); // Cap at 200%

    canvas.value.setZoom(zoom);
    canvas.value.requestRenderAll();
    updateZoomState();
    scheduleViewportStateSave('zoom-selection');
}

const canvasObjects = shallowRef<any[]>([]) // Reactive list (shallow for performance)
let canvasObjectsRefreshRafId: number | null = null
let canvasObjectsRefreshTimer: ReturnType<typeof setTimeout> | null = null
let canvasObjectsRefreshPendingSource: any[] | null = null
let lastCanvasObjectsRefreshAt = 0
const CANVAS_OBJECTS_REFRESH_MIN_INTERVAL_MS = 42

const commitCanvasObjectsRefresh = () => {
    if (isCanvasDestroyed.value) return
    const source = canvasObjectsRefreshPendingSource || canvas.value?.getObjects?.() || []
    canvasObjectsRefreshPendingSource = null
    canvasObjects.value = Array.isArray(source) ? [...source] : []
    lastCanvasObjectsRefreshAt = (typeof performance !== 'undefined' && typeof performance.now === 'function')
        ? performance.now()
        : Date.now()
}

const refreshCanvasObjects = (opts: { immediate?: boolean; source?: any[] } = {}) => {
    if (Array.isArray(opts.source)) {
        canvasObjectsRefreshPendingSource = opts.source
    } else if (!canvasObjectsRefreshPendingSource && canvas.value?.getObjects) {
        canvasObjectsRefreshPendingSource = canvas.value.getObjects()
    }

    const immediate = !!opts.immediate || typeof window === 'undefined'
    if (immediate) {
        if (canvasObjectsRefreshTimer) {
            clearTimeout(canvasObjectsRefreshTimer)
            canvasObjectsRefreshTimer = null
        }
        if (canvasObjectsRefreshRafId !== null && typeof window !== 'undefined') {
            cancelAnimationFrame(canvasObjectsRefreshRafId)
            canvasObjectsRefreshRafId = null
        }
        commitCanvasObjectsRefresh()
        return
    }

    if (canvasObjectsRefreshRafId !== null) return
    const now = (typeof performance !== 'undefined' && typeof performance.now === 'function')
        ? performance.now()
        : Date.now()
    const elapsed = now - lastCanvasObjectsRefreshAt

    const scheduleRaf = () => {
        if (canvasObjectsRefreshRafId !== null) return
        canvasObjectsRefreshRafId = requestAnimationFrame(() => {
            canvasObjectsRefreshRafId = null
            commitCanvasObjectsRefresh()
        })
    }

    if (elapsed >= CANVAS_OBJECTS_REFRESH_MIN_INTERVAL_MS) {
        scheduleRaf()
        return
    }

    if (canvasObjectsRefreshTimer) return
    canvasObjectsRefreshTimer = setTimeout(() => {
        canvasObjectsRefreshTimer = null
        scheduleRaf()
    }, Math.max(0, CANVAS_OBJECTS_REFRESH_MIN_INTERVAL_MS - elapsed))
}
const selectedObjectId = ref<string | null>(null)
const selectedObjectIds = ref<string[]>([])
const selectedObjectRef = shallowRef<any>(null) // Direct reference for properties panel (shallow for performance)

/** Refresh selectedObjectRef with a fresh snapshot so Vue detects changes in PropertiesPanel props */
const refreshSelectedRef = (extra?: Record<string, any>) => {
    refreshSelectedRefWithRecovery({
        canvas: canvas.value,
        selectedObjectRef,
        snapshotForPropertiesPanel,
        triggerSelectedObjectRef: () => triggerRef(selectedObjectRef),
        extra
    })
}

const selectedObjectPos = ref<{top: number, left: number, width: number, visible: boolean}>({ top: 0, left: 0, width: 0, visible: false })

// Debounced save for properties panel (prevents lag during rapid input changes)
let propertySaveTimer: ReturnType<typeof setTimeout> | null = null;
const debouncedSaveCurrentState = () => {
    if (propertySaveTimer) clearTimeout(propertySaveTimer);
    propertySaveTimer = setTimeout(() => {
        saveCurrentState({ reason: 'properties-panel' });
        // Property changes do not always emit Fabric `object:modified` events, so ensure DB auto-save runs too.
        triggerAutoSave();
    }, 150); // 150ms debounce for snappy feel but coalesces rapid changes
};

// Debounced save for text editing (typing in i-text/textbox does not always emit object:modified).
let textEditSaveTimer: ReturnType<typeof setTimeout> | null = null;
const queueTextEditSave = (reason = 'text-edit') => {
    if (textEditSaveTimer) clearTimeout(textEditSaveTimer);
    textEditSaveTimer = setTimeout(() => {
        saveCurrentState({ reason });
        triggerAutoSave();
    }, 180);
};
const flushTextEditSave = (reason = 'text-edit-exit') => {
    if (textEditSaveTimer) {
        clearTimeout(textEditSaveTimer);
        textEditSaveTimer = null;
    }
    saveCurrentState({ reason });
    triggerAutoSave();
};

let isLifecycleFlushInProgress = false;
let lastLifecycleFlushAt = 0;

const finalizeActiveTextEditingForPersist = () => {
    if (!canvas.value) return;
    try {
        const active = canvas.value.getActiveObject() as any;
        if (!active) return;
        const t = String(active.type || '').toLowerCase();
        if ((t === 'i-text' || t === 'textbox') && active.isEditing && typeof active.exitEditing === 'function') {
            active.exitEditing();
            active.setCoords?.();
        }
    } catch {
        // ignore
    }
};

const flushPersistenceNow = (reason: string, opts: { force?: boolean } = {}) => {
    const now = Date.now();
    const force = !!opts.force;
    if (!force && now - lastLifecycleFlushAt < 250) return;
    lastLifecycleFlushAt = now;
    if (isLifecycleFlushInProgress) return;
    isLifecycleFlushInProgress = true;

    try {
        if (propertySaveTimer) {
            clearTimeout(propertySaveTimer);
            propertySaveTimer = null;
        }
        if (textEditSaveTimer) {
            clearTimeout(textEditSaveTimer);
            textEditSaveTimer = null;
        }
        if (globalStylesSaveTimer) {
            clearTimeout(globalStylesSaveTimer);
            globalStylesSaveTimer = null;
        }
        if (viewportStateSaveTimer) {
            clearTimeout(viewportStateSaveTimer);
            viewportStateSaveTimer = null;
        }

        finalizeActiveTextEditingForPersist();

        // Save to in-memory project + local draft immediately (sync path inside saveState/updatePageData).
        try {
            saveCurrentState({
                allowEmptyOverwrite: true,
                reason: `lifecycle:${reason}`,
                source: 'system',
                skipIfUnchanged: true,
                skipCoalesce: true
            });
        } catch (err) {
            console.warn('[persist] Falha ao salvar estado em flush de lifecycle:', err);
        }

        // Also force remote save path whenever possible.
        if (hasUnsavedChanges.value) triggerAutoSave();
        void flushAutoSave().catch((err: any) => {
            console.warn('[persist] Falha no flushAutoSave:', err);
        });
    } finally {
        isLifecycleFlushInProgress = false;
    }
};

const handleEditorBeforeUnload = () => {
    flushPersistenceNow('beforeunload');
};

const handleEditorPageHide = () => {
    flushPersistenceNow('pagehide');
};

const handleEditorVisibilityChange = () => {
    if (document.visibilityState === 'hidden') {
        flushPersistenceNow('visibility-hidden');
    }
};

onMounted(() => {
    window.addEventListener('beforeunload', handleEditorBeforeUnload);
    window.addEventListener('pagehide', handleEditorPageHide);
    window.addEventListener('editor:open-page-history', handleOpenPageHistoryEvent as EventListener);
    document.addEventListener('visibilitychange', handleEditorVisibilityChange);
});

onUnmounted(() => {
    window.removeEventListener('beforeunload', handleEditorBeforeUnload);
    window.removeEventListener('pagehide', handleEditorPageHide);
    window.removeEventListener('editor:open-page-history', handleOpenPageHistoryEvent as EventListener);
    document.removeEventListener('visibilitychange', handleEditorVisibilityChange);
    if (propertySaveTimer) {
        clearTimeout(propertySaveTimer);
        propertySaveTimer = null;
    }
    if (textEditSaveTimer) {
        clearTimeout(textEditSaveTimer);
        textEditSaveTimer = null;
    }
});

// Enable/disable "Salvar da Selecao" in the label templates modal.
canSaveLabelTemplateFromSelectionComputed = computed(() => {
    return !!getPriceGroupFromAny(selectedObjectRef.value);
});

const showProjectManager = ref(false)
const viewShowGrid = ref(false)
const viewShowRulers = ref(true)
const viewShowGuides = ref(true)
const snapToObjects = ref(true)
const snapToGuides = ref(true)
const snapToGrid = ref(false)
const gridSize = ref(20)

const VIEW_SETTINGS_KEY = 'editor:viewSettings:v1'
let viewSettingsSaveTimer: ReturnType<typeof setTimeout> | null = null

const loadViewSettings = () => {
    if (!import.meta.client) return
    try {
        const raw = localStorage.getItem(VIEW_SETTINGS_KEY)
        if (!raw) return
        const data = JSON.parse(raw || '{}') || {}
        if (typeof data.viewShowGrid === 'boolean') viewShowGrid.value = data.viewShowGrid
        if (typeof data.viewShowRulers === 'boolean') viewShowRulers.value = data.viewShowRulers
        if (typeof data.viewShowGuides === 'boolean') viewShowGuides.value = data.viewShowGuides
        if (typeof data.snapToObjects === 'boolean') snapToObjects.value = data.snapToObjects
        if (typeof data.snapToGuides === 'boolean') snapToGuides.value = data.snapToGuides
        if (typeof data.snapToGrid === 'boolean') snapToGrid.value = data.snapToGrid
        const gs = Number(data.gridSize)
        if (Number.isFinite(gs) && gs > 0) gridSize.value = Math.round(gs)
    } catch {
        // ignore
    }
}

const persistViewSettings = () => {
    if (!import.meta.client) return
    try {
        const data = {
            viewShowGrid: viewShowGrid.value,
            viewShowRulers: viewShowRulers.value,
            viewShowGuides: viewShowGuides.value,
            snapToObjects: snapToObjects.value,
            snapToGuides: snapToGuides.value,
            snapToGrid: snapToGrid.value,
            gridSize: gridSize.value
        }
        localStorage.setItem(VIEW_SETTINGS_KEY, JSON.stringify(data))
    } catch {
        // ignore
    }
}

const toggleGrid = () => {
    viewShowGrid.value = !viewShowGrid.value
    applyGridBackground()
}

const createGridPatternSource = (size: number) => {
    const cell = Math.max(4, Math.round(Number(size) || 20))
    const canvasGrid = document.createElement('canvas');
    canvasGrid.width = cell;
    canvasGrid.height = cell;
    const ctx = canvasGrid.getContext('2d');
    if (ctx) {
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(cell, 0);
        ctx.lineTo(cell, cell);
        ctx.moveTo(0, cell);
        ctx.lineTo(cell, cell);
        ctx.stroke();
    }
    return canvasGrid;
}

const applyGridBackground = () => {
    if (!import.meta.client) return
    if (!canvas.value) return
    try {
        if (viewShowGrid.value) {
            const src = createGridPatternSource(gridSize.value)
            const pattern = fabric?.Pattern ? new fabric.Pattern({ source: src, repeat: 'repeat' }) : null
            if (pattern) {
                // backgroundColor accepts Pattern in Fabric v7
                canvas.value.set?.('backgroundColor', pattern)
            } else {
                // Fallback: just keep dark background
                canvas.value.set?.('backgroundColor', '#1e1e1e')
            }
        } else {
            canvas.value.set?.('backgroundColor', '#1e1e1e')
        }
        canvas.value.requestRenderAll?.()
    } catch (e) {
        console.warn('[grid] Falha ao aplicar background:', e)
    }
}

const isFullscreen = ref(false)

const toggleRulers = () => {
    viewShowRulers.value = !viewShowRulers.value
}

const toggleGuides = () => {
    viewShowGuides.value = !viewShowGuides.value
    applyUserGuidesVisibility()
}

const toggleSnapObjects = () => { snapToObjects.value = !snapToObjects.value }
const toggleSnapGuides = () => { snapToGuides.value = !snapToGuides.value }
const toggleSnapGrid = () => { snapToGrid.value = !snapToGrid.value }
const setGridSize = (size: number) => {
    const next = Math.max(4, Math.round(Number(size) || 20))
    gridSize.value = next
    if (viewShowGrid.value) applyGridBackground()
}

const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(() => {
            isFullscreen.value = true
        }).catch(err => {
            console.error('Erro ao entrar em tela cheia:', err)
        })
    } else {
        document.exitFullscreen().then(() => {
            isFullscreen.value = false
        }).catch(err => {
            console.error('Erro ao sair de tela cheia:', err)
        })
    }
}

// Listen to fullscreen changes
const handleFullscreenChange = () => {
    isFullscreen.value = !!document.fullscreenElement
}

onMounted(() => {
    document.addEventListener('fullscreenchange', handleFullscreenChange)
})

onMounted(() => {
    loadViewSettings()
})

watch(
    [viewShowGrid, viewShowRulers, viewShowGuides, snapToObjects, snapToGuides, snapToGrid, gridSize],
    () => {
        if (viewSettingsSaveTimer) clearTimeout(viewSettingsSaveTimer)
        viewSettingsSaveTimer = setTimeout(() => persistViewSettings(), 200)
    },
    { deep: false }
)

watch(viewShowGrid, () => applyGridBackground())
watch(gridSize, () => { if (viewShowGrid.value) applyGridBackground() })
watch(() => canvas.value, () => {
    // When canvas becomes ready (or is swapped), apply view settings.
    applyGridBackground()
    applyUserGuidesVisibility()
})

onUnmounted(() => {
    if (viewSettingsSaveTimer) {
        clearTimeout(viewSettingsSaveTimer)
        viewSettingsSaveTimer = null
    }
})

// Modals State
const showSaveModal = ref(false)
const saveProjectName = ref('')

const showPasteListModal = ref(false)
const pasteListText = ref('')
const activePasteTab = ref('text') // 'text' | 'image'
const pastedImage = ref<string | null>(null)
const isAnalyzingImage = ref(false)

// Product Review State (after processing)
const showProductReviewModal = ref(false)
const reviewProducts = ref<any[]>([])
const productImportExistingCount = ref(0)
const targetGridZone = ref<any>(null) // Reference to the Grid Zone that was double-clicked
const isConfirmingProductImport = ref(false)

type ImportTargetMode = 'zone' | 'multi-frame'
type FrameAssignment = { productId: string; frameId: string | null }
type ProductImportOptions = {
    mode?: 'replace' | 'append'
    labelTemplateId?: string
    targetMode?: ImportTargetMode
    selectedFrameIds?: string[]
    frameAssignments?: FrameAssignment[]
    countRule?: 'min'
    cardsPerFrame?: 1
}

type SmartGridRunOptions = {
    mode?: 'replace' | 'append'
    labelTemplateId?: string
    persist?: boolean
}

const isPriceGroupOrPriceChild = (obj: any): boolean => {
    if (!obj) return false;
    if (String(obj?.name || '') === 'priceGroup') return true;
    if (String((obj as any)?.group?.name || '') === 'priceGroup') return true;
    return false;
}

const extractProductsFromZoneForReview = (zone: any): any[] => {
    if (!zone || !isLikelyProductZone(zone)) return [];

    let cards: any[] = [];
    try {
        cards = getZoneChildren(zone);
    } catch {
        cards = [];
    }
    if (!Array.isArray(cards) || !cards.length) return [];

    const orderedCards = cards
        .filter((card: any) => !!card)
        .slice()
        .sort((a: any, b: any) => {
            const ao = Number((a as any)?._zoneOrder);
            const bo = Number((b as any)?._zoneOrder);
            if (Number.isFinite(ao) && Number.isFinite(bo)) return ao - bo;
            if (Number.isFinite(ao)) return -1;
            if (Number.isFinite(bo)) return 1;
            return 0;
        });

    return orderedCards.map((card: any, index: number) => {
        const base = (((card as any)?._productData && typeof (card as any)._productData === 'object')
            ? { ...(card as any)._productData }
            : {}) as any;

        const titleObj = typeof getCardTitleText === 'function' ? getCardTitleText(card) : null;
        const titleText = String((titleObj as any)?.text ?? '').replace(/\r\n?/g, '\n');
        const fallbackName = `Produto ${index + 1}`;
        const rawName = titleText || String(base.name ?? (card as any)?.layerName ?? '');
        const name = /\S/.test(rawName) ? rawName : fallbackName;
        const imageUrlRaw = base.imageUrl ?? base.image ?? (card as any)?.imageUrl ?? null;
        const imageUrl = imageUrlRaw == null ? null : String(imageUrlRaw).trim() || null;

        return {
            id: String(base.id || (card as any)?._customId || `zone-product-${index + 1}`),
            name,
            brand: base.brand ?? '',
            weight: base.weight ?? '',
            price: base.price ?? (card as any)?.price ?? '',
            pricePack: base.pricePack ?? (card as any)?.pricePack ?? '',
            priceUnit: base.priceUnit ?? (card as any)?.priceUnit ?? '',
            priceSpecial: base.priceSpecial ?? (card as any)?.priceSpecial ?? '',
            priceSpecialUnit: base.priceSpecialUnit ?? (card as any)?.priceSpecialUnit ?? '',
            specialCondition: base.specialCondition ?? (card as any)?.specialCondition ?? '',
            priceWholesale: base.priceWholesale ?? (card as any)?.priceWholesale ?? '',
            wholesaleTrigger: base.wholesaleTrigger ?? (card as any)?.wholesaleTrigger ?? null,
            wholesaleTriggerUnit: base.wholesaleTriggerUnit ?? (card as any)?.wholesaleTriggerUnit ?? '',
            packQuantity: base.packQuantity ?? (card as any)?.packQuantity ?? null,
            packUnit: base.packUnit ?? (card as any)?.packUnit ?? '',
            packageLabel: base.packageLabel ?? (card as any)?.packageLabel ?? '',
            price_mode: base.price_mode ?? 'retail',
            limit: base.limit ?? (card as any)?.limit ?? '',
            flavor: base.flavor ?? '',
            imageUrl,
            status: imageUrl ? 'done' : 'pending',
            error: undefined,
            raw: base.raw ?? base
        };
    });
}

const resolveZoneForProductImport = (target: any): any | null => {
    if (!target || !canvas.value) return null;

    if (isLikelyProductZone(target)) return target;

    const resolveByZoneId = (zoneIdRaw: any): any | null => {
        const zoneId = String(zoneIdRaw || '').trim();
        if (!zoneId) return null;
        return findContainmentZoneById(zoneId);
    };

    const directZoneByParent = resolveByZoneId((target as any)?.parentZoneId);
    if (directZoneByParent) return directZoneByParent;
    const directZoneBySlot = resolveByZoneId((target as any)?._zoneSlot?.zoneId);
    if (directZoneBySlot) return directZoneBySlot;

    if (isProductCardContainer(target)) {
        const zoneFromCard = resolveCardParentZone(target, { allowNearest: true });
        if (zoneFromCard) return zoneFromCard;
    }

    let cursor: any = target;
    const visited = new Set<any>();
    while (cursor && !visited.has(cursor)) {
        visited.add(cursor);
        if (isLikelyProductZone(cursor)) return cursor;

        const byParent = resolveByZoneId((cursor as any)?.parentZoneId);
        if (byParent) return byParent;
        const bySlot = resolveByZoneId((cursor as any)?._zoneSlot?.zoneId);
        if (bySlot) return bySlot;

        if (isProductCardContainer(cursor)) {
            const zoneFromCard = resolveCardParentZone(cursor, { allowNearest: true });
            if (zoneFromCard) return zoneFromCard;
        }

        cursor = (cursor as any)?.group;
    }

    const parentCard = findProductCardParentGroup(target);
    if (parentCard) {
        const zoneFromParentCard = resolveCardParentZone(parentCard, { allowNearest: true });
        if (zoneFromParentCard) return zoneFromParentCard;
    }

    return null;
}

const resolveImportTargetZone = (): any | null => {
    if (!canvas.value) return null;

    const zones = canvas.value.getObjects().filter((obj: any) => isLikelyProductZone(obj));
    const byId = new Map<string, any>();
    zones.forEach((zone: any) => {
        const id = String((zone as any)?._customId || '').trim();
        if (id) byId.set(id, zone);
    });

    const resolveById = (rawId: any): any | null => {
        const id = String(rawId || '').trim();
        if (!id) return null;
        return byId.get(id) || null;
    };

    const explicit = targetGridZone.value;
    if (explicit && isLikelyProductZone(explicit)) {
        const refreshed = resolveById((explicit as any)?._customId);
        return refreshed || explicit;
    }
    if (explicit) {
        const byExplicitId = resolveById((explicit as any)?._customId) || resolveById((explicit as any)?.id);
        if (byExplicitId) return byExplicitId;
    }

    const active = canvas.value.getActiveObject?.();
    const fromActive = resolveZoneForProductImport(active);
    if (fromActive) return fromActive;

    const snap: any = selectedObjectRef.value;
    const fromSnapshot =
        resolveById(snap?._customId) ||
        resolveById(snap?.parentZoneId) ||
        resolveById(snap?._zoneSlot?.zoneId);
    if (fromSnapshot) return fromSnapshot;

    if (zones.length === 1) return zones[0];
    return null;
}

const openProductReviewForZone = (zone: any): boolean => {
    if (!zone || !isLikelyProductZone(zone)) return false;

    targetGridZone.value = zone;
    try {
        productImportExistingCount.value = getZoneChildren(zone).length;
    } catch {
        productImportExistingCount.value = 0;
    }
    reviewProducts.value = [];
    showProductReviewModal.value = true;
    return true;
}

const tryOpenProductReviewFromDblClickTarget = (target: any): boolean => {
    if (!target || showProductReviewModal.value) return false;
    if (isPriceGroupOrPriceChild(target)) return false;

    const zone = resolveZoneForProductImport(target);
    if (!zone) return false;
    return openProductReviewForZone(zone);
}

const importZoneLabelTemplateId = computed(() => {
    const z = targetGridZone.value;
    if (z && isLikelyProductZone(z)) {
        const fromStyles = String((z as any)._zoneGlobalStyles?.splashTemplateId || '').trim();
        if (fromStyles) return fromStyles;
        const fromSnapshot = String((z as any)._zoneTemplateSnapshotId || '').trim();
        if (fromSnapshot) return fromSnapshot;
    }
    return '';
})

watch(showProductReviewModal, async (open) => {
    if (!open) return;
    await ensureLabelTemplatesReady();
})

const showAIModal = ref(false)
const aiPrompt = ref('')
const aiReferenceImageDataUrl = ref<string | null>(null)
const aiApplyMode = ref<'replace' | 'newPage'>('replace')
const aiPageType = ref<'RETAIL_OFFER' | 'FREE_DESIGN'>('RETAIL_OFFER')
const aiPageWidth = ref(1080)
const aiPageHeight = ref(1920)
const aiToast = ref<{ type: 'success' | 'error' | 'info'; message: string } | null>(null)
let aiToastTimer: ReturnType<typeof setTimeout> | null = null

const pushAiToast = (type: 'success' | 'error' | 'info', message: string) => {
    aiToast.value = { type, message }
    if (aiToastTimer) clearTimeout(aiToastTimer)
    aiToastTimer = setTimeout(() => {
        aiToast.value = null
        aiToastTimer = null
    }, 3200)
}

const notifyEditorError = (message: string) => {
    pushAiToast('error', String(message || 'Erro inesperado'))
}

const notifyEditorInfo = (message: string) => {
    pushAiToast('info', String(message || 'Aviso'))
}

const openAiGenerationModal = () => {
    aiApplyMode.value = 'replace'
    aiPageType.value = (activePage.value?.type || 'RETAIL_OFFER') as 'RETAIL_OFFER' | 'FREE_DESIGN'
    aiPageWidth.value = Math.max(64, Math.round(Number(activePage.value?.width || 1080)))
    aiPageHeight.value = Math.max(64, Math.round(Number(activePage.value?.height || 1920)))
    aiReferenceImageDataUrl.value = null
    showAIModal.value = true
}
onUnmounted(() => {
    if (aiToastTimer) clearTimeout(aiToastTimer)
})

const showExportModal = ref(false)
const showShareModal = ref(false)
const isExportDownloadInProgress = ref(false)
const exportDownloadStatus = ref('Baixando...')
let exportDownloadFeedbackToken = 0

const startExportDownloadFeedback = (status = 'Baixando...') => {
    exportDownloadFeedbackToken += 1
    exportDownloadStatus.value = status
    isExportDownloadInProgress.value = true
    return exportDownloadFeedbackToken
}

const stopExportDownloadFeedback = async (token: number) => {
    await new Promise(resolve => setTimeout(resolve, 700))
    if (token === exportDownloadFeedbackToken) {
        isExportDownloadInProgress.value = false
    }
}

const showPresentationModal = ref(false)
const presentationImage = ref('')
const presentationHotspots = ref<any[]>([])

const startPresentation = async (pageIndex = -1) => {
    if (!canvas.value) return;
    
    // Determine page to show (default to current active)
    const targetIndex = pageIndex >= 0 ? pageIndex : project.activePageIndex;
    
    // If target is different, we need to load it temporarily to render?
    // Optimization: We assume the user starts from CURRENT page for now. 
    // If navigating, we might need to load JSON data in background or switch context.
    
    // For this "Lite" prototype, we will handle navigation by ACTUALLY switching the active page in the background
    // but keeping the modal open.
    
    if (targetIndex !== project.activePageIndex) {
        // Switch page logic (re-using useProject)
        // This triggers the watcher, which re-renders canvas.
        // We need to wait for render, then grab image.
        project.activePageIndex = targetIndex;
        // Wait for Vue watch and Canvas render
        await new Promise(r => setTimeout(r, 200)); 
    }

    canvas.value.discardActiveObject();
    canvas.value.requestRenderAll();

    // 1. Sanitize clipPaths before generating image
    sanitizeAllClipPaths();

    // 2. Generate Image
    try {
        presentationImage.value = canvas.value.toDataURL({
            format: 'png',
            multiplier: 2
        });
    } catch (err) {
        console.error('[Prototype] Erro ao gerar imagem:', err);
        // Nuclear option: clear all clipPaths
        removeAllClipPaths();
        try {
            canvas.value.requestRenderAll();
            await new Promise(resolve => setTimeout(resolve, 10));
            presentationImage.value = canvas.value.toDataURL({
                format: 'png',
                multiplier: 2
            });
        } catch (err2) {
            console.error('[Prototype] Falha definitiva ao gerar imagem:', err2);
            presentationImage.value = '';
        }
    }
    
    // 2. Generate Hotspots
    // We need to map object coordinates to the image percentages to be responsive in modal
    const vWidth = canvas.value.getWidth();
    const vHeight = canvas.value.getHeight();
    const objects = canvas.value.getObjects();
    
    presentationHotspots.value = objects
        .filter((o: any) => o.interactionDestination !== undefined && o.interactionDestination !== '')
        .map((o: any) => {
            const boundingRect = o.getBoundingRect();
            return {
                top: (boundingRect.top / vHeight) * 100 + '%',
                left: (boundingRect.left / vWidth) * 100 + '%',
                width: (boundingRect.width / vWidth) * 100 + '%',
                height: (boundingRect.height / vHeight) * 100 + '%',
                target: o.interactionDestination
            };
        });
    
    showPresentationModal.value = true;
}

const handleHotspotClick = (targetIndex: any) => {
    // Navigate to target page
    startPresentation(Number(targetIndex));
}

const HIGH_RES_EXPORT_SCALE = 6
const HIGH_RES_EXPORT_QUALITY = 1
const EXPORT_COLOR_SATURATION = 1.12
const EXPORT_COLOR_CONTRAST = 1.08
const EXPORT_COLOR_BRIGHTNESS = 1.02

const exportSettings = ref({
    format: 'png',
    scale: HIGH_RES_EXPORT_SCALE,
    quality: HIGH_RES_EXPORT_QUALITY,
    exportScope: 'selected-frame', // 'selected-object' | 'selected-frame' | 'all-frames'
    selectedFrameId: '' // ID of the frame to export
})

const getFrameDisplayNameForExport = (frame: any, index: number) => {
    const layerName = String(frame?.layerName || '').trim();
    const runtimeName = String(frame?.name || '').trim();
    const isGenericLayerName =
        !layerName ||
        /^FRAMER(?:\s+\d+)?$/i.test(layerName) ||
        /^FRAME(?:\s+\d+)?$/i.test(layerName);

    if (!isGenericLayerName) return layerName;
    if (runtimeName) return runtimeName;
    if (layerName) return layerName;
    return `Frame ${index + 1}`;
};

const availableFramesForExport = computed(() => {
    const _activePage = Number(project.activePageIndex || 0);
    const _objectsSnapshot = canvasObjects.value;
    void _activePage;

    if (!canvas.value) return [];

    // Depend explicitly on reactive object snapshots. Fabric internals are non-reactive.
    const sourceObjects = Array.isArray(_objectsSnapshot) && _objectsSnapshot.length > 0
        ? _objectsSnapshot
        : (canvas.value.getObjects?.() || []);
    void sourceObjects.length;

    const runtimeFrameById = new Map<string, any>();
    getAllFrames().forEach((frame: any) => {
        const frameId = String(frame?._customId || frame?.id || '').trim();
        if (frameId) runtimeFrameById.set(frameId, frame);
    });

    const normalized: any[] = [];
    sourceObjects.forEach((obj: any) => {
        const frame = normalizeFrameRuntimeProps(obj);
        if (frame) normalized.push(frame);
    });
    // Fallback to runtime query if snapshot is temporarily stale.
    if (normalized.length === 0) {
        getAllFrames().forEach((f: any) => normalized.push(f));
    }

    const byId = new Map<string, { id: string; name: string }>();
    normalized.forEach((f: any, idx: number) => {
        const id = String(f?._customId || f?.id || '').trim() || `frame-${idx + 1}`;
        if (!f?._customId) f._customId = id;
        const runtimeFrame = runtimeFrameById.get(id) || f;
        const name = getFrameDisplayNameForExport(runtimeFrame, idx);
        if (!byId.has(id)) byId.set(id, { id, name });
    });

    return Array.from(byId.values());
})

const availableFramesForImport = computed(() => {
    const frames = availableFramesForExport.value || []
    return frames.map((frame: any, index: number) => {
        const id = String(frame?.id || '').trim() || `frame-${index + 1}`
        const name = String(frame?.name || '').trim() || `Frame ${index + 1}`
        const runtime = getFrameById(id)
        const bounds = runtime ? getFrameBounds(runtime) : null
        return {
            id,
            name,
            left: bounds?.left,
            top: bounds?.top
        }
    })
})

const selectedFrameForExport = computed(() => {
    if (!exportSettings.value.selectedFrameId || !canvas.value) return null
    return getFrameById(exportSettings.value.selectedFrameId)
})

// Design System State
const colorStyles = ref<{id: string, name: string, value: string}[]>([
    { id: 'primary', name: 'Primary Red', value: '#FF0000' },
    { id: 'secondary', name: 'Dark Gray', value: '#333333' },
    { id: 'accent', name: 'Blue Accent', value: '#3B82F6' }
])

const addColorStyle = (color: string) => {
    colorStyles.value.push({
        id: Math.random().toString(36).substr(2, 9),
        name: 'New Color',
        value: color
    });
}

const applyColorStyle = (styleId: string) => {
    if (!canvas.value) return;
    const active = canvas.value.getActiveObject();
    const style = colorStyles.value.find(s => s.id === styleId);
    if (active && style) {
        active.set('fill', style.value);
        active.set('styleId', styleId); // Save ref for future updates
        canvas.value.requestRenderAll();
        saveCurrentState();
        // Update selection Ref
        selectedObjectRef.value = snapshotForPropertiesPanel(active);
    }
}

// History System
const historyStack = ref<string[]>([]);
const historyIndex = ref(-1);
const isHistoryProcessing = ref(false); // Flag to prevent loop
let isZoneCascadeDelete = false;
let isApplyingZoneUpdate = false; // Flag to prevent double state save when updating product zones

const makeCanvasObjectId = () => Math.random().toString(36).substr(2, 9);
const TRANSIENT_CONTROL_NAMES = new Set(['path_node', 'bezier_handle', 'control_point', 'handle_line']);

const isControlLikeObject = (obj: any) => {
    if (!obj || typeof obj !== 'object') return false;
    const name = String(obj.name || '');
    const id = String(obj.id || '');
    if (TRANSIENT_CONTROL_NAMES.has(name)) return true;
    if (id === 'guide-vertical' || id === 'guide-horizontal') return true;
    if (obj.data && (obj.data.parentPath || obj.data.parentObj)) return true;
    return false;
};

const ensureObjectPersistentId = (obj: any) => {
    if (!obj || typeof obj !== 'object') return;
    if (obj._customId) return;
    if (isControlLikeObject(obj)) return;
    // User guides are persisted by `id` (guide-user-*) and should never become layers (_customId).
    try { if (isUserGuideObject(obj)) return; } catch {}
    obj._customId = makeCanvasObjectId();
};

const isTransientCanvasObject = (obj: any) => {
    if (!obj || typeof obj !== 'object') return false;
    const name = String(obj.name || '');
    const id = String(obj.id || '');
    const hasCustomId = typeof obj._customId === 'string' && obj._customId.trim().length > 0;

    if (hasCustomId) return false;
    if (isControlLikeObject(obj)) return true;
    if (obj.type === 'circle' && obj.radius && obj.radius <= 10 && !hasCustomId && !!obj.excludeFromExport) return true;
    if (obj.type === 'line' && !hasCustomId && !!obj.excludeFromExport) return true;
    if (obj.type === 'path' && !hasCustomId && !obj.isVectorPath && !!obj.excludeFromExport) return true;

    if (obj.excludeFromExport === true) {
        const isPersistentContent =
            !!obj.isFrame ||
            !!obj.isSmartObject ||
            !!obj.isProductCard ||
            !!obj.isGridZone ||
            !!obj.isProductZone ||
            !!obj.parentZoneId ||
            name === 'gridZone' ||
            name === 'productZoneContainer' ||
            name === 'priceGroup' ||
            name.startsWith('product-card') ||
            id === 'artboard-bg';
        if (isPersistentContent) return false;
        // Avoid removing regular user content by mistake. For non-persistent objects,
        // only treat as transient when they look like control/guide objects.
        return isControlLikeObject(obj);
    }

    return false;
};

const ensurePersistentContentFlags = (obj: any) => {
    if (!obj || typeof obj !== 'object') return;
    ensureObjectPersistentId(obj);
    const name = String(obj.name || '');
    const isPersistentContent =
        !!obj.isFrame ||
        !!obj.isSmartObject ||
        !!obj.isProductCard ||
        !!obj.isGridZone ||
        !!obj.isProductZone ||
        !!obj.parentZoneId ||
        name === 'gridZone' ||
        name === 'productZoneContainer' ||
        name.startsWith('product-card');
    if (isPersistentContent && obj.excludeFromExport) {
        obj.excludeFromExport = false;
    }
};

const showDeletePageModal = ref(false)

const handleDeleteCurrentPage = () => {
    if (project.pages.length <= 1) return;
    showDeletePageModal.value = true;
}

const confirmDeletePage = () => {
    deletePage(project.activePageIndex);
    showDeletePageModal.value = false;
}

let fabric: any = null;
const isFabricReady = ref(false)

// Mock Data for Smart Grid (Fallback) - Empty, real data comes from API
const MOCK_PRODUCTS: any[] = [];



// --- Smart Grid Implementation ---
// Legacy renderer (productZoneState.products -> Fabric objects) conflicts with the
// current Product Zone engine (group + recalculateZoneLayout). Keep disabled.
const LEGACY_PRODUCT_ZONE_RENDERER_ENABLED = false;

const initProductZone = () => {
    if (!canvas.value) return;
    if (!LEGACY_PRODUCT_ZONE_RENDERER_ENABLED) return;

    // watch for zone changes
    watch(() => productZoneState.productZone.value, (newZone) => {
        renderProductZone(newZone);
    }, { deep: true });

    // watch for products changes
    watch(() => productZoneState.products.value, (newProducts) => {
        renderProducts(newProducts);
    }, { deep: true });
}

// Map to track rendered product objects to avoid full re-renders
const productObjectMap = new Map<string | number, any>();
const zoneObjectRef = shallowRef<any>(null);

const renderProductZone = (zone: any) => {
    if (!canvas.value) return;

    let zoneRect = zoneObjectRef.value;

    // Only create zone if user explicitly enabled it
    if (!zone.enabled) {
        // Remove existing zone if disabled
        if (zoneRect) {
            canvas.value.remove(zoneRect);
            zoneObjectRef.value = null;
        }
        return;
    }

    if (!zoneRect) {
        // Create Zone Container (only when enabled)
        zoneRect = new fabric.Rect({
            left: zone.x,
            top: zone.y,
            width: zone.width,
            height: zone.height,
            fill: 'rgba(13, 153, 255, 0.05)',
            stroke: '#0d99ff',
            strokeWidth: 1,
            strokeDashArray: [5, 5],
            selectable: true,
            hasControls: true,
            lockRotation: true,
            id: 'product_zone_container',
            isZone: true, // Custom flag
            isProductZone: true // Flag to identify as product zone
        });

        // Add Event Listeners for "Smart" behavior
        zoneRect.on('moving', (e: any) => {
            const dx = e.transform.target.left - zone.x;
            const dy = e.transform.target.top - zone.y;
            
            // Move internal logic (update state)
            productZoneState.updateZone({ x: e.transform.target.left, y: e.transform.target.top });
            
            // Move all products visually to stay in sync during drag
            // (Re-render will fix exact positions, but this mimics realtime)
            productZoneState.products.value.forEach(p => {
                const pObj = productObjectMap.get(p.id);
                if (pObj) {
                    pObj.set({
                        left: pObj.left + dx,
                        top: pObj.top + dy
                    });
                    pObj.setCoords();
                }
            });
            // Also update product state coordinates
            productZoneState.products.value.forEach(p => {
                 productZoneState.updateProduct(p.id, {
                     x: p.x + dx, 
                     y: p.y + dy
                 });
            });
        });

        zoneRect.on('scaling', (e: any) => {
             // "Smart Container" resizing
             const newWidth = zoneRect.getScaledWidth();
             const newHeight = zoneRect.getScaledHeight();

             // Reset Scale to 1 to avoid distortion
             zoneRect.set({
                 width: newWidth,
                 height: newHeight,
                 scaleX: 1,
                 scaleY: 1
             });

             // Update State -> Triggers Recalculate
             productZoneState.updateZone({ width: newWidth, height: newHeight });
             productZoneState.recalculateLayout();
        });

        canvas.value.add(zoneRect);
        // Move to back by manipulating _objects array (Fabric.js v7 compatible)
        const objects = canvas.value._objects;
        if (Array.isArray(objects)) {
            const index = objects.indexOf(zoneRect);
            if (index > -1) {
                objects.splice(index, 1);
                objects.unshift(zoneRect);
            }
        }
        zoneObjectRef.value = zoneRect;
    } else {
        // Update existing zone visual
        zoneRect.set({
            left: zone.x,
            top: zone.y,
            width: zone.width,
            height: zone.height
        });
        zoneRect.setCoords();
    }
    
    canvas.value.requestRenderAll();
}

const renderProducts = (products: any[]) => {
    if (!canvas.value) return;

    // 1. Identify removed products
    const currentIds = new Set(products.map(p => p.id));
    for (const [id, obj] of productObjectMap.entries()) {
        if (!currentIds.has(id)) {
            canvas.value.remove(obj);
            productObjectMap.delete(id);
        }
    }

    // 2. Add/Update products
    products.forEach(product => {
        let pObj = productObjectMap.get(product.id);

        if (!pObj) {
            // CREATE NEW PRODUCT GROUP
            // Calculate optimal image size
            const optimalSize = productZoneState.getOptimalImageSize(product);

            const bg = new fabric.Rect({
                width: product.width,
                height: product.height,
                fill: product.backgroundColor || '#ffffff',
                rx: product.borderRadius || 8,
                ry: product.borderRadius || 8,
                originX: 'center',
                originY: 'center',
                shadow: { color: 'rgba(0,0,0,0.1)', blur: 4, offsetX: 0, offsetY: 2 }
            });

            const text = new fabric.Textbox(product.name || 'Nome', {
                fontSize: Math.min(18, product.width * 0.1),
                fontFamily: 'Inter',
                fontWeight: 600,
                fill: '#333333',
                originX: 'center',
                originY: 'top',
                top: -product.height/2 + 10,
                width: product.width - 20,
                textAlign: 'center',
                splitByGrapheme: true
            });

            // Image Area (Placeholder)
            const imgPlaceholder = new fabric.Rect({
                width: optimalSize.maxWidth,
                height: optimalSize.maxHeight,
                fill: '#f5f5f5',
                stroke: '#e5e5e5',
                strokeWidth: 1,
                originX: 'center',
                originY: 'center',
                top: -10 
            });

            // Usar getAvailablePrices para determinar o preço principal
            const availablePrices = getAvailablePrices(product);
            const priceVal = availablePrices.mainPrice !== undefined ? availablePrices.mainPrice : 0;
            const priceStr = typeof priceVal === 'number'
                ? priceVal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })
                : priceVal.toString();

            const price = new fabric.Text(`R$ ${priceStr}`, {
                fontSize: Math.min(28, product.width * 0.15),
                fontWeight: '800',
                fill: '#dc2626',
                originX: 'center',
                originY: 'bottom',
                top: product.height/2 - 15
            });

	            pObj = new fabric.Group([bg, text, imgPlaceholder, price], {
	                left: product.x,
	                top: product.y,
	                width: product.width,
	                height: product.height,
	                selectable: true,
	                id: product.id,
	                isProduct: true,
	                // Keep parity with product-card behavior: allow inner target selection.
	                subTargetCheck: true,
	                interactive: true
	            });

            pObj.on('moving', (e: any) => {
                 // Update product position in state
                 // Note: If restricted to grid, we arguably shouldn't allow moving individual items freely unless 'freeMode'
                 // For now, let's sync state
                 productZoneState.updateProduct(product.id, {
                     x: pObj.left,
                     y: pObj.top
                 });
            });

            canvas.value.add(pObj);
            productObjectMap.set(product.id, pObj);
        } else {
            // UPDATE EXISTING
            // We animate the move for smoothness if desired, or set directly
            pObj.set({
                left: product.x,
                top: product.y,
                width: product.width,
                height: product.height
            });
            
            // Deep update of internals
            const items = pObj.getObjects();
            const optimalSize = productZoneState.getOptimalImageSize(product);
            
            if(items[0]) { // BG
                items[0].set({ width: product.width, height: product.height, fill: product.backgroundColor || '#ffffff' });
            }
            if(items[1]) { // Textbox
                items[1].set({ 
                    text: product.name, 
                    top: -product.height/2 + 10,
                    width: product.width - 20,
                    fontSize: Math.min(18, product.width * 0.1)
                });
            }
            if(items[2]) { // Image Placeholder
                items[2].set({
                    width: optimalSize.maxWidth,
                    height: optimalSize.maxHeight,
                    top: -10
                });
            }
            if(items[3]) { // Price
                // Usar getAvailablePrices para determinar o preço principal
                const availablePrices = getAvailablePrices(product);
                const priceVal = availablePrices.mainPrice !== undefined ? availablePrices.mainPrice : 0;
                const priceStr = typeof priceVal === 'number'
                   ? priceVal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })
                   : priceVal.toString();
                items[3].set({
                    text: `R$ ${priceStr}`,
                    fontSize: Math.min(28, product.width * 0.15),
                    top: product.height/2 - 15
                });
            }

            pObj.setCoords();
        }
    });

    canvas.value.requestRenderAll();
}

// --- Watch for Page Switching ---
// IMPORTANT: When the user changes pages (or creates a new one), there is a tiny window where
// the reactive `activePage` already changed but the Fabric canvas still shows the previous page.
// Any delayed `saveCurrentState()` fired in this window can accidentally persist the previous
// canvas into the new page, making pages "share" content. We mark loading synchronously to
// block user saves until the loader pipeline finishes.
watch(
    () => project.activePageIndex,
    () => {
        // Only relevant client-side with a live canvas.
        if (typeof window === 'undefined') return
        if (!canvas.value || !isFabricReady.value) return
        // Match the loader preconditions; avoid getting stuck in "loading" during initial project fetch.
        if (!isProjectLoaded.value && project.id && !String(project.id).startsWith('proj_')) return
        if (isCanvasDestroyed.value) return
        isDesignLoading.value = true
    },
    { flush: 'sync' }
)
watch([activePage, () => canvas.value, isProjectLoaded, isFabricReady, pageReloadToken], async ([newPage, canvasInstance, loaded, _fabricReady, reloadToken], prev) => {
    const oldPage = (prev?.[0] as any) || null
    if (!newPage) return;
    if (!canvasInstance || !fabric || !isFabricReady.value) return;
    if (!loaded && project.id && !project.id.startsWith('proj_')) return;

    const nextPageId = String((newPage as any)?.id || '').trim()
    const projectIdForLoad = String(project.id || '').trim()
    const nextPageLoadKey = `${projectIdForLoad}:${nextPageId}`
    const prevReloadToken = Number((prev as any)?.[4] ?? 0)
    const forceReload = Number(reloadToken ?? 0) !== prevReloadToken
 
    if (nextPageId && lastLoadedPageKey === nextPageLoadKey && !forceReload) {
        // If we already loaded this page and it has real objects, don't reload just because canvas/fabric became ready.
        try {
            const hasRealObjects = (canvas.value?.getObjects?.() || []).some((o: any) => !isTransientCanvasObject(o) && o?.id !== 'artboard-bg')
            if (hasRealObjects) return
        } catch {
            // ignore
        }
    }

    const loadSessionId = ++activePageLoadSessionId;
    const isStaleLoad = () => loadSessionId !== activePageLoadSessionId || isCanvasDestroyed.value;

    const savedVpt = newPage.canvasData ? getSavedViewportTransform(newPage.canvasData) : null;
    let loadedOk = false
    isDesignLoading.value = true
    designLoadExpectedCounts.value = newPage.canvasData ? countCanvasJsonObjectsAndImages(newPage.canvasData) : { objects: 0, images: 0 }
    designLoadActualCounts.value = null
    let degradedFailedCount: number | null = null

    try {
        // 1. Snapshot logic...
        
        // 2. Clear & Resize Canvas
        isHistoryProcessing.value = true;
        // Prevent ProductZone "global styles" from leaking across pages/projects.
        // `useProductZone()` is a singleton composable, so without an explicit reset the next
        // page can inherit the last selected zone/card styles when creating a fresh zone/cards.
        try {
            productZoneState.clearSelection();
            productZoneState.products.value = [];
            productZoneState.splashes.value = [];
            productZoneState.productZone.value = { ...DEFAULT_PRODUCT_ZONE };
            productZoneState.globalStyles.value = { ...DEFAULT_GLOBAL_STYLES };
        } catch {
            // ignore
        }
        clearCanvasForPageSwitch(canvas.value)
        // THE WORKSPACE BACKGROUND IS DYNAMIC
        if (canvas.value) {
            canvas.value.backgroundColor = pageSettings.value.backgroundColor;
        } 
        
        // Infinite canvas: the Fabric canvas must match the visible wrapper size,
        // NOT the page/frame dimensions (those are represented by Frame objects).
        const ww = wrapperEl.value?.clientWidth || canvas.value.getWidth?.() || 0;
        const wh = wrapperEl.value?.clientHeight || canvas.value.getHeight?.() || 0;
        if (ww && wh) {
            canvas.value.setDimensions({ width: ww, height: wh });
        }

		        // 3. Load Data
		        try {
		            if (newPage.canvasData) {
	            // CRITICAL: Ensure canvas is fully initialized before loading
	            if (!canvas.value || !canvas.value.getContext) {
	                console.warn('⚠️ Canvas não inicializado, aguardando...');
	                await new Promise(resolve => setTimeout(resolve, 100));
	                if (!canvas.value || !canvas.value.getContext) {
	                    console.error('❌ Canvas ainda não inicializado após espera');
	                    isHistoryProcessing.value = false;
	                    return;
	                }
	            }
	            
	            // Restore label templates stored alongside the Fabric JSON (persisted per page).
	            hydrateLabelTemplatesFromProjectJson(newPage.canvasData);

                    // Normalize image URLs to same-origin proxy (Wasabi/Contabo) before load.
                    let canvasDataToLoad = prepareCanvasDataForLoad(newPage.canvasData);

	            // Track whether we loaded successfully and whether we had to degrade (missing images)
	            let didLoadNewPage = false;
	            let degradedNewPage = false;
	            try {
	                try {
	                    await loadFromJSONWithImageProgress(canvasDataToLoad, loadSessionId);
	                    didLoadNewPage = true;
	                } catch (imageLoadErr: any) {
	                    const errorStr = imageLoadErr?.message || imageLoadErr?.toString?.() || '';
	                    const isImageError =
	                        errorStr.includes('fabric: Error loading') ||
	                        errorStr.includes('Error loading') ||
	                        errorStr.includes('contabostorage') ||
	                        errorStr.includes('500');

	                    if (!isImageError) throw imageLoadErr;

	                    console.warn('⚠️ Erro ao carregar imagem durante loadFromJSON:', imageLoadErr);
	                    console.warn('   Tentando gerar novas URLs presignadas para imagens da Contabo...');

		                    // IMPORTANT: Use a clone of already-processed canvasDataToLoad (avoid re-running heavy prepare).
		                    const safeCanvasData = cloneCanvasDataForLoad(canvasDataToLoad);
		                    if (safeCanvasData?.objects && Array.isArray(safeCanvasData.objects)) {
		                        const refreshStats = await refreshContaboUrlsInCanvasData(safeCanvasData, { concurrency: 6 });
		                        degradedNewPage = refreshStats.failed > 0;
                                degradedFailedCount = Number(refreshStats.failed || 0) || null
		                        // Try loading again with updated URLs (or placeholders for failed entries)
		                        await loadFromJSONWithImageProgress(safeCanvasData, loadSessionId);
		                        didLoadNewPage = true;
		                    } else {
		                        // No objects array, use pre-processed data
		                        await loadFromJSONWithImageProgress(canvasDataToLoad, loadSessionId);
	                        didLoadNewPage = true;
	                    }
	                }
	            } catch (loadErr) {
	                console.error('❌ Erro ao carregar JSON no canvas:', loadErr);
	                // Try to clear and retry once - but only if canvas is fully ready
	                if (canvas.value) {
	                    try {
	                        // Verificar se o contexto ainda existe antes de tentar clear
	                        const ctx = canvas.value.getContext();
	                        if (ctx && typeof ctx.clearRect === 'function') {
	                            canvas.value.clear();
	                            await new Promise(resolve => setTimeout(resolve, 50));
	                            await loadFromJSONWithImageProgress(canvasDataToLoad, loadSessionId);
	                        } else {
	                            console.warn('⚠️ Contexto do canvas não está disponível, pulando clear()');
	                            // Tentar carregar diretamente sem clear
	                            await loadFromJSONWithImageProgress(canvasDataToLoad, loadSessionId);
	                        }
                    } catch (retryErr) {
                        console.error('❌ Erro ao recarregar após clear:', retryErr);
                        // Penúltima tentativa: substituir imagens Contabo por placeholder (mantém layout)
                        try {
                            const dataWithPlaceholders = replaceContaboImagesWithPlaceholder(canvasDataToLoad);
                            await loadFromJSONWithImageProgress(dataWithPlaceholders, loadSessionId);
                            didLoadNewPage = true;
                            degradedNewPage = true;
                            degradedFailedCount = null
                            console.log('✅ loadFromJSON concluído com placeholder para imagens que falharam');
                        } catch (placeholderErr) {
                            // Last attempt: load without ANY images (never throw due to broken image)
                            try {
                                const safeData = JSON.parse(JSON.stringify(canvasDataToLoad));
                                removeImageObjectsDeep(safeData);
                                await loadFromJSONWithImageProgress(safeData, loadSessionId);
                                didLoadNewPage = true;
                                degradedNewPage = true;
                                degradedFailedCount = null
                                console.log('✅ loadFromJSON concluído sem imagens (fallback final)');
                            } catch (finalErr) {
                                console.error('❌ Erro final ao carregar:', finalErr);
                                throw finalErr;
                            }
                        }
                    }
                } else {
                    throw loadErr;
                }
            }
		                    // If we couldn't load, do NOT continue (prevents wiping saved data with empty state).
		                    if (!didLoadNewPage) {
			                isHistoryProcessing.value = false;
			                return;
			            }
                    loadedOk = true
                    storageDegraded.value = degradedNewPage
                    storageDegradedFailedCount.value = degradedFailedCount
                    storageDegradedHint.value = degradedNewPage
                        ? (degradedFailedCount ? `Algumas imagens nao carregaram (${degradedFailedCount}).` : 'Algumas imagens nao carregaram.')
                        : ''
                    if (isStaleLoad()) {
                        isHistoryProcessing.value = false;
                        return;
                    }
		            
		            // Remove old frame label text objects (if any were saved)
	            const objects = canvas.value.getObjects();
	            objects.forEach((obj: any) => {
	                if (obj.isFrameLabel || (obj.type === 'text' && obj.text && obj.text.includes('@') && obj.text.includes('dpi'))) {
	                    canvas.value.remove(obj);
	                }
	            });
	            
            // CRITICAL: Remove any duplicate objects BEFORE rehydration
            const allObjsBefore = canvas.value.getObjects();
            const seenIds = new Set<string>();
            const duplicates: any[] = [];
            allObjsBefore.forEach((obj: any) => {
                if (isTransientCanvasObject(obj)) return;
                const id = obj._customId || obj.id;
                if (id && seenIds.has(id)) {
                    if (obj._customId) {
                        const old = obj._customId;
                        obj._customId = makeCanvasObjectId();
                        seenIds.add(obj._customId);
                        console.warn(`⚠️ _customId duplicado detectado após load. Regenerado ${old} -> ${obj._customId}`);
                    } else {
                        duplicates.push(obj);
                    }
                } else if (id) {
                    seenIds.add(id);
                }
            });
            // CRITICAL: Remove duplicates preserving order
            // Remove from end to preserve order of remaining objects
            if (duplicates.length > 0) {
                console.warn(`⚠️ Removendo ${duplicates.length} objeto(s) duplicado(s) após loadFromJSON`);
                // Remove duplicates without affecting order
                duplicates.forEach(dup => {
                    try {
                        canvas.value.remove(dup);
                    } catch (e) {
                        // Ignore errors
                    }
                });
            }
            
            // CRITICAL: Remove any non-frame rectangles that might have been incorrectly created
            // IMPORTANT: Preserve order by removing from end
            const allObjsAfterDedup = canvas.value.getObjects();
            const rectsToRemove: any[] = [];
            // Iterate in reverse to mark for removal from end
            for (let i = allObjsAfterDedup.length - 1; i >= 0; i--) {
                const obj = allObjsAfterDedup[i];
                // If it's a rect but NOT a frame, and doesn't have a specific purpose (like artboard-bg), remove it
                if (obj.type === 'rect' && 
                    !obj.isFrame && 
                    !obj.clipContent && 
                    obj.id !== 'artboard-bg' &&
                    obj.selectable !== false && // artboard is not selectable
                    !obj.excludeFromExport) {
                    // Check if this looks like a duplicate frame (has similar properties but missing isFrame)
                    const hasFrameLikeProps = obj.stroke && String(obj.stroke).toLowerCase() === '#0d99ff';
                    if (hasFrameLikeProps) {
                        // Mark for removal (remove from end to preserve order)
                        rectsToRemove.push(obj);
                    }
                }
            }
            // Remove from end to preserve order
            rectsToRemove.forEach((obj: any) => {
                try {
                    canvas.value.remove(obj);
                } catch (e) {
                    // Ignore errors
                }
            });
            
            // CRITICAL: Clear deserialized frame clipPaths before rehydrate.
            // Keep object masks (`objectMaskEnabled`) intact.
            const objsBeforeRehydrateNew = canvas.value.getObjects();
            objsBeforeRehydrateNew.forEach((obj: any) => {
                const hasObjectMask = !!obj?.objectMaskEnabled;
                if (obj.clipPath && !obj.isFrame && !hasObjectMask) {
                    obj.clipPath = null;
                    delete obj._frameClipOwner;
                }
            });
            
            // CRITICAL: Rehydrate zones AND frames to restore isFrame flags and normalize names
            rehydrateCanvasZones();
            
            // Ensure all frames have layerName set to "FRAMER" if missing (for LayersPanel display)
            const allObjs = canvas.value.getObjects();
            allObjs.forEach((obj: any) => {
                if (obj?.isFrame && !obj.layerName) {
                    obj.layerName = 'FRAMER';
                    console.log(`🔄 Frame sem layerName, definido como "FRAMER":`, obj.name);
                }
            });
            
            // CRITICAL: Remove any artboard-bg that might have been incorrectly created
            let artboard = canvas.value.getObjects().find((o: any) => o.id === 'artboard-bg');
            if (artboard && (artboard.isFrame || artboard.clipContent || artboard.selectable)) {
                console.warn('⚠️ Removendo artboard-bg incorreto (era um Frame)');
                canvas.value.remove(artboard);
                artboard = null; // Clear reference after removal
            }
            
            // Force update canvasObjects to reflect restored state
            refreshCanvasObjects();
            
            // Try to sync settings from loaded artboard (re-find after potential removal)
            if (!artboard) {
                artboard = canvas.value.getObjects().find((o: any) => o.id === 'artboard-bg');
            }
            if (artboard && artboard.fill) {
                pageSettings.value.backgroundColor = artboard.fill as string;
            }
            
            // Restore IDs if lost - BUT exclude frames and selectable objects
            canvas.value.getObjects().forEach((o: any) => {
                // CRITICAL: Don't mark frames as artboard! Frames are selectable and have isFrame flag
                if (o.type === 'rect' && !o.selectable && !o.id && !o.isFrame && !o.clipContent) {
                    o.set('id', 'artboard-bg');
                }
            });

            // CRITICAL: Clear Fabric's char-width cache and recalculate text
            // dimensions after loadFromJSON. The JSON may carry stale width/height
            // that was measured with a fallback font. Even if fonts loaded later,
            // Fabric caches per-char widths keyed by font name — those stale entries
            // persist until explicitly cleared.
            try {
                const fabricCache = (fabric as any)?.cache;
                if (fabricCache && typeof fabricCache.clearFontCache === 'function') {
                    fabricCache.clearFontCache();
                }
            } catch (_e) { /* ignore */ }

            const recalcAllText = (obj: any) => {
                if (!obj) return;
                const t = String(obj.type || '').toLowerCase();
                if (t === 'i-text' || t === 'textbox' || t === 'text') {
                    if (typeof obj.initDimensions === 'function') obj.initDimensions();
                    obj.set('dirty', true);
                    if (typeof obj.setCoords === 'function') obj.setCoords();
                }
                if (typeof obj.getObjects === 'function') {
                    obj.getObjects().forEach(recalcAllText);
                    obj.set('dirty', true);
                }
            };
            canvas.value.getObjects().forEach(recalcAllText);
            // Same issue as webfont load: JSON could have been measured with fallback fonts.
            // Re-fit manual label templates so cards match the mini editor geometry.
            refitManualLabelTemplatesAfterFontMetrics(canvas.value);

	            safeRequestRenderAll();
	            } else {
	                // New Blank Page starts with default settings
	                // canvas.value.backgroundColor = '#ffffff'; // NO! Workspace is dark. Artboard is white.
	                // Explicitly do nothing here, let updateArtboard() create the white rect.
                loadedOk = true
                storageDegraded.value = false
                storageDegradedFailedCount.value = null
                storageDegradedHint.value = ''
	        }
	    } catch (err) {
	        console.error("Error loading page data:", err);
            storageDegraded.value = true
            storageDegradedFailedCount.value = null
            storageDegradedHint.value = 'Falha ao carregar imagens do storage.'
	    } finally {
	        isHistoryProcessing.value = false;
	    }
    
    // 4. Reset History for this page context
    historyStack.value = [];
    historyIndex.value = -1;

    // 5. Restore viewport (last pan/zoom) or fallback to zoom-to-fit.
    if (savedVpt) {
        applyViewportTransform(savedVpt);
        // Persist immediately so a reload doesn't overwrite viewport with defaults.
        if (oldPage) {
            saveCurrentState({
                reason: 'page-switch-viewport',
                source: 'system',
                skipIfUnchanged: true,
                expectedPageId: String(newPage.id || '')
            });
        }
    } else {
        setTimeout(() => {
            if (isStaleLoad()) return;
            zoomToFit();
            if (oldPage) {
                saveCurrentState({
                    reason: 'page-switch-viewport',
                    source: 'system',
                    skipIfUnchanged: true,
                    expectedPageId: String(newPage.id || '')
                });
            }
        }, 50);
    }

    // 6. Refresh Reactivity and ensure no duplicates
    const objs = canvas.value.getObjects();
    const seenCustomIds = new Set<string>();
    const seenIds = new Set<string>();
    const finalObjs: any[] = [];
    
    // CRITICAL: Preserve order - iterate in original order and only remove control objects
    // Don't reorder or sort - maintain exact order from canvas
    const objsInOrder = [...objs]; // Preserve original order
    const toRemove: any[] = [];
    
    objsInOrder.forEach((o: any) => {
        if (isTransientCanvasObject(o)) {
            // Mark for removal (remove later to preserve order)
            toRemove.push(o);
            return;
        }

        ensurePersistentContentFlags(o);

        // Ensure _customId exists for real objects
        if (!o._customId) o._customId = makeCanvasObjectId();
        
        // Check for duplicates by _customId or id
        const customId = o._customId;
        const id = o.id;
        
        if (customId && seenCustomIds.has(customId)) {
            const old = customId;
            o._customId = makeCanvasObjectId();
            console.warn(`⚠️ _customId duplicado no load. Regenerado ${old} -> ${o._customId}`);
        }
        if (id && id !== 'artboard-bg' && seenIds.has(id) && !String(o._customId || '').trim()) {
            console.warn(`⚠️ Removendo objeto duplicado por id: ${id}`, o);
            toRemove.push(o);
            return;
        }
        
        if (o._customId) seenCustomIds.add(o._customId);
        if (id) seenIds.add(id);
        finalObjs.push(o);
    });
    
    // Remove marked objects (from end to preserve order)
    toRemove.forEach((obj: any) => {
        try {
            canvas.value.remove(obj);
        } catch (e) {
            // Ignore errors
        }
    });
    
    // CRITICAL: Update canvasObjects with deduplicated list (order preserved from original)
    // Don't reorder - maintain exact order from canvas.getObjects()
    refreshCanvasObjects({ source: finalObjs, immediate: true });

    try {
        designLoadActualCounts.value = countFabricObjectsAndImages(canvas.value)
    } catch {
        designLoadActualCounts.value = null
    }

    if (loadedOk) {
        lastLoadedPageKey = nextPageId ? nextPageLoadKey : null
        isInitialDesignLoadDone.value = true
    }
    } finally {
        if (!isStaleLoad()) isDesignLoading.value = false
    }
}, { deep: false, immediate: true }); // Watch the object reference change

const zoomToFit = (opts: { persist?: boolean } = {}) => {
    if (!canvas.value || !wrapperEl.value) return;

    // Refresh Canvas Size
    canvas.value.setDimensions({
        width: wrapperEl.value.clientWidth,
        height: wrapperEl.value.clientHeight
    });

    const vWidth = canvas.value.getWidth();
    const vHeight = canvas.value.getHeight();
    // Infinite Canvas Logic: Fit to ALL Objects
    const objects = canvas.value.getObjects().filter((o: any) => o.id !== 'artboard-bg' && !o.excludeFromExport);

    if (objects.length === 0) {
        // Empty Canvas? Center at (0,0) with zoom 1 or default zoom
        canvas.value.setViewportTransform([1, 0, 0, 1, vWidth / 2, vHeight / 2]);
        updateZoomState();
        if (opts.persist) scheduleViewportStateSave('zoom-fit');
        showZoomMenu.value = false
        return;
    }

    // Calculate Bounding Box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    objects.forEach((obj: any) => {
        // `getBoundingRect(true, true)` returns absolute/world coords (no viewport),
        // which is what we want for a stable zoom-to-fit.
        const br = typeof obj.getBoundingRect === 'function'
            ? obj.getBoundingRect(true, true)
            : obj.getBoundingRect();
        if (br.left < minX) minX = br.left;
        if (br.top < minY) minY = br.top;
        if (br.left + br.width > maxX) maxX = br.left + br.width;
        if (br.top + br.height > maxY) maxY = br.top + br.height;
    });

    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;

    // Safety check
    if (contentWidth <= 0 || contentHeight <= 0) {
         canvas.value.setViewportTransform([1, 0, 0, 1, vWidth / 2, vHeight / 2]);
         updateZoomState();
         if (opts.persist) scheduleViewportStateSave('zoom-fit');
         showZoomMenu.value = false
         return;
    }

    // Add padding (10%)
    const padding = 100;

    const scaleX = (vWidth - padding * 2) / contentWidth;
    const scaleY = (vHeight - padding * 2) / contentHeight;
    const scale = Math.min(scaleX, scaleY, 1); // Max zoom 1 to avoid too close

    // Center Logic
    const contentCenterX = minX + contentWidth / 2;
    const contentCenterY = minY + contentHeight / 2;

    const viewportX = (vWidth / 2) - (contentCenterX * scale);
    const viewportY = (vHeight / 2) - (contentCenterY * scale);

    canvas.value.setViewportTransform([scale, 0, 0, scale, viewportX, viewportY]);
    updateZoomState();
    if (opts.persist) scheduleViewportStateSave('zoom-fit');
    showZoomMenu.value = false

    // Infinite Canvas Mode: No Artboard update needed
    // updateArtboard();
}

const updateArtboard = () => {
    // INFINITE CANVAS MODE:
    // We explicitly DISABLE the creation of the fixed "artboard-bg" rectangle.
    // The canvas is now an infinite space where users can drop Frames.
    if (!canvas.value) return;

    // Check if there's a legacy artboard left and remove it if found
    const legacyArtboard = canvas.value.getObjects().find((o: any) => o.id === 'artboard-bg');
    if (legacyArtboard) {
        canvas.value.remove(legacyArtboard);
        canvas.value.requestRenderAll();
    }
}

const resizeCanvas = () => {
    if (!canvas.value || !wrapperEl.value) return;

    const oldW = canvas.value.getWidth?.() || 0;
    const oldH = canvas.value.getHeight?.() || 0;
    const newW = wrapperEl.value.clientWidth || oldW;
    const newH = wrapperEl.value.clientHeight || oldH;
    if (!newW || !newH) return;
    if (Math.abs(newW - oldW) < 1 && Math.abs(newH - oldH) < 1) return;

    // Preserve the scene point currently at the center of the viewport.
    // This avoids drifting to corners when panels expand/collapse.
    const vpt = Array.isArray(canvas.value.viewportTransform) ? [...canvas.value.viewportTransform] : [1, 0, 0, 1, 0, 0];
    const scale = Number(vpt[0] || 1);
    let sceneCenter: any = null;
    try {
        if (oldW > 0 && oldH > 0 && (fabric as any)?.util?.invertTransform && (fabric as any)?.util?.transformPoint) {
            const inv = (fabric as any).util.invertTransform(vpt);
            sceneCenter = (fabric as any).util.transformPoint({ x: oldW / 2, y: oldH / 2 }, inv);
        }
    } catch {
        sceneCenter = null;
    }

    canvas.value.setDimensions({ width: newW, height: newH });
    canvas.value.calcOffset?.();

    if (sceneCenter && typeof sceneCenter.x === 'number' && typeof sceneCenter.y === 'number') {
        const next = [scale, 0, 0, scale, (newW / 2) - (sceneCenter.x * scale), (newH / 2) - (sceneCenter.y * scale)];
        canvas.value.setViewportTransform(next);
    } else {
        // Fallback: keep scale and center the origin
        canvas.value.setViewportTransform([scale, 0, 0, scale, newW / 2, newH / 2]);
    }

    updateScrollbars();
    safeRequestRenderAll();
}

// 🔒 === CONTAINMENT SYSTEM (Product Cards & Zones) ===
// Ensures:
// 1. Product cards stay INSIDE product zones
// 2. Product images stay INSIDE product cards
// 3. Works on load, move, and scale
// MUST be declared at component scope to be accessible in all event handlers
let containmentZoneByIdCache: Map<string, any> | null = null;
const pendingZoneRelayoutOnDrop = new Set<string>();

const invalidateContainmentZoneCache = () => {
    containmentZoneByIdCache = null;
};

const hasParentZoneBinding = (obj: any) => {
    return String((obj as any)?.parentZoneId || '').trim().length > 0;
};

const getObjectCenterInParentPlane = (obj: any): { x: number; y: number } => {
    if (!obj) return { x: 0, y: 0 };

    // Preferred for grouped objects: center in parent/group coordinate plane.
    try {
        if (typeof obj.getRelativeCenterPoint === 'function') {
            const p = obj.getRelativeCenterPoint();
            if (p && Number.isFinite(Number(p.x)) && Number.isFinite(Number(p.y))) {
                return { x: Number(p.x), y: Number(p.y) };
            }
        }
    } catch {
        // fallback below
    }

    // Fallback: derive center from local left/top + origin.
    const w = Math.abs((Number(obj.width) || 0) * (Number(obj.scaleX) || 1));
    const h = Math.abs((Number(obj.height) || 0) * (Number(obj.scaleY) || 1));
    const ox = String(obj.originX || 'left');
    const oy = String(obj.originY || 'top');
    let cx = Number(obj.left || 0);
    let cy = Number(obj.top || 0);
    if (ox === 'left') cx += w / 2;
    else if (ox === 'right') cx -= w / 2;
    if (oy === 'top') cy += h / 2;
    else if (oy === 'bottom') cy -= h / 2;

    if (Number.isFinite(cx) && Number.isFinite(cy)) return { x: cx, y: cy };

    // Final fallback for top-level objects.
    try {
        if (typeof obj.getCenterPoint === 'function') {
            const p = obj.getCenterPoint();
            if (p && Number.isFinite(Number(p.x)) && Number.isFinite(Number(p.y))) {
                return { x: Number(p.x), y: Number(p.y) };
            }
        }
    } catch {
        // ignore
    }

    return { x: 0, y: 0 };
};

const setObjectCenterInParentPlane = (obj: any, cx: number, cy: number) => {
    if (!obj) return;
    if (fabric?.Point && typeof obj.setPositionByOrigin === 'function') {
        obj.setPositionByOrigin(new fabric.Point(cx, cy), 'center', 'center');
    } else {
        obj.set({ left: cx, top: cy, originX: 'center', originY: 'center' });
    }
};

const shouldApplyContainmentConstraints = (obj: any) => {
    if (!obj) return false;
    if (obj.type === 'image') return !!obj.group;
    if (obj.type === 'group') return hasParentZoneBinding(obj);
    return false;
};

const getContainmentZoneById = (zoneId: any) => {
    if (!canvas.value) return null;
    const id = String(zoneId || '').trim();
    if (!id) return null;
    if (!containmentZoneByIdCache) {
        const map = new Map<string, any>();
        canvas.value.getObjects().forEach((o: any) => {
            if (!isLikelyProductZone(o)) return;
            const zid = String(o?._customId || '').trim();
            if (zid) map.set(zid, o);
        });
        containmentZoneByIdCache = map;
    }
    return containmentZoneByIdCache.get(id) || null;
};

const findContainmentZoneById = (zoneId: any) => {
    if (!canvas.value) return null;
    const id = String(zoneId || '').trim();
    if (!id) return null;
    return getContainmentZoneById(id) || canvas.value.getObjects().find((o: any) => (
        isLikelyProductZone(o) && String((o as any)?._customId || '').trim() === id
    )) || null;
};

const isCardLikeForZoneBinding = (obj: any) => {
    if (!obj || obj.excludeFromExport || obj.isFrame) return false;
    if (obj.type !== 'group') return false;
    const hasLegacyCardSize =
        Number.isFinite(Number((obj as any)?._cardWidth)) &&
        Number((obj as any)?._cardWidth) > 0 &&
        Number.isFinite(Number((obj as any)?._cardHeight)) &&
        Number((obj as any)?._cardHeight) > 0;
    const hasLegacyGridSignals =
        String((obj as any)?.smartGridId || '').trim().length > 0 ||
        String((obj as any)?.priceMode || '').trim().length > 0;
    return !!(
        obj.isSmartObject ||
        obj.isProductCard ||
        String(obj.name || '').startsWith('product-card') ||
        hasLegacyCardSize ||
        hasLegacyGridSignals ||
        String((obj as any)?.parentZoneId || '').trim().length > 0 ||
        String((obj as any)?._zoneSlot?.zoneId || '').trim().length > 0
    );
};

const repairLooseZoneCardBindings = () => {
    if (!canvas.value) return;
    const cards = canvas.value.getObjects().filter((o: any) => isCardLikeForZoneBinding(o));
    cards.forEach((card: any) => {
        const slotZoneId = String((card as any)?._zoneSlot?.zoneId || '').trim();
        const parentZoneId = String((card as any)?.parentZoneId || '').trim();
        const parentZone = parentZoneId ? findContainmentZoneById(parentZoneId) : null;
        const slotZone = slotZoneId ? findContainmentZoneById(slotZoneId) : null;
        const hasMissingParent = !parentZoneId;
        const hasInvalidParent = !!parentZoneId && !parentZone;
        const hasSlotMismatch = !!slotZoneId && !!parentZoneId && slotZoneId !== parentZoneId;
        const needsRepair = hasMissingParent || hasInvalidParent || hasSlotMismatch;
        if (!needsRepair) return;

        // Recover missing parent id from the persisted slot metadata.
        if (hasMissingParent && slotZone) {
            (card as any).parentZoneId = slotZoneId;
        }

        // Keep legacy cards upgraded so downstream checks stay deterministic.
        if (!card.isProductCard && !card.isSmartObject && isLikelyProductCard(card)) {
            card.isProductCard = true;
            card.isSmartObject = true;
        }

        ensureCardZoneBinding(card, { allowNearest: true });
    });
};

const markZoneForDropRelayout = (zone: any) => {
    const zoneId = String((zone as any)?._customId || '').trim();
    if (zoneId) pendingZoneRelayoutOnDrop.add(zoneId);
};

const flushZoneRelayoutOnDrop = () => {
    if (!canvas.value) return;
    repairLooseZoneCardBindings();
    if (pendingZoneRelayoutOnDrop.size === 0) return;
    const zoneIds = Array.from(pendingZoneRelayoutOnDrop);
    pendingZoneRelayoutOnDrop.clear();

    zoneIds.forEach((zoneId: string) => {
        const zone = findContainmentZoneById(zoneId);
        if (!zone) return;
        ensureZoneSanity(zone);
        recalculateZoneLayout(zone, getZoneChildren(zone), { save: false });
    });

    canvas.value.requestRenderAll();
};

const resolveCardParentZone = (card: any, opts: { allowNearest?: boolean } = {}) => {
    if (!canvas.value || !card) return null;
    const allowNearest = opts.allowNearest !== false;

    const currentZoneId = String((card as any)?.parentZoneId || '').trim();
    if (currentZoneId) {
        const currentZone = findContainmentZoneById(currentZoneId);
        if (currentZone) return currentZone;
    }

    // Slot metadata is a stronger signal than nearest-zone guessing.
    const slotZoneId = String((card as any)?._zoneSlot?.zoneId || '').trim();
    if (slotZoneId) {
        const slotZone = findContainmentZoneById(slotZoneId);
        if (slotZone) return slotZone;
    }

    const zones = canvas.value.getObjects().filter((o: any) => isLikelyProductZone(o));
    if (!zones.length) return null;
    if (zones.length === 1) return zones[0];

    const center = typeof card.getCenterPoint === 'function'
        ? card.getCenterPoint()
        : { x: Number(card.left || 0), y: Number(card.top || 0) };

    let bestZone: any = null;
    let bestDistanceSq = Number.POSITIVE_INFINITY;

    for (const zone of zones) {
        const zm = (typeof getZoneMetrics === 'function')
            ? (getZoneMetrics(zone) ?? zone.getBoundingRect(true))
            : zone.getBoundingRect(true);
        const insideBounds =
            center.x >= zm.left &&
            center.x <= (zm.left + zm.width) &&
            center.y >= zm.top &&
            center.y <= (zm.top + zm.height);
        if (insideBounds) {
            bestZone = zone;
            bestDistanceSq = 0;
            break;
        }

        try {
            if (typeof zone.intersectsWithObject === 'function' && zone.intersectsWithObject(card)) {
                bestZone = zone;
                bestDistanceSq = 0;
                break;
            }
        } catch {
            // ignore intersection errors during drag
        }

        if (!allowNearest) continue;
        const zx = Number((zm.centerX ?? (zm.left + (zm.width / 2))) || 0);
        const zy = Number((zm.centerY ?? (zm.top + (zm.height / 2))) || 0);
        const dx = center.x - zx;
        const dy = center.y - zy;
        const d2 = (dx * dx) + (dy * dy);
        if (d2 < bestDistanceSq) {
            bestDistanceSq = d2;
            bestZone = zone;
        }
    }

    if (!bestZone) return null;
    if (bestDistanceSq > 0) {
        const zm = (typeof getZoneMetrics === 'function')
            ? (getZoneMetrics(bestZone) ?? bestZone.getBoundingRect(true))
            : bestZone.getBoundingRect(true);
        const maxDim = Math.max(Number(zm.width || 0), Number(zm.height || 0), 1);
        const maxDistance = Math.max(120, maxDim * 1.75);
        if (bestDistanceSq > (maxDistance * maxDistance)) return null;
    }

    return bestZone;
};

const ensureCardZoneBinding = (card: any, opts: { allowNearest?: boolean } = {}) => {
    if (!card || !canvas.value) return null;
    const previousZoneId = String((card as any)?.parentZoneId || '').trim();
    const zone = resolveCardParentZone(card, opts);
    if (!zone) {
        // If binding references a non-existing zone, clear stale metadata.
        if (previousZoneId && !findContainmentZoneById(previousZoneId)) {
            (card as any).parentZoneId = undefined;
        }
        const slotZoneId = String((card as any)?._zoneSlot?.zoneId || '').trim();
        if (slotZoneId && !findContainmentZoneById(slotZoneId)) {
            (card as any)._zoneSlot = undefined;
        }
        return null;
    }

    const zoneId = String((zone as any)?._customId || '').trim();
    if (!zoneId) return null;

    if (String((card as any)?.parentZoneId || '').trim() !== zoneId) {
        (card as any).parentZoneId = zoneId;
    }

    // Slot metadata from another zone causes cross-zone relayout corruption.
    const slotZoneId = String((card as any)?._zoneSlot?.zoneId || '').trim();
    if (slotZoneId && slotZoneId !== zoneId) {
        (card as any)._zoneSlot = undefined;
    }

    if (previousZoneId && previousZoneId !== zoneId) {
        const previousZone = findContainmentZoneById(previousZoneId);
        if (previousZone) markZoneForDropRelayout(previousZone);
    }

    try {
        const zoneFrameId = getResolvedZoneFrameId(zone);
        applyCardFrameBinding(card, zoneFrameId);
    } catch {
        // keep binding even if frame sync fails
    }

    markZoneForDropRelayout(zone);
    return zone;
};

const getCardBaseSizeForContainment = (card: any): { w: number; h: number } | null => {
    if (!card) return null;
    const w0 = Number((card as any)._cardWidth);
    const h0 = Number((card as any)._cardHeight);
    if (Number.isFinite(w0) && w0 > 0 && Number.isFinite(h0) && h0 > 0) {
        return { w: w0, h: h0 };
    }
    try {
        if (card.type === 'group' && typeof card.getObjects === 'function') {
            const bg = card.getObjects().find((c: any) => c?.name === 'offerBackground' && (c?.type === 'rect' || c?.type === 'Rect'));
            const bw = Number(bg?.width);
            const bh = Number(bg?.height);
            if (Number.isFinite(bw) && bw > 0 && Number.isFinite(bh) && bh > 0) {
                return { w: bw, h: bh };
            }
        }
    } catch {
        // ignore
    }

    const w1 = Number(card?.width);
    const h1 = Number(card?.height);
    if (Number.isFinite(w1) && w1 > 0 && Number.isFinite(h1) && h1 > 0) {
        return { w: w1, h: h1 };
    }
    return null;
};

const applyContainmentConstraints = (obj: any) => {
    if (!obj || !canvas.value) return;
    if (!shouldApplyContainmentConstraints(obj)) return;
    
    // CONSTRAINT 1: Product Card must stay inside Product Zone
    if (obj.type === 'group' && (hasParentZoneBinding(obj) || isLikelyProductCard(obj))) {
        const zone = ensureCardZoneBinding(obj, { allowNearest: true });
        if (!zone) return;
        
        // Get zone boundaries (robust to origin/viewport)
        const zm = (typeof getZoneMetrics === 'function') ? (getZoneMetrics(zone) ?? zone.getBoundingRect(true)) : zone.getBoundingRect(true);
        const zoneLeft = zm.left;
        const zoneTop = zm.top;
        const zoneRight = zm.left + zm.width;
        const zoneBottom = zm.top + zm.height;
        
        // Get card boundaries (prefer the real card container size, not the group bounding box)
        const base = getCardBaseSizeForContainment(obj);
        const baseW = base?.w ?? (Number(obj.width) || 0);
        const baseH = base?.h ?? (Number(obj.height) || 0);
        const cardWidth = Math.abs(baseW * Number(obj.scaleX || 1));
        const cardHeight = Math.abs(baseH * Number(obj.scaleY || 1));
        const center = (typeof obj.getCenterPoint === 'function')
            ? obj.getCenterPoint()
            : { x: (obj.left ?? 0), y: (obj.top ?? 0) };

        const cardLeft = center.x - cardWidth / 2;
        const cardTop = center.y - cardHeight / 2;
        const cardRight = cardLeft + cardWidth;
        const cardBottom = cardTop + cardHeight;
        const zoneWidth = zoneRight - zoneLeft;
        const zoneHeight = zoneBottom - zoneTop;
        
        // Calculate constraints
        let constrainedCx = center.x;
        let constrainedCy = center.y;
        
        // Constrain horizontally
        if (cardWidth >= zoneWidth) {
            constrainedCx = zoneLeft + (zoneWidth / 2);
        } else if (cardLeft < zoneLeft) {
            constrainedCx = zoneLeft + cardWidth / 2;
        } else if (cardRight > zoneRight) {
            constrainedCx = zoneRight - cardWidth / 2;
        }
        
        // Constrain vertically
        if (cardHeight >= zoneHeight) {
            constrainedCy = zoneTop + (zoneHeight / 2);
        } else if (cardTop < zoneTop) {
            constrainedCy = zoneTop + cardHeight / 2;
        } else if (cardBottom > zoneBottom) {
            constrainedCy = zoneBottom - cardHeight / 2;
        }
        
        // Apply constraints if needed
        if (constrainedCx !== center.x || constrainedCy !== center.y) {
            // Keep card positioned by its center, regardless of its current origin.
            if (fabric?.Point && typeof obj.setPositionByOrigin === 'function') {
                obj.setPositionByOrigin(new fabric.Point(constrainedCx, constrainedCy), 'center', 'center');
            } else {
                obj.set({ left: constrainedCx, top: constrainedCy, originX: 'center', originY: 'center' });
            }
            obj.setCoords();
        }
    }
    
    // CONSTRAINT 2: Product Images must stay inside Product Card (when in deep-select mode)
    if (obj.type === 'image' && obj.group) {
        const parentCard = obj.group;
        const parentLikelyCard = !!(
            parentCard.isSmartObject ||
            parentCard.isProductCard ||
            hasParentZoneBinding(parentCard) ||
            String(parentCard.name || '').startsWith('product-card')
        );
        
        // Only constrain if parent is a product card
        if (!parentLikelyCard && !isLikelyProductCard(parentCard)) {
            return;
        }

        // Harden product-image transforms so scale gestures cannot leave the image flipped.
        const nextScaleX = Math.abs(Number(obj.scaleX ?? 1)) || 1;
        const nextScaleY = Math.abs(Number(obj.scaleY ?? 1)) || 1;
        obj.set({
            scaleX: nextScaleX,
            scaleY: nextScaleY,
            flipX: false,
            flipY: false,
            lockScalingFlip: true,
            lockSkewingX: true,
            lockSkewingY: true
        });
        
        // Get card boundaries in GROUP-LOCAL coordinates (do not use scaled group bounds)
        const base = getCardBaseSizeForContainment(parentCard);
        const cardW = Number(base?.w ?? parentCard.width ?? 0);
        const cardH = Number(base?.h ?? parentCard.height ?? 0);
        if (!Number.isFinite(cardW) || cardW <= 0 || !Number.isFinite(cardH) || cardH <= 0) return;
        const cardLeft = -cardW / 2;
        const cardTop = -cardH / 2;
        const cardRight = cardW / 2;
        const cardBottom = cardH / 2;
        
        // Get image size in GROUP-LOCAL coordinates
        const imgWidth = Math.abs(Number(obj.width || 0) * Number(obj.scaleX || 1));
        const imgHeight = Math.abs(Number(obj.height || 0) * Number(obj.scaleY || 1));
        if (!Number.isFinite(imgWidth) || imgWidth <= 0 || !Number.isFinite(imgHeight) || imgHeight <= 0) return;

        // Use CENTER-based clamping regardless of current origin.
        // This avoids "teleport to corner" when Fabric temporarily changes origin during scale gestures.
        const center = getObjectCenterInParentPlane(obj);
        const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));

        // If image is larger than card, range inverts naturally; keep min<=max by using Math.min/Math.max.
        const minCx = Math.min(cardLeft + (imgWidth / 2), cardRight - (imgWidth / 2));
        const maxCx = Math.max(cardLeft + (imgWidth / 2), cardRight - (imgWidth / 2));
        const minCy = Math.min(cardTop + (imgHeight / 2), cardBottom - (imgHeight / 2));
        const maxCy = Math.max(cardTop + (imgHeight / 2), cardBottom - (imgHeight / 2));

        const constrainedCx = clamp(Number(center.x || 0), minCx, maxCx);
        const constrainedCy = clamp(Number(center.y || 0), minCy, maxCy);

        // Apply constraints if needed
        if (constrainedCx !== center.x || constrainedCy !== center.y) {
            setObjectCenterInParentPlane(obj, constrainedCx, constrainedCy);
            obj.setCoords();
            parentCard.dirty = true;
        }
    }
};

onMounted(async () => {
  isCanvasDestroyed.value = false;
  isCanvasJsonLoadInProgress = false;
  // Run non-critical network warmups in background.
  // Do not block canvas/Fabric boot on auth/templates/uploads.
  void (async () => {
      try {
          await auth.getSession()
      } catch (err) {
          console.warn('[boot] auth.getSession falhou:', err)
      }

      await Promise.allSettled([
          loadLabelTemplatesFromDb(),
          refreshAiStudioUploads()
      ])

      try {
          await loadCollaborators()
      } catch (err) {
          console.warn('[boot] loadCollaborators falhou:', err)
      }

      // Retry image recovery once auth/session is stabilized.
      scheduleMissingProductImageRecovery(260, 8);
  })()
  
  // Initialize Project Store ONLY if it's a new project (default ID)
  // If loading existing project, editor/[id].vue will call loadProjectDB first
  if (!project.id || project.id.startsWith('proj_')) {
    // Don't init yet - wait for loadProjectDB from parent or create new page later
    // initProject() will be called if project remains empty after load attempt
  }

  // Dynamic import to avoid SSR issues
	  try {
	    const fabricModule = await import('fabric');
	    fabric = fabricModule; 
        // Patch Fabric image loader once so we can report real image-load progress on tablets/slow networks.
        patchFabricLoadImageProgress()
        isFabricReady.value = true

		    // Ensure our custom properties are always serialized/deserialized by Fabric (even if a save path forgets to pass propsToInclude).
		    try {
		        const stickerProps = [
		            '__stickerOutlineEnabled',
		            '__stickerOutlineMode',
		            '__stickerOutlineWidth',
		            '__stickerOutlineColor',
		            '__stickerOutlineOpacity',
		            '__stickerNoTransparency',
		            'crossOrigin',
                    '__originalSrc'
	        ];
	        const addCustomProps = (Ctor: any, props: string[]) => {
	            if (!Ctor) return;
	            const cur = Array.isArray(Ctor.customProperties) ? Ctor.customProperties : [];
	            Ctor.customProperties = Array.from(new Set([...cur, ...props]));
	        };
	        addCustomProps((fabric as any).FabricObject, stickerProps);
	        addCustomProps((fabric as any).Object, stickerProps);
	        addCustomProps((fabric as any).Image, stickerProps);
	        addCustomProps((fabric as any).FabricImage, stickerProps);
	    } catch (e) {
	        console.warn('⚠️ Falha ao registrar customProperties do Fabric (StickerOutline):', e);
	    }

	    // PATCH: Fabric v7 can call `drawObject(ctx, false, {})` (no cache path),
	    // but `_drawClipPath` assumes a DrawContext with `parentClipPaths` and will crash.
	    // We harden `_drawClipPath` to fill missing context fields.
    try {
        const Base = (fabric as any)?.BaseFabricObject;
        if (Base?.prototype && !(Base.prototype as any).__patchedClipPathContext) {
            const originalDrawClipPath = Base.prototype._drawClipPath;
            Base.prototype._drawClipPath = function (ctx: any, clipPath: any, context: any) {
                const safeCtx = (context && typeof context === 'object') ? context : {};
                if (!Array.isArray(safeCtx.parentClipPaths)) safeCtx.parentClipPaths = [];
                if (typeof safeCtx.cacheTranslationX !== 'number') safeCtx.cacheTranslationX = 0;
                if (typeof safeCtx.cacheTranslationY !== 'number') safeCtx.cacheTranslationY = 0;
                if (typeof safeCtx.zoomX !== 'number') safeCtx.zoomX = 1;
                if (typeof safeCtx.zoomY !== 'number') safeCtx.zoomY = 1;
                // Ensure layer canvas has non-zero dimensions.
                if (typeof safeCtx.width !== 'number' || safeCtx.width <= 0) {
                    const w = (typeof this.getScaledWidth === 'function')
                        ? this.getScaledWidth()
                        : (Number(this.width || 0) * Number(this.scaleX || 1));
                    safeCtx.width = Math.max(1, Math.ceil(Number(w) || 1));
                }
                if (typeof safeCtx.height !== 'number' || safeCtx.height <= 0) {
                    const h = (typeof this.getScaledHeight === 'function')
                        ? this.getScaledHeight()
                        : (Number(this.height || 0) * Number(this.scaleY || 1));
                    safeCtx.height = Math.max(1, Math.ceil(Number(h) || 1));
                }
                return originalDrawClipPath.call(this, ctx, clipPath, safeCtx);
            };
            (Base.prototype as any).__patchedClipPathContext = true;
            console.log('🩹 Fabric patch aplicado: _drawClipPath context hardening');
        }
    } catch (e) {
        console.warn('⚠️ Falha ao aplicar patch do Fabric (_drawClipPath):', e);
    }
    
	    if (canvasEl.value && wrapperEl.value) {
	      try {
	        // Init Infinite Canvas (Full Wrapper Size)
	        canvas.value = new fabric.Canvas(canvasEl.value, {
	          width: wrapperEl.value.clientWidth,
	          height: wrapperEl.value.clientHeight,
	          backgroundColor: '#1e1e1e', // Dark Workspace
	          preserveObjectStacking: true, 
	          renderOnAddRemove: true,
	          selection: true,
              // Disable Fabric default Shift multiselect so we can fully control additive selection logic.
              selectionKey: null,
	          // Required for deep-select (sub-target selection inside Fabric groups).
	          subTargetCheck: true,
	          // CRITICAL: Enable renderOnAddRemove and skipTargetFind to prevent trails
	          skipTargetFind: false,
	          // Force full render to clear previous positions
	          enableRetinaScaling: true,
	          // IMPORTANT: Disable clipTo to allow preview lines to extend beyond viewport
	          clipTo: undefined,
	        });

            // Global baseline for huge scenes: skip drawing offscreen objects.
            // This is safe for editing and dramatically reduces overdraw on large projects.
            (canvas.value as any).skipOffscreen = true;

            // Tablet/Touch UX + performance: bigger handles and cheaper hit-tests.
            // This makes selection/resizing usable on iPad/Android tablets.
            try {
                const isCoarsePointer =
                    typeof window !== 'undefined' &&
                    typeof window.matchMedia === 'function' &&
                    window.matchMedia('(pointer: coarse)').matches;

                if (isCoarsePointer && canvas.value) {
                    // Big canvases render faster if we skip objects outside viewport.
                    // Safe for interactive editing; exports should use their own render path.
                    (canvas.value as any).skipOffscreen = true;
                    // Per-pixel hit-testing is expensive and unnecessary for touch.
                    (canvas.value as any).perPixelTargetFind = false;
                    // Increase tolerance so taps select objects more reliably.
                    const prevTol = Number((canvas.value as any).targetFindTolerance || 0);
                    (canvas.value as any).targetFindTolerance = Math.max(prevTol, 12);

                    const Obj = (fabric as any)?.Object || (fabric as any)?.FabricObject;
                    if (Obj?.prototype) {
                        // Fabric uses touchCornerSize on touch devices; keep cornerSize untouched for desktop.
                        if (typeof Obj.prototype.touchCornerSize !== 'number' || Obj.prototype.touchCornerSize < 22) {
                            Obj.prototype.touchCornerSize = 22;
                        }
                        // Slightly stronger border scale helps on high-DPI tablets.
                        if (typeof Obj.prototype.borderScaleFactor !== 'number' || Obj.prototype.borderScaleFactor < 1.2) {
                            Obj.prototype.borderScaleFactor = 1.2;
                        }
                    }
                }
            } catch {
                // ignore
            }

	        // Prevent black-screen render failures by guarding Fabric rendering.
	        patchCanvasRenderSafety(canvas.value);

        // PATCH: Improve hit-testing for product cards inside zones.
        // Some interactions (deep select, non-evented children, transparent areas) can make Fabric miss the card and start a group selection rectangle.
        // We wrap `findTarget` to prefer the top-most product card under pointer when Fabric returns null or the zone itself.
        try {
            const c: any = canvas.value as any;
            if (c && !c.__patchedFindTargetProductCards) {
                const originalFindTarget = c.findTarget?.bind(c);
                if (typeof originalFindTarget === 'function') {
                    const isProductCardGroup = (o: any) => {
                        if (!o) return false;
                        if (o.excludeFromExport) return false;
                        if (String(o.type || '').toLowerCase() !== 'group') return false;
                        return !!(o.isSmartObject || o.isProductCard || String(o.name || '').startsWith('product-card') || isLikelyProductCard(o));
                    };
                    const isFrameLikeHitTarget = (o: any) => {
                        if (!o) return false;
                        if (o.isFrame === true) return true;
                        const layerName = String(o.layerName || '').trim().toUpperCase();
                        const name = String(o.name || '').trim().toUpperCase();
                        return layerName === 'FRAMER' || layerName === 'FRAME' || name === 'FRAMER' || name === 'FRAME';
                    };
                    const isInteractiveHitCandidate = (o: any) => {
                        if (!o) return false;
                        if (o.excludeFromExport) return false;
                        if (o.visible === false) return false;
                        if (o.evented === false && o.selectable === false) return false;
                        return true;
                    };
                    const isTextLikeHitTarget = (o: any) => {
                        if (!o || o.excludeFromExport) return false;
                        const t = String(o.type || '').toLowerCase();
                        if (t === 'text' || t === 'i-text' || t === 'textbox') return true;
                        if (t === 'group' && typeof o.getObjects === 'function') {
                            try {
                                const children = o.getObjects() || [];
                                return children.some((child: any) => {
                                    const ct = String(child?.type || '').toLowerCase();
                                    return ct === 'text' || ct === 'i-text' || ct === 'textbox';
                                });
                            } catch {
                                return false;
                            }
                        }
                        return false;
                    };
                    const hitObjectByPoints = (o: any, pts: any[]) => {
                        if (!o || !pts.length) return false;
                        try {
                            if (typeof o.containsPoint === 'function') {
                                for (const pt of pts) {
                                    if (o.containsPoint(pt, undefined, true)) return true;
                                }
                            }
                        } catch {
                            // ignore containsPoint failures and fallback to bounds
                        }
                        try {
                            const r = o.getBoundingRect?.(true, true);
                            if (!r) return false;
                            for (const pt of pts) {
                                if (pt.x >= r.left && pt.x <= (r.left + r.width) && pt.y >= r.top && pt.y <= (r.top + r.height)) {
                                    return true;
                                }
                            }
                        } catch {
                            // ignore
                        }
                        return false;
                    };
                    c.findTarget = function (evt: any, skipGroup?: boolean) {
                        const info = originalFindTarget(evt, skipGroup) || {};
                        const target = info?.target ?? info;
                        const targetIsZone = !!(target && isLikelyProductZone(target));
                        const targetIsFrame = !!(target && isFrameLikeHitTarget(target));
                        const shouldOverride = !target || targetIsZone || targetIsFrame;
                        if (!shouldOverride) return info;

                        const pts: any[] = [];
                        try {
                            if (typeof this.getScenePoint === 'function') {
                                const p0 = this.getScenePoint(evt);
                                if (p0 && typeof p0.x === 'number' && typeof p0.y === 'number') pts.push(p0);
                            }
                        } catch {
                            // ignore
                        }
                        try {
                            if (typeof this.getPointer === 'function') {
                                const p1 = this.getPointer(evt);
                                if (p1 && typeof p1.x === 'number' && typeof p1.y === 'number') pts.push(p1);
                                const vpt = this.viewportTransform;
                                if (p1 && Array.isArray(vpt) && vpt.length >= 6 && (fabric as any)?.util?.invertTransform) {
                                    const inv = (fabric as any).util.invertTransform(vpt);
                                    const p2 = (fabric as any).util.transformPoint(p1, inv);
                                    if (p2 && typeof p2.x === 'number' && typeof p2.y === 'number') pts.push(p2);
                                }
                            }
                        } catch {
                            // ignore
                        }
                        if (!pts.length) return info;

                        const list = (typeof this.getObjects === 'function' ? this.getObjects() : (this._objects || [])).slice().reverse();
                        for (const o of list) {
                            if (!isProductCardGroup(o)) continue;
                            if (hitObjectByPoints(o, pts)) return { ...(info || {}), target: o };
                        }

                        // If Fabric hit a zone, still allow direct text selection over/near zone edges.
                        // This fixes cases where footer text becomes "unclickable" because the zone
                        // bounding area overlaps it.
                        if (targetIsZone) {
                            for (const o of list) {
                                if (!isInteractiveHitCandidate(o)) continue;
                                if (isFrameLikeHitTarget(o)) continue;
                                if (isLikelyProductZone(o)) continue;
                                if (!isTextLikeHitTarget(o)) continue;
                                if (hitObjectByPoints(o, pts)) {
                                    return { ...(info || {}), target: o };
                                }
                            }
                            return info;
                        }

                        // Generic fallback:
                        // if Fabric resolved the frame/zone itself (or nothing), prefer the
                        // top-most interactive non-frame object under the pointer.
                        for (const o of list) {
                            if (!isInteractiveHitCandidate(o)) continue;
                            if (isFrameLikeHitTarget(o)) continue;
                            if (isLikelyProductZone(o)) continue;
                            if (hitObjectByPoints(o, pts)) {
                                return { ...(info || {}), target: o };
                            }
                        }

                        return info;
                    };
                    c.__patchedFindTargetProductCards = true;
                }
            }
        } catch (e) {
            console.warn('⚠️ Falha ao aplicar patch do Fabric (findTarget product cards):', e);
        }
        
        // Set initial viewport to center
        zoomToFit();
      } catch (error) {
        console.error('Error initializing canvas:', error);
      }

      // Fallback: alguns estados pós-load podem não emitir `mouse:dblclick` do Fabric.
      // Escutamos dblclick no DOM e disparamos manualmente o evento do Fabric.
      try {
          if (!domCanvasDblClickHandler && canvas.value?.upperCanvasEl) {
              domCanvasDblClickHandler = (evt: MouseEvent) => {
                  if (!canvas.value) return;
                  const now = Date.now();
                  if (now - lastDomDblClickAt < 250) return;
                  lastDomDblClickAt = now;

                  const c: any = canvas.value as any;
                  let info: any = null;
                  try {
                      info = (typeof c.findTarget === 'function') ? c.findTarget(evt) : null;
                  } catch (e) {
                      info = null;
                  }
                  const target = info?.target ?? info ?? null;
                  try {
                      c.fire?.('mouse:dblclick', { e: evt, originalEvent: evt, target });
                  } catch (e) {
                      // ignore
                  }
              };
              canvas.value.upperCanvasEl.addEventListener('dblclick', domCanvasDblClickHandler, { passive: true });
          }
      } catch (e) {
          // ignore
      }

      // Initialize Smart Grid
      initProductZone();
      
      // Force workspace to dark
      wrapperEl.value.style.backgroundColor = '#121212';
      
      // --- Frame Labels: update HTML overlay positions on every render ---
      canvas.value.on('after:render', handleAfterRenderPerf);
      canvas.value.on('after:render', () => {
          throttledUpdateFrameLabels();
      });

      // Update scrollbars on render
      canvas.value.on('after:render', throttledUpdateScrollbars);

      // Resize Window Event - Resize Canvas & Re-center
      window.addEventListener('resize', resizeCanvas);

      // CRITICAL: wrapper size changes (sidebars/panels) do NOT trigger window resize.
      // Observe wrapper and resize Fabric canvas accordingly to avoid large black areas.
      try {
          if (!wrapperResizeObserver && typeof window !== 'undefined' && 'ResizeObserver' in window && wrapperEl.value) {
              let raf = 0;
              wrapperResizeObserver = new ResizeObserver(() => {
                  if (raf) cancelAnimationFrame(raf);
                  raf = requestAnimationFrame(() => {
                      resizeCanvas();
                  });
              });
              wrapperResizeObserver.observe(wrapperEl.value);
          }
      } catch (e) {
          // ignore
      }
      
      // Initial scrollbar update
      updateScrollbars();
      
      // Zoom & Pan
      setupZoomPan();
      
      // Snapping
      setupSnapping();

      // Load Fonts
      loadFonts();

      // Clean up any orphaned control/preview objects on initialization
      cleanupOrphanedObjects();

      // Hook events for Reactivity
      setupReactivity();
      scheduleViewportCulling('force');

      // Hook History
      setupHistory();

      // Alt/Option + Drag duplicate
      setupAltDragDuplicate();
      
      // Global Key Listener
      window.addEventListener('keydown', handleKeyDown);
      
      // ESC key handler for Pen Tool and Node Editing
      if (!globalEscKeyHandler) {
          globalEscKeyHandler = (e: KeyboardEvent) => {
              if (e.key === 'Escape') {
                  if (isPenMode.value) {
                      finishPenPath();
                      setTool('select');
                  }
                  if (isNodeEditing.value) {
                      exitNodeEditing();
                  }
              }
          };
          window.addEventListener('keydown', globalEscKeyHandler);
      }

      if (!globalKeyUpHandler) {
          globalKeyUpHandler = (e: KeyboardEvent) => {
              if (e.code === 'Space') {
                  isSpacePanPressed = false;
                  if (canvas.value && canvas.value.defaultCursor === 'grab') {
                      canvas.value.defaultCursor = 'default';
                  }
              }

              if (
                  keyboardNudgeDirty &&
                  (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')
              ) {
                  keyboardNudgeDirty = false;
                  saveCurrentState({ reason: 'keyboard-nudge' });
              }
          };
          window.addEventListener('keyup', globalKeyUpHandler);
      }
      if (!globalMouseUpHandler) {
          globalMouseUpHandler = (evt: MouseEvent) => {
              if (!canvas.value) return;
              const currentTransform = (canvas.value as any)._currentTransform;
              if (!currentTransform) return;
              
              const upEvent = {
                  clientX: evt.clientX,
                  clientY: evt.clientY,
                  type: 'mouseup',
                  target: canvas.value.upperCanvasEl,
                  button: evt.button,
                  buttons: evt.buttons,
                  altKey: evt.altKey,
                  ctrlKey: evt.ctrlKey,
                  metaKey: evt.metaKey,
                  shiftKey: evt.shiftKey
              } as any;
              
              (canvas.value as any)._onMouseUp(upEvent);

              if ((canvas.value as any)._currentTransform) {
                  (canvas.value as any)._currentTransform = null;
                  safeRequestRenderAll();
              }
          };
          window.addEventListener('mouseup', globalMouseUpHandler);
      }

      // LEGACY loader desativado: mantemos um único pipeline no watch(activePage)
      // para evitar corrida de load e sobrescrita acidental.
      if (ENABLE_LEGACY_WATCH_EFFECT_LOADER) {
      let stopWatchFn: (() => void) | null = null;
      stopWatchFn = watchEffect(async () => {
          if (!canvas.value) return;

          const loaded = isProjectLoaded.value;
          const pagesLen = project.pages.length;
          const projectId = project.id;
          const page = activePage.value;

          console.log('🔍 WatchEffect trigger:', { loaded, pagesLen, projectId, hasPage: !!page, hasCanvasData: !!page?.canvasData });

          // Only load when project is loaded AND we have a page
          if (loaded && page && pagesLen > 0) {
              if (isCanvasJsonLoadInProgress) {
                  console.log('⏳ Carregamento de canvas já em andamento, aguardando conclusão...');
                  return;
              }

              // Check if canvas is already loaded to avoid reloading
              const objects = canvas.value.getObjects();
              const alreadyLoaded = objects.some((o: any) => {
                  if (!o || o.id === 'artboard-bg') return false;
                  if (isTransientCanvasObject(o)) return false;
                  return true;
              });

              if (alreadyLoaded && page.canvasData) {
                  console.log('⏭️ Canvas já carregado, parando watch');
                  if (stopWatchFn) stopWatchFn();
                  return;
              }

              isCanvasJsonLoadInProgress = true;
              isHistoryProcessing.value = true;

              try {
                  // Declarar degradedPage no escopo do try para estar disponível em todo o bloco
                  let degradedPage = false;
                  
                  if (page.canvasData) {
                      // Validar que canvasData não está vazio ou inválido
                      const isValidCanvasData = page.canvasData && 
                          typeof page.canvasData === 'object' && 
                          (page.canvasData.objects || page.canvasData.version);
                      
                      if (!isValidCanvasData) {
                          console.error('❌ CanvasData inválido ou vazio para página:', page.id);
                          console.error('   CanvasData:', page.canvasData);
                          isHistoryProcessing.value = false;
                          return;
                      }
                      
                      const objectCount = page.canvasData?.objects?.length || 0;
                      console.log(`📥 Carregando canvasData da página ${page.id}: ${objectCount} objeto(s)`);
                      
                      if (objectCount === 0) {
                          // Página nova/vazia — canvas válido sem objetos, continua normalmente
                      }
                      
                      // CRITICAL: Ensure canvas is fully initialized before loading
                      if (!canvas.value) {
                          console.warn('⚠️ Canvas não inicializado, aguardando...');
                          await new Promise(resolve => setTimeout(resolve, 100));
                      }
                      
                      // Double-check canvas has context before loading
                      if (!canvas.value || !canvas.value.getContext) {
                          console.error('❌ Canvas não está inicializado com contexto');
                          isHistoryProcessing.value = false;
                          return;
                      }
                      
                      const savedVpt = getSavedViewportTransform(page.canvasData);
                      // Restore label templates stored alongside the Fabric JSON
                      hydrateLabelTemplatesFromProjectJson(page.canvasData);
                      
                      // Log antes de carregar
                      const expectedObjects = page.canvasData?.objects?.length || 0;
                      const deferHeavyPostLoad = !isInitialCanvasHydrationDone.value && expectedObjects >= 80;
                      console.log(`📥 Preparando para carregar ${expectedObjects} objeto(s) do canvasData`);
                      
                      // Normalize image URLs to same-origin proxy (Wasabi/Contabo) before load.
                      let canvasDataToLoad = prepareCanvasDataForLoad(page.canvasData);
                      
                      console.log(`📦 CanvasData carregado - ${canvasDataToLoad?.objects?.length || 0} objeto(s)`);
                      
                      let didLoadPage = false;
                      try {
                          // CRITICAL: Wrap loadFromJSON in a try-catch that handles image errors gracefully
                          // If an image fails to load, we'll catch the error and continue with other objects
                          try {
                              await loadFromJsonSafe(canvasDataToLoad);
                              didLoadPage = true;
                          } catch (imageLoadErr: any) {
                              // Image load error - since we're using proxy, this shouldn't happen often
                              // but if it does, log it and try to continue
                              console.warn('⚠️ Erro ao carregar canvas:', imageLoadErr);
                              
                              // Try again with failed images replaced by placeholders
                              const safeCanvasData = replaceContaboImagesWithPlaceholder(canvasDataToLoad);
                              await loadFromJsonSafe(safeCanvasData);
                              didLoadPage = true;
                              degradedPage = true;
                          }
                          
                          // Verificar quantos objetos foram carregados
                          const loadedObjects = canvas.value.getObjects();
                          const loadedCount = loadedObjects.length;
                          const imageCount = loadedObjects.filter((o: any) => (o.type || '').toLowerCase() === 'image').length;
                          console.log(`✅ loadFromJSON concluído: ${loadedCount} objeto(s) carregado(s) (esperado: ${expectedObjects}), ${imageCount} imagem(ns)`);
                          
                          // CRITICAL: Sanitize groups to remove invalid objects
                          let removedInvalidObjects = 0;
                          loadedObjects.forEach((obj: any) => {
                              if (obj.type === 'group' && typeof obj.getObjects === 'function') {
                                  const children = obj.getObjects();
                                  const validChildren = children.filter((child: any) => {
                                      const isValid = child && typeof child === 'object' && typeof child.setCoords === 'function';
                                      if (!isValid) {
                                          console.error('❌ Objeto inválido removido do grupo:', {
                                              groupId: obj._customId || obj.name,
                                              childType: typeof child,
                                              childValue: child
                                          });
                                          removedInvalidObjects++;
                                      }
                                      return isValid;
                                  });
                                  
                                  if (validChildren.length !== children.length) {
                                      // Rebuild group with valid children only
                                      const internal = (obj as any)._objects;
                                      if (Array.isArray(internal)) {
                                          internal.length = 0;
                                          validChildren.forEach((c: any) => internal.push(c));
                                      }
                                  }
                              }
                          });
                          
                          if (removedInvalidObjects > 0) {
                              console.warn(`⚠️ Removidos ${removedInvalidObjects} objetos inválidos de grupos durante sanitização`);
                          }
                          // Log image loading status
                          const expectedImages = (canvasDataToLoad.objects || []).filter((o: any) => (o.type || '').toLowerCase() === 'image').length;
                          if (expectedImages > 0) {
                              console.log(`✅ ${imageCount}/${expectedImages} imagem(ns) carregada(s)`);
                          }
                          
                          if (loadedCount === 0 && expectedObjects > 0) {
                              console.error(`❌ PROBLEMA CRÍTICO: CanvasData tinha ${expectedObjects} objetos mas nenhum foi carregado!`);
                              console.error('   CanvasData preview:', JSON.stringify(page.canvasData).substring(0, 500));
                          } else if (loadedCount !== expectedObjects) {
                              console.warn(`⚠️ Discrepância: esperado ${expectedObjects} objetos, mas ${loadedCount} foram carregados`);
                          }
                      } catch (loadErr) {
                          console.error('❌ Erro ao carregar JSON no canvas:', loadErr);
                          // Try with placeholders as fallback
                          if (canvas.value) {
                              try {
                                  const dataWithPlaceholders = replaceContaboImagesWithPlaceholder(canvasDataToLoad);
                                  await loadFromJsonSafe(dataWithPlaceholders);
                                  didLoadPage = true;
                                  degradedPage = true;
                                  console.log('✅ loadFromJSON concluído com placeholders');
                              } catch (placeholderErr) {
                                  console.error('❌ Erro final ao carregar:', placeholderErr);
                                  throw placeholderErr;
                              }
                          } else {
                              throw loadErr;
                          }
                      }
                      // If we couldn't load, bail out BEFORE saving anything (prevents wiping server JSON).
                      if (!didLoadPage) {
                          isHistoryProcessing.value = false;
                          return;
                      }
                      
                      // Remove old frame label text objects (if any were saved)
                      // IMPORTANT: Preserve order by removing from end
                      const objects = canvas.value.getObjects();
                      const labelsToRemove: any[] = [];
                      // Iterate in reverse to mark for removal from end
                      for (let i = objects.length - 1; i >= 0; i--) {
                          const obj = objects[i];
                          if (obj.isFrameLabel || (obj.type === 'text' && obj.text && obj.text.includes('@') && obj.text.includes('dpi'))) {
                              labelsToRemove.push(obj);
                          }
                      }
                      // Remove from end to preserve order
                      labelsToRemove.forEach((obj: any) => {
                          try {
                              canvas.value.remove(obj);
                          } catch (e) {
                              // Ignore errors
                          }
                      });
                      
                      // CRITICAL: Remove any duplicate objects BEFORE rehydration
                      // IMPORTANT: Preserve order by removing duplicates from the END of the array
                      // This ensures the first occurrence (correct order) is kept
                      const allObjsBefore = canvas.value.getObjects();
                      const seenIds = new Set<string>();
                      const duplicates: any[] = [];
                      // Iterate in reverse to remove duplicates from the end, preserving order
                      for (let i = allObjsBefore.length - 1; i >= 0; i--) {
                          const obj = allObjsBefore[i];
                          if (isTransientCanvasObject(obj)) continue;
                          const id = obj._customId || obj.id;
                          if (id && seenIds.has(id)) {
                              if (obj._customId) {
                                  const old = obj._customId;
                                  obj._customId = makeCanvasObjectId();
                                  seenIds.add(obj._customId);
                                  console.warn(`⚠️ _customId duplicado detectado no watchEffect load. Regenerado ${old} -> ${obj._customId}`);
                              } else {
                                  duplicates.push(obj);
                              }
                          } else if (id) {
                              seenIds.add(id);
                          }
                      }
                      if (duplicates.length > 0) {
                          console.warn(`⚠️ Removendo ${duplicates.length} objeto(s) duplicado(s) após loadFromJSON`);
                          // Remove duplicates without affecting order of remaining objects
                          duplicates.forEach(dup => canvas.value.remove(dup));
                      }
                      
                      // NOTE: Removed problematic code that was deleting frames with blue stroke
                      // before rehydrateCanvasZones could restore their isFrame flag.
                      // This was causing frames to be removed and re-added at the end, changing layer order.
                      // The rehydrateCanvasZones function below will properly restore isFrame flags.
                      
                      // CRITICAL: Clear deserialized frame clipPaths before rehydrate.
                      // Keep object masks (`objectMaskEnabled`) intact.
                      const objsBeforeRehydrate = canvas.value.getObjects();
                      objsBeforeRehydrate.forEach((obj: any) => {
                          // Rehydrate will recreate frame clips from parentFrameId.
                          const hasObjectMask = !!obj?.objectMaskEnabled;
                          if (obj.clipPath && !obj.isFrame && !hasObjectMask) {
                              obj.clipPath = null;
                              delete obj._frameClipOwner;
                          }
                      });
                      
                       // CRITICAL: Rehydrate zones AND frames to restore isFrame flags and normalize names
                      rehydrateCanvasZones();
                      
                      // CRITICAL FIX: Restore lost object names in product cards after JSON load
                      // When canvas is loaded from JSON, nested object names inside groups are lost
                      const restoreProductCardNames = () => {
                          if (!canvas.value) return;
                          
                          canvas.value.getObjects().forEach((obj: any) => {
                              // Check if this is a product card
                              if (obj.type === 'group' && (obj.isProductCard || obj.isSmartObject || isLikelyProductCard(obj))) {
                                  if (typeof obj.getObjects !== 'function') return;
                                  
                                  const children = obj.getObjects();
                                  
                                  // Find price group inside the card
                                  const priceGroup = children.find((child: any) => 
                                      child.type === 'group' && (
                                          child.name === 'priceGroup' || 
                                          child.name === 'smart_price' ||
                                          child.name === 'smart_splash'
                                      )
                                  );
                                  
                                  if (priceGroup && typeof priceGroup.getObjects === 'function') {
                                      const priceChildren = priceGroup.getObjects();
                                      
                                      // Heuristic: identify elements by type and assign names
                                      priceChildren.forEach((child: any) => {
                                          if (child.name) return; // Already has a name
                                          
                                          // Try to identify by type and properties
                                          if (child.type === 'rect') {
                                              // The largest rect is likely price_bg
                                              const isLargest = !priceChildren.some((other: any) => 
                                                  other !== child && 
                                                  other.type === 'rect' && 
                                                  (other.width * other.height) > (child.width * child.height)
                                              );
                                              if (isLargest) {
                                                  child.set('name', 'price_bg');
                                              }
                                          } else if (child.type === 'circle') {
                                              child.set('name', 'price_currency_bg');
                                          } else if (child.type && child.type.includes('text')) {
                                              const text = String(child.text || '').trim();
                                              if (text === 'R$' || text.includes('R$')) {
                                                  child.set('name', 'price_currency_text');
                                              } else if (/^\d+$/.test(text.replace(',', ''))) {
                                                  // Integer part of price
                                                  const hasInteger = priceChildren.some((other: any) => 
                                                      other !== child && other.name === 'price_integer_text'
                                                  );
                                                  if (!hasInteger) {
                                                      child.set('name', 'price_integer_text');
                                                  } else {
                                                      child.set('name', 'price_decimal_text');
                                                  }
                                              } else {
                                                  child.set('name', 'price_unit_text');
                                              }
                                          }
                                      });
                                      
                                      // Also fix other card children
                                      children.forEach((child: any) => {
                                          if (child.name) return;
                                          
                                          if (child.type === 'rect' && child.width > child.height * 0.8) {
                                              // Likely offer background
                                              child.set('name', 'offerBackground');
                                          } else if (child.type && child.type.includes('text')) {
                                              const text = String(child.text || '').trim().toLowerCase();
                                              if (text.includes('kg') || text.includes('ml') || text.includes('un')) {
                                                  child.set('name', 'smart_limit');
                                              } else {
                                                  child.set('name', 'smart_title');
                                              }
                                          } else if (child.type === 'image') {
                                              child.set('name', 'smart_image');
                                          }
                                      });
                                  }
                              }
                          });
                      };

                      // CRITICAL: After rehydrate, ensure all frames have layerName and isFrame
                      const allObjs = canvas.value.getObjects();
                      let framesFixed = 0;
                      allObjs.forEach((obj: any) => {
                          // Detect frame-like objects that might have lost isFrame flag
                          const isFrameLike = obj?.isFrame || 
                              (obj?.type === 'rect' && 
                               (obj?.clipContent === true || obj?.clipContent === 1) && 
                               String(obj?.stroke || '').toLowerCase() === '#0d99ff');
                          
                          if (isFrameLike) {
                              obj.isFrame = true;
                              if (!obj.layerName) {
                                  obj.layerName = 'FRAMER';
                                  framesFixed++;
                              }
                              // Ensure stroke is correct
                              if (!obj.stroke || String(obj.stroke).toLowerCase() !== '#0d99ff') {
                                  obj.stroke = '#0d99ff';
                              }
                          }
                      });
                      
                      if (framesFixed > 0 && !degradedPage) {
                          // Re-save immediately to persist the fixes
                          if (!deferHeavyPostLoad) {
	                              saveCurrentState({ reason: 'frame-fix-post-load', source: 'system', skipIfUnchanged: true });
	                          } else {
	                              scheduleIdleStatePersistence({ reason: 'frame-fix-post-load', source: 'system', skipIfUnchanged: true }, 3000);
	                          }
                      }
                      
                      // CRITICAL: Remove any artboard-bg that might have been incorrectly created from a Frame
                      // IMPORTANT: Find and remove without affecting order of other objects
                      const artboard = canvas.value.getObjects().find((o: any) => o.id === 'artboard-bg');
                      if (artboard && (artboard.isFrame || artboard.clipContent || artboard.selectable)) {
                          console.warn('⚠️ Removendo artboard-bg incorreto (era um Frame)');
                          // Remove without affecting order (artboard is usually at the end)
                          try {
                              canvas.value.remove(artboard);
                          } catch (e) {
                              // Ignore errors
                          }
                      }
                      
                      const runHeavyPostLoadPasses = () => {
                          if (!canvas.value || isCanvasDestroyed.value) return;

                          restoreProductCardNames();

                          // Clean up transient/orphaned control objects that might have been saved
                          const allObjsForCleanup = canvas.value.getObjects();
                          const orphanedToRemove: any[] = [];
                          for (let i = allObjsForCleanup.length - 1; i >= 0; i--) {
                              const o = allObjsForCleanup[i];
                              ensurePersistentContentFlags(o);
                              ensureObjectPersistentId(o);
                              if (isTransientCanvasObject(o)) {
                                  orphanedToRemove.push(o);
                              }
                          }
                          if (orphanedToRemove.length > 0) {
                              orphanedToRemove.forEach((obj: any) => {
                                  try { canvas.value.remove(obj); } catch (e) {}
                              });
                          }

                          // Ensure product cards stay in zones and images stay in cards
                          const allLoadedObjects = canvas.value.getObjects();
                          allLoadedObjects.forEach((obj: any) => {
                              if (shouldApplyContainmentConstraints(obj)) {
                                  applyContainmentConstraints(obj);
                              }
                          });

                          refreshCanvasObjects();
                          safeRequestRenderAll();
                      };

                      if (deferHeavyPostLoad) {
                          scheduleIdleWork(runHeavyPostLoadPasses, 2800);
                      } else {
                          runHeavyPostLoadPasses();
                      }
                      
                      // CRITICAL: Preserve exact order from JSON - don't reorder objects
                      // Force update canvasObjects to reflect restored state (order preserved from loadFromJSON)
                      // IMPORTANT: Get objects in exact order they were loaded (Fabric preserves order in _objects array)
                      const loadedObjs = canvas.value.getObjects();
                      refreshCanvasObjects({ source: loadedObjs, immediate: true });
                      
                      // Ensure objects have IDs restored if missing - BUT exclude frames
                      const objs = canvas.value.getObjects();
                      objs.forEach((o: any) => {
                          // CRITICAL: Don't mark frames as artboard! Only mark non-selectable, non-frame rects
                          if (o.type === 'rect' && !o.selectable && !o.id && !o.isFrame && !o.clipContent) {
                              o.set('id', 'artboard-bg');
                              console.log('✅ Artboard ID restaurado para retângulo não-Frame');
                          }
                      });

                      safeRequestRenderAll();

                      // Restore last viewport (pan/zoom) if present; otherwise fit.
                      if (savedVpt) {
                          applyViewportTransform(savedVpt);
                      } else {
                          zoomToFit();
                      }
                  } else {
                      console.log('⚠️ Página sem canvasData, criando canvas vazio');
                  }

                  // Ensure Artboard is there
                  updateArtboard();
                  refreshCanvasObjects();
                  isHistoryProcessing.value = false;
                  historyStack.value = [];
                  historyIndex.value = -1;
                  // Important: DO NOT auto-save after a degraded load (missing images),
                  // otherwise we overwrite the stored JSON with placeholders/empty state.
                  if (!degradedPage) {
                      const expectedObjects = Number(page?.canvasData?.objects?.length || 0);
                      const nonTransientObjects = canvas.value
                          .getObjects()
                          .filter((o: any) => !isTransientCanvasObject(o) && o?.id !== 'artboard-bg').length;

                      if (expectedObjects > 0 && nonTransientObjects === 0) {
                          console.warn('⚠️ Pós-load gerou canvas vazio para página que tinha objetos. Pulando auto-save para evitar sobrescrita.');
                      } else {
                          // Persistência pós-load em modo ocioso:
                          // evita travar o primeiro paint do editor.
	                          scheduleIdleStatePersistence({
	                              allowEmptyOverwrite: expectedObjects === 0,
	                              reason: 'post-load-cleanup',
                                  source: 'system',
                                  skipIfUnchanged: true
	                          });
                      }
                  } else {
                      console.warn('⚠️ Carregamento degradado (imagens com erro). Pulando auto-save para não sobrescrever o projeto.');
                  }

                  // Stop watching after successful load
                  console.log('✅ Carregamento concluído, parando watch');
                  isInitialCanvasHydrationDone.value = true;
                  isInitialDesignLoadDone.value = true;
                  if (stopWatchFn) stopWatchFn();
              } catch (err) {
                  console.error('❌ Error loading canvas data:', err);
                  isHistoryProcessing.value = false;
              } finally {
                  isCanvasJsonLoadInProgress = false;
              }
          } else {
              console.log('⏳ Aguardando projeto carregar...', { loaded, pagesLen, hasPage: !!page });
          }
      });
      }

    }
  } catch (e) {
    console.error("Failed to load fabric.js", e);
  }
})
onUnmounted(() => {
  isCanvasJsonLoadInProgress = false;
  isDesignLoading.value = false
  if (imageProgressRafId !== null && typeof window !== 'undefined') {
    cancelAnimationFrame(imageProgressRafId)
    imageProgressRafId = null
  }
  activeImageLoadTracker = null
  designLoadImageProgress.value = null
  if (canvasObjectsRefreshTimer) {
    clearTimeout(canvasObjectsRefreshTimer);
    canvasObjectsRefreshTimer = null;
  }
  if (canvasObjectsRefreshRafId !== null && typeof window !== 'undefined') {
    cancelAnimationFrame(canvasObjectsRefreshRafId);
    canvasObjectsRefreshRafId = null;
  }
  canvasObjectsRefreshPendingSource = null;
  if (viewportCullTimer) {
    clearTimeout(viewportCullTimer);
    viewportCullTimer = null;
  }
  if (viewportCullRafId !== null && typeof window !== 'undefined') {
    cancelAnimationFrame(viewportCullRafId);
    viewportCullRafId = null;
  }
  if (frameLabelUpdateTimer) {
    clearTimeout(frameLabelUpdateTimer);
    frameLabelUpdateTimer = null;
  }
  if (missingProductImageRecoveryTimer) {
    clearTimeout(missingProductImageRecoveryTimer)
    missingProductImageRecoveryTimer = null
  }
  if (cancelPendingCoalescedSave) {
    cancelPendingCoalescedSave()
    cancelPendingCoalescedSave = null
  }
  if (teardownHistoryListeners) {
    teardownHistoryListeners()
    teardownHistoryListeners = null
  }
  flushPersistenceNow('unmount', { force: true });
  if (globalStylesSaveTimer) {
    clearTimeout(globalStylesSaveTimer);
    globalStylesSaveTimer = null;
  }
  if (viewportStateSaveTimer) {
    clearTimeout(viewportStateSaveTimer);
    viewportStateSaveTimer = null;
  }
  cancelAutoSave();
  isCanvasDestroyed.value = true;
  document.removeEventListener('fullscreenchange', handleFullscreenChange)
  window.removeEventListener('resize', resizeCanvas);
  window.removeEventListener('keydown', handleKeyDown);
  if (globalEscKeyHandler) {
    window.removeEventListener('keydown', globalEscKeyHandler);
    globalEscKeyHandler = null;
  }
  if (globalKeyUpHandler) {
    window.removeEventListener('keyup', globalKeyUpHandler);
    globalKeyUpHandler = null;
  }
  isSpacePanPressed = false;
  keyboardNudgeDirty = false;
    if (wrapperResizeObserver) {
        try {
            wrapperResizeObserver.disconnect();
        } catch (e) {
            // ignore
        }
        wrapperResizeObserver = null;
    }
  // ESC handler cleanup is handled by Vue's cleanup
    if (domCanvasDblClickHandler && canvas.value?.upperCanvasEl) {
        try {
            canvas.value.upperCanvasEl.removeEventListener('dblclick', domCanvasDblClickHandler as any);
        } catch (e) {
            // ignore
        }
        domCanvasDblClickHandler = null;
    }
  if (canvas.value?.upperCanvasEl) {
    try {
      if (domCanvasTouchStartHandler) {
        canvas.value.upperCanvasEl.removeEventListener('touchstart', domCanvasTouchStartHandler as any);
      }
      if (domCanvasTouchMoveHandler) {
        canvas.value.upperCanvasEl.removeEventListener('touchmove', domCanvasTouchMoveHandler as any);
      }
      if (domCanvasTouchEndHandler) {
        canvas.value.upperCanvasEl.removeEventListener('touchend', domCanvasTouchEndHandler as any);
      }
      if (domCanvasTouchCancelHandler) {
        canvas.value.upperCanvasEl.removeEventListener('touchcancel', domCanvasTouchCancelHandler as any);
      }
    } catch (e) {
      // ignore
    }
  }
  domCanvasTouchStartHandler = null;
  domCanvasTouchMoveHandler = null;
  domCanvasTouchEndHandler = null;
  domCanvasTouchCancelHandler = null;
  if (globalMouseUpHandler) {
    window.removeEventListener('mouseup', globalMouseUpHandler);
    globalMouseUpHandler = null;
  }
  if (teardownSnapping) {
    teardownSnapping();
    teardownSnapping = null;
  }
  if (canvas.value) {
    const canvasToDispose = canvas.value;
    canvas.value = null;
    canvasToDispose.dispose();
  }
})

// --- History & Keyboard ---
// Ensure function is hoisted or accessible for updateObjectProperty
type SaveStateOptions = {
    allowEmptyOverwrite?: boolean;
    forceEmptyOverwrite?: boolean;
    reason?: string;
    source?: 'user' | 'system';
    skipIfUnchanged?: boolean;
    expectedPageId?: string;
    skipCoalesce?: boolean;
};

let saveCurrentState: (opts?: SaveStateOptions) => void | Promise<void> = () => {}; 
let cancelPendingCoalescedSave: (() => void) | null = null;
let teardownHistoryListeners: (() => void) | null = null;
const applyViewportTransform = (vpt: number[]) => {
    if (!canvas.value) return;
    canvas.value.setViewportTransform([...vpt]);
    updateZoomState();
    updateScrollbars();
    canvas.value.requestRenderAll();
};

const clearCanvasForPageSwitch = (canvasInstance: any) => {
    if (!canvasInstance) return
    try {
        canvasInstance.discardActiveObject?.()
        canvasInstance.clear()
        return
    } catch (err) {
        console.warn('⚠️ clear() falhou no page switch, tentando remoção manual:', err)
    }

    try {
        const allObjects = Array.isArray(canvasInstance.getObjects?.()) ? [...canvasInstance.getObjects()] : []
        for (let i = allObjects.length - 1; i >= 0; i--) {
            try {
                canvasInstance.remove(allObjects[i])
            } catch {
                // ignore object-specific remove failures
            }
        }
        canvasInstance.requestRenderAll?.()
    } catch (manualErr) {
        console.error('❌ Falha ao limpar canvas no page switch:', manualErr)
    }
}

const CANVAS_CUSTOM_PROPS = [
    // Identity / selection
    'id',
    '_customId',
    'name',
    'layerName',
    'excludeFromExport',
    // User guides (persistent)
    'isUserGuide',
    'guideAxis',

    // Frames
    'isFrame',
    'clipContent',
    'parentFrameId',
    '_frameClipOwner',
    'objectMaskEnabled',
    'objectMaskSourceId',

    // Grid cells (Canva-style grids = multiple frames linked by gridGroupId)
    'isGridCell',
    'gridGroupId',
    'gridCol',
    'gridRow',

    // Smart objects / cards
    'isSmartObject',
    'isProductCard',
    'smartGridId',
    'parentZoneId',
    '_zoneOrder',
    '_cardWidth',
    '_cardHeight',
    '_productData',
    'imageUrl',
    'subTargetCheck',
    'interactive',
    // When true on a child object, prevents auto-layout from overriding user placement (persisted).
    '__manualTransform',
	    '__manualTransformCardW',
	    '__manualTransformCardH',
	    '__manualTextWidth',
	    '__manualTextWidthRatio',
	    '__priceLayoutSnapshot',
	    '__priceLayoutSnapshotAt',
	    '__atacValueVariants',
	    '__atacVariantGroups',
	    '__preserveManualLayout',
	    '__isCustomTemplate',
	    '__forceAtacarejoCanonical',
	    '__manualTemplateBaseW',
	    '__manualTemplateBaseH',
	    '__manualGapSingle',
	    '__manualGapRetail',
	    '__manualGapWholesale',
	    '__fontScale',
	    '__fontScaleBase',
	    '__yOffsetRatio',
	    '__strokeWidth',
	    '__roundness',
	    '__shadowBlur',
	    '__originalWidth',
	    '__originalHeight',
	    '__originalFontSize',
	    '__originalLeft',
	    '__originalTop',
	    '__originalOriginX',
	    '__originalOriginY',
	    '__originalScaleX',
	    '__originalScaleY',
	    '__originalRadius',
	    '__originalRx',
	    '__originalRy',
	    '__originalStrokeWidth',

    // Product zone metadata
    'isGridZone',
    'isProductZone',
    '_zoneWidth',
    '_zoneHeight',
    '_zonePadding',
    '_zoneGlobalStyles',
    '_zoneTemplateSnapshotId',
    '_zoneTemplateSnapshot',
    'backgroundColor', // Zone background color
    'gapHorizontal',
    'gapVertical',
    'columns',
    'rows',
    'cardAspectRatio',
    'lastRowBehavior',
    'layoutDirection',
    'verticalAlign',
    'highlightCount',
    'highlightPos',
    'highlightHeight',

    // Price mode engine
    'priceMode',
    'priceFrom',
    'priceClub',
    'priceWholesale',
    'wholesaleTrigger',
    'wholesaleTriggerUnit',
    'packQuantity',
    'packUnit',
    'packageLabel',

    // Shape utilities (Figma-like)
    '__fillEnabled',
    '__fillBackup',
    '__strokeEnabled',
    '__strokeBackup',
    '__strokeWidthBackup',
    '__strokeDashBackup',
    'cornerRadii',
    
	    // Vector Path properties
	    'isVectorPath',
	    'isClosedPath',
	    'penPathData',
	    'strokePosition',
	    'strokeMiterLimit',

		// Sticker Outline (alpha-based contour)
		'__stickerOutlineEnabled',
		'__stickerOutlineMode',
		'__stickerOutlineWidth',
		'__stickerOutlineColor',
		'__stickerOutlineOpacity',
		'__stickerNoTransparency',

	// Images: ensure CORS behavior survives reload (needed for pixel-based effects like Sticker Outline)
	'crossOrigin',
    '__originalSrc',

    // Locks (persist cadeado state across reload)
    'lockMovementX',
    'lockMovementY',
    'lockScalingX',
    'lockScalingY',
    'lockRotation',
    'lockScalingFlip'
] as const;

// Helper function to extract key/path from Wasabi URL (presigned or permanent)
const extractWasabiKey = (url: string): string | null => {
    try {
        // CRITICAL: Decode URL first to handle encoded characters
        const decodedUrl = decodeURIComponent(url);
        const urlObj = new URL(decodedUrl);

        // Formatos Wasabi:
        // - Path-style: https://s3.wasabisys.com/bucket/key...
        //
        // OBS: a "key" é SEMPRE o caminho completo do objeto no bucket (ex.: projects/{userId}/...)

        // Decode pathname as well to handle any encoded characters
        const decodedPathname = decodeURIComponent(urlObj.pathname);
        const pathParts = decodedPathname.split('/').filter(p => p);
        console.log(`🔍 extractWasabiKey - URL: ${url.substring(0, 100)}...`);
        console.log(`   decodedUrl: ${decodedUrl.substring(0, 100)}...`);
        console.log(`   pathname: ${decodedPathname}`);
        console.log(`   pathParts: [${pathParts.join(', ')}]`);

        if (pathParts.length === 0) {
            console.warn(`⚠️ Não foi possível extrair chave da URL (path vazio): ${url.substring(0, 100)}`);
            return null;
        }

        const cfg = useRuntimeConfig()?.public?.wasabi || {};
        const configuredBucket = (cfg.bucket || 'jobvarejo').toString();

        console.log(`   configuredBucket: ${configuredBucket}`);

        const hostname = (urlObj.hostname || '').toLowerCase();
        const first = pathParts[0] ?? '';
        // Check if first part is bucket
        const firstLooksLikeBucket = first === configuredBucket || first.includes(':');
        const hostLooksLikeVirtualHost = hostname.includes(`${configuredBucket.toLowerCase()}.`);

        console.log(`   first: ${first}`);
        console.log(`   firstLooksLikeBucket: ${firstLooksLikeBucket}`);
        console.log(`   hostLooksLikeVirtualHost: ${hostLooksLikeVirtualHost}`);

        // Path-style: primeira parte do path é bucket → remover
        // Virtual-host: host já contém bucket → NÃO remover nada do path
        const keyParts = (firstLooksLikeBucket && !hostLooksLikeVirtualHost) ? pathParts.slice(1) : pathParts;
        const key = keyParts.join('/');

        console.log(`   keyParts: [${keyParts.join(', ')}]`);
        console.log(`   key extraída: ${key}`);

        if (!key || key.length === 0) {
            console.warn(`⚠️ Chave extraída está vazia da URL: ${url.substring(0, 100)}`);
            return null;
        }
        return key;
    } catch (err) {
        console.error(`❌ Erro ao extrair chave da URL: ${url.substring(0, 100)}`, err);
        return null;
    }
};

// Helper function to convert presigned URL to permanent URL (Wasabi)
const convertPresignedToPermanentUrl = (url: string): string => {
    // If it's not a Wasabi URL, return as-is
    if (!url.includes('wasabisys.com')) {
        return url;
    }

    // If it's already a permanent URL (no query params), return as-is
    try {
        const urlObj = new URL(url);
        if (!urlObj.search) {
            console.log(`🔗 URL já é permanente (sem query params): ${url.substring(0, 80)}...`);
            return url;
        }

        // Extract key from presigned URL
        const key = extractWasabiKey(url);
        if (!key) {
            console.warn(`⚠️ Não foi possível extrair key da URL presignada: ${url.substring(0, 100)}`);
            return url; // Can't extract key, return original
        }

        // Build permanent URL for Wasabi
        const config = useRuntimeConfig().public?.wasabi || {};
        const endpoint = config.endpoint || 's3.wasabisys.com';
        const bucket = config.bucket || 'jobvarejo';
        const permanentUrl = `https://${endpoint}/${bucket}/${key}`;
        console.log(`🔄 Convertendo presigned → permanent (Wasabi):`);
        console.log(`   De: ${url.substring(0, 100)}...`);
        console.log(`   Para: ${permanentUrl.substring(0, 100)}...`);
        console.log(`   Key extraída: ${key}`);
        return permanentUrl;
    } catch (err) {
        console.error(`❌ Erro ao converter URL presignada para permanente:`, err);
        return url; // Error parsing, return original
    }
};

// Helper function to generate new presigned URL from permanent URL or key
const generatePresignedUrl = async (urlOrKey: string): Promise<string | null> => {
    try {
        // If it's already a presigned URL, extract key and generate new one
        let key: string | null = null;
        
        console.log(`🔑 generatePresignedUrl chamada com: ${urlOrKey.substring(0, 100)}...`);

        if (urlOrKey.includes('wasabisys.com')) {
            key = extractWasabiKey(urlOrKey);
            console.log(`   Key extraída da URL Wasabi: ${key || '(null)'}`);
        } else {
            // Assume it's already a key
            key = urlOrKey;
            console.log(`   Usando como key diretamente: ${key}`);
        }
        
        if (!key) {
            console.error(`❌ Não foi possível obter key para gerar URL presignada`);
            return null;
        }
        
        // Request new presigned URL from backend
        console.log(`📤 Requisitando presigned URL do backend para key: ${key}`);
        const headers = await getApiAuthHeaders();
        const data = await $fetch<{ url?: string }>('/api/storage/presigned', {
            method: 'POST',
            headers,
            body: { key, contentType: 'image/*', operation: 'get' }
        });
        
        if (data?.url) {
            console.log(`✅ Presigned URL gerada com sucesso: ${data.url.substring(0, 100)}...`);
        } else {
            console.error(`❌ Backend retornou resposta sem URL:`, data);
        }
        
        return data?.url || null;
    } catch (error) {
        console.error('❌ Erro ao gerar URL presignada:', error);
        return null;
    }
};

// 1x1 transparent PNG data URL - usado quando imagem falha para permitir carregar o resto do canvas
const PLACEHOLDER_IMAGE_DATA_URL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

/**
 * Decodifica URLs da Contabo que têm %3A (colon codificado) no bucket name.
 * A Contabo retorna erro 500 quando o bucket name tem %3A em vez de :.
 * Formato: https://endpoint/tenant%3Abucket/key -> https://endpoint/tenant:bucket/key
 */
const decodeContaboUrls = (canvasData: any): any => {
    const cloned = JSON.parse(JSON.stringify(canvasData));
    if (!cloned?.objects || !Array.isArray(cloned.objects)) return cloned;

    let count = 0;
    const processObject = (obj: any): void => {
        if (!obj) return;
        const objType = (obj.type || '').toLowerCase();
        if (objType === 'image' && typeof obj.src === 'string' && obj.src.includes('contabostorage.com')) {
            // Check if URL has encoded colon in bucket name
            if (obj.src.includes('%3A')) {
                try {
                    const urlObj = new URL(obj.src);
                    // Decode only the pathname (bucket/key), not query params
                    urlObj.pathname = decodeURIComponent(urlObj.pathname);
                    obj.src = urlObj.toString();
                    count++;
                } catch (e) {
                    // Fallback: simple replace for the bucket portion only
                    // Match pattern: /tenant%3Abucket/ and decode it
                    obj.src = obj.src.replace(/\/([^\/]+)%3A([^\/]+)\//, (match: string, tenant: string, bucket: string) => {
                        return `/${tenant}:${bucket}/`;
                    });
                    count++;
                }
            }
        }
        if (obj.objects && Array.isArray(obj.objects)) {
            obj.objects.forEach((child: any) => processObject(child));
        }
    };

    cloned.objects.forEach((obj: any) => processObject(obj));
    if (count > 0) console.log(`🔧 Decodificado ${count} URL(s) da Contabo (%3A -> :)`);
    return cloned;
};

/**
 * Extrai bucket e key de uma URL da Contabo.
 */
const extractContaboBucketAndKey = (url: string): { bucket: string | null; key: string | null } => {
    try {
        const decodedUrl = decodeURIComponent(url);
        const urlObj = new URL(decodedUrl);
        const decodedPathname = decodeURIComponent(urlObj.pathname);
        const pathParts = decodedPathname.split('/').filter(p => p);

        if (pathParts.length === 0) {
            return { bucket: null, key: null };
        }

        const cfg = (useRuntimeConfig()?.public?.contabo as any) || {};
        const configuredBucket = (cfg.bucket || '475a29e42e55430abff00915da2fa4bc:jobupload').toString();
        const candidates = new Set<string>();
        if (configuredBucket) candidates.add(configuredBucket);

        const first = pathParts[0] ?? '';
        // Check if first part is bucket (may have : or match configured buckets)
        const firstLooksLikeBucket = first.includes(':') || candidates.has(first);
        const hostLooksLikeVirtualHost = [...candidates].some(b => b && urlObj.hostname.startsWith(`${b.toLowerCase()}.`));

        // Path-style: primeira parte do path é bucket/tenant:bucket → extrair bucket
        // Virtual-host: host já contém bucket → usar bucket configurado
        let bucket: string | null = null;
        let keyParts: string[];

        if (firstLooksLikeBucket && !hostLooksLikeVirtualHost) {
            bucket = first;
            keyParts = pathParts.slice(1);
        } else if (hostLooksLikeVirtualHost) {
            // Extrair bucket do hostname (virtual-host style)
            const hostParts = urlObj.hostname.split('.');
            bucket = hostParts[0] || null;
            keyParts = pathParts;
        } else {
            // Usar bucket padrão
            bucket = null; // Deixa o proxy usar o padrão
            keyParts = pathParts;
        }

        const key = keyParts.join('/');

        if (!key || key.length === 0) {
            return { bucket: null, key: null };
        }

        return { bucket, key };
    } catch (err) {
        console.error(`❌ Erro ao extrair bucket e key da URL: ${url.substring(0, 100)}`, err);
        return { bucket: null, key: null };
    }
};

/**
 * Extrai bucket e key de uma URL do Wasabi S3.
 * Formato esperado: https://s3.wasabisys.com/bucket/key...
 */
const extractWasabiBucketAndKey = (url: string): { bucket: string | null; key: string | null } => {
    try {
        const urlObj = new URL(url);
        const pathParts = urlObj.pathname.split('/').filter(p => p);

        if (pathParts.length === 0) {
            return { bucket: null, key: null };
        }

        // Wasabi path-style: /bucket/key...
        const bucket = pathParts[0] || null;
        const key = pathParts.slice(1).join('/');

        if (!key || key.length === 0) {
            return { bucket: null, key: null };
        }

        return { bucket, key };
    } catch (err) {
        console.error(`❌ Erro ao extrair bucket e key da URL Wasabi: ${url.substring(0, 100)}`, err);
        return { bucket: null, key: null };
    }
};

/**
 * Converte URLs da Contabo/Wasabi para usar o proxy local.
 * Isso evita problemas com URLs presignadas, encoding de caracteres especiais e CORS.
 * O proxy busca a imagem diretamente do S3 no backend, sem problemas de assinatura.
 */
const cloneCanvasDataForLoad = (canvasData: any): any => {
    try {
        return JSON.parse(JSON.stringify(canvasData));
    } catch {
        return canvasData;
    }
};

const walkCanvasObjects = (root: any, visitor: (obj: any) => void): void => {
    if (!root || typeof root !== 'object') return;
    const stack: any[] = Array.isArray(root.objects) ? [...root.objects] : [];
    while (stack.length > 0) {
        const node = stack.pop();
        if (!node || typeof node !== 'object') continue;
        visitor(node);
        if (Array.isArray(node.objects) && node.objects.length) {
            for (let i = node.objects.length - 1; i >= 0; i--) {
                stack.push(node.objects[i]);
            }
        }
    }
};

const mapLimit = async <T>(
    items: T[],
    concurrency: number,
    worker: (item: T, index: number) => Promise<void>
): Promise<void> => {
    const limit = Math.max(1, Math.floor(concurrency || 1));
    let cursor = 0;
    const runWorker = async () => {
        while (true) {
            const index = cursor++;
            if (index >= items.length) return;
            await worker(items[index] as T, index);
        }
    };
    const tasks = Array.from({ length: Math.min(limit, items.length) }, () => runWorker());
    await Promise.all(tasks);
};

const collectContaboImageNodes = (canvasData: any): any[] => {
    const images: any[] = [];
    walkCanvasObjects(canvasData, (node) => {
        const src = String(node?.src || '');
        if (String(node?.type || '').toLowerCase() !== 'image') return;
        if (!src) return;
        if (!src.includes('contabostorage.com') && !src.includes('usc1.contabostorage.com')) return;
        images.push(node);
    });
    return images;
};

const refreshContaboUrlsInCanvasData = async (
    canvasData: any,
    opts: { concurrency?: number } = {}
): Promise<{ total: number; refreshed: number; failed: number }> => {
    const images = collectContaboImageNodes(canvasData);
    if (!images.length) return { total: 0, refreshed: 0, failed: 0 };

    const concurrency = Math.max(1, Number(opts.concurrency || 6));
    let refreshed = 0;
    let failed = 0;

    console.log(`🔄 Gerando novas URLs presignadas para ${images.length} imagem(ns)...`);
    await mapLimit(images, concurrency, async (imgObj) => {
        try {
            const result = extractContaboBucketAndKey(String(imgObj?.src || ''));
            const key = result?.key;
            if (!key) {
                console.warn(`⚠️ Não foi possível extrair chave da URL: ${String(imgObj?.src || '').substring(0, 80)}...`);
                if (!imgObj.__originalSrc) {
                    imgObj.__originalSrc = String(imgObj?.src || '');
                }
                imgObj.src = PLACEHOLDER_IMAGE_DATA_URL;
                failed++;
                return;
            }

            const newUrl = await generatePresignedUrl(key);
            if (newUrl) {
                imgObj.src = newUrl;
                refreshed++;
            } else {
                console.error(`❌ Falha ao gerar URL presignada para: ${key.substring(0, 50)}...`);
                if (!imgObj.__originalSrc) {
                    imgObj.__originalSrc = String(imgObj?.src || '');
                }
                imgObj.src = PLACEHOLDER_IMAGE_DATA_URL;
                failed++;
            }
        } catch (err) {
            console.error('❌ Erro ao gerar URL presignada:', err);
            console.error(`   URL original: ${String(imgObj?.src || '').substring(0, 100)}`);
            if (!imgObj.__originalSrc) {
                imgObj.__originalSrc = String(imgObj?.src || '');
            }
            imgObj.src = PLACEHOLDER_IMAGE_DATA_URL;
            failed++;
        }
    });

    return { total: images.length, refreshed, failed };
};

const convertContaboToProxyUrls = (canvasData: any, opts: { clone?: boolean } = {}): any => {
    const cloned = opts.clone === false ? canvasData : cloneCanvasDataForLoad(canvasData);
    if (!cloned || typeof cloned !== 'object') return cloned;

    let contaboCount = 0;
    let wasabiCount = 0;
    walkCanvasObjects(cloned, (node) => {
        const objType = String(node.type || '').toLowerCase();
        if (objType === 'image' && !node.crossOrigin) {
            // Keep consistent CORS mode for Fabric image processing.
            node.crossOrigin = 'anonymous';
        }

        if (typeof node.src === 'string' && node.src.trim()) {
            const src = node.src;
            if (!node.__originalSrc) {
                node.__originalSrc = src;
            }
            const wasabiProxy = toWasabiProxyUrl(src);

            if (wasabiProxy && wasabiProxy !== src) {
                node.src = wasabiProxy;
                wasabiCount++;
            } else if (src.includes('contabostorage.com')) {
                const { bucket, key } = extractContaboBucketAndKey(src);
                if (key) {
                    if (bucket) node.src = `/api/storage/p?bucket=${encodeURIComponent(bucket)}&key=${encodeURIComponent(key)}`;
                    else node.src = `/api/storage/p?key=${encodeURIComponent(key)}`;
                    contaboCount++;
                }
            }
        }
    });
    if (contaboCount > 0) console.log(`🔄 Convertido ${contaboCount} URL(s) da Contabo para proxy local`);
    if (wasabiCount > 0) console.log(`🔄 Convertido ${wasabiCount} URL(s) do Wasabi para proxy local`);
    return cloned;
};

const prepareCanvasDataForLoad = (raw: any): any => {
    try {
        let out = cloneCanvasDataForLoad(raw);
        out = replaceBlobImagesWithPlaceholder(out, { clone: false });
        out = convertContaboToProxyUrls(out, { clone: false });
        return out;
    } catch {
        return raw;
    }
}

/**
 * Substitui src de imagens blob: (sessão/local) por placeholder.
 * Blob URLs não sobrevivem ao reload, então quebram o loadFromJSON.
 */
const replaceBlobImagesWithPlaceholder = (canvasData: any, opts: { clone?: boolean } = {}): any => {
    const cloned = opts.clone === false ? canvasData : cloneCanvasDataForLoad(canvasData);
    if (!cloned?.objects || !Array.isArray(cloned.objects)) return cloned;

    let count = 0;
    walkCanvasObjects(cloned, (obj) => {
        const objType = (obj.type || '').toLowerCase();
        if (objType === 'image' && typeof obj.src === 'string' && obj.src.startsWith('blob:')) {
            obj.src = PLACEHOLDER_IMAGE_DATA_URL;
            count++;
        }
    });
    if (count > 0) console.warn(`⚠️ Substituindo ${count} imagem(ns) blob por placeholder (URL temporária)`);
    return cloned;
};

const isPotentiallyBrokenRemoteImageSrc = (src: string): boolean => {
    const value = String(src || '').trim().toLowerCase();
    if (!value) return false;
    if (value.startsWith('data:')) return false;
    if (value.startsWith('blob:')) return true;
    if (value.includes('contabostorage.com')) return true;
    if (value.includes('wasabisys.com')) return true;
    if (value.includes('/api/storage/proxy')) return true;
    if (value.includes('/api/storage/p')) return true;
    if (value.startsWith('http://') || value.startsWith('https://')) return true;
    return false;
};

/**
 * Substitui src de imagens remotas por placeholder para permitir loadFromJSON
 * quando URLs expiraram/foram removidas (proxy 404, Contabo, Wasabi etc.).
 * Preserva layout e processa grupos aninhados recursivamente.
 */
const replaceContaboImagesWithPlaceholder = (canvasData: any, opts: { clone?: boolean } = {}): any => {
    const cloned = opts.clone === false ? canvasData : cloneCanvasDataForLoad(canvasData);
    if (!cloned?.objects || !Array.isArray(cloned.objects)) return cloned;
    
    let count = 0;
    walkCanvasObjects(cloned, (obj) => {
        const objType = (obj.type || '').toLowerCase();
        
        // Se é uma imagem remota potencialmente quebrada, substituir pelo placeholder
        if (
            objType === 'image' &&
            typeof obj.src === 'string' &&
            isPotentiallyBrokenRemoteImageSrc(obj.src)
        ) {
            if (!obj.__originalSrc) {
                obj.__originalSrc = obj.src;
            }
            obj.src = PLACEHOLDER_IMAGE_DATA_URL;
            count++;
        }
    });
    
    if (count > 0) console.warn(`⚠️ Substituindo ${count} imagem(ns) remota(s) por placeholder`);
    return cloned;
};

const removeImageObjectsDeep = (node: any): any => {
    if (!node || typeof node !== 'object') return node;
    if (Array.isArray(node.objects)) {
        node.objects = node.objects
            .filter((child: any) => String(child?.type || '').toLowerCase() !== 'image')
            .map((child: any) => removeImageObjectsDeep(child));
    }
    return node;
};

	const setupHistory = () => {
	    if (!canvas.value) return;
        if (teardownHistoryListeners) {
            teardownHistoryListeners()
            teardownHistoryListeners = null
        }
        if (cancelPendingCoalescedSave) {
            cancelPendingCoalescedSave()
            cancelPendingCoalescedSave = null
        }
	    let lastThumbnailAt = 0;
    let thumbnailTicket = 0;
    let lastHotSaveSanitizeAt = 0;
    let pendingCoalescedSaveTimer: ReturnType<typeof setTimeout> | null = null;
    let pendingCoalescedSaveOpts: SaveStateOptions | null = null;
    let pendingCoalescedSavePageId = '';
    let invokeSaveStateSafely: (opts?: SaveStateOptions) => void = () => {};
    const clearPendingCoalescedSave = () => {
        if (pendingCoalescedSaveTimer) {
            clearTimeout(pendingCoalescedSaveTimer)
            pendingCoalescedSaveTimer = null
        }
        pendingCoalescedSaveOpts = null
        pendingCoalescedSavePageId = ''
    }
    cancelPendingCoalescedSave = clearPendingCoalescedSave;

    const resolvePageIndexById = (pageId: string): number => {
        return findPageIndexById(project.pages, pageId, Number(project.activePageIndex || 0))
    }

	    const saveState = async (opts: SaveStateOptions = {}) => {
	        if (isHistoryProcessing.value) return; // Prevent loop
	        const canvasInstance = canvas.value as any;
	        if (!canvasInstance || isCanvasDestroyed.value) return;
	        // Prevent cross-page contamination: while the editor is switching/loading pages,
	        // ignore user-triggered saves (timers, debounced handlers). System saves used by
	        // the loader itself always pass `source: 'system'` and/or an expectedPageId.
	        const src = (opts.source || 'user') as any;
	        if (isDesignLoading.value && src !== 'system') {
	            return;
	        }
	        const saveReason = String(opts.reason || 'unknown');
	        const expectedPageId = String(opts.expectedPageId || '').trim();
	        const targetPageId = expectedPageId || getActiveProjectPageId();
	        if (!targetPageId) return;
        const isTargetPageActive = () => getActiveProjectPageId() === targetPageId;
        if (expectedPageId && !isTargetPageActive()) {
            return;
        }
        const targetPageIndexStart = resolvePageIndexById(targetPageId);
        if (targetPageIndexStart < 0) {
            return;
        }
        if (expectedPageId) {
            const activeNowId = getActiveProjectPageId();
            if (!activeNowId || activeNowId !== expectedPageId) {
                return
            }
        }
        const liveObjectCount = Number(canvasInstance?.getObjects?.()?.length || 0)
        const coalesceDelayMs = opts.skipCoalesce
            ? 0
            : getAdaptiveCoalesceDelayMs(saveReason, liveObjectCount)
        if (coalesceDelayMs > 0) {
            pendingCoalescedSaveOpts = { ...opts }
            pendingCoalescedSavePageId = getActiveProjectPageId()
            if (!pendingCoalescedSaveTimer) {
                pendingCoalescedSaveTimer = setTimeout(() => {
                    pendingCoalescedSaveTimer = null
                    const nextOpts = pendingCoalescedSaveOpts
                        ? { ...pendingCoalescedSaveOpts, skipCoalesce: true }
                        : { reason: saveReason, source: opts.source, skipCoalesce: true }
                    pendingCoalescedSaveOpts = null
                    if (pendingCoalescedSavePageId && !nextOpts.expectedPageId) {
                        nextOpts.expectedPageId = pendingCoalescedSavePageId
                    }
                    pendingCoalescedSavePageId = ''
                    invokeSaveStateSafely(nextOpts)
                }, coalesceDelayMs)
            }
            return
        }

        // Don't persist transient geometry while the user is still in a brusque transform.
        // Keeping the previous stable snapshot is safer than saving an in-flight state.
        if (shouldSkipLifecycleSave(saveReason, lastTransformMutationAt)) {
            console.warn(`[saveState] Pulando flush de lifecycle durante transformação ativa (${saveReason})`);
            return;
        }

        const shouldRunHeavySanitize = shouldRunHeavySanitizeForReason(saveReason);
        restoreMissingManualTemplateFlagsInCanvas(canvasInstance, `saveState:${saveReason}`);
        if (shouldRunHeavySanitize) {
            sanitizeCanvasObjectStack(canvasInstance, `saveState:${saveReason}`);
            stabilizePriceGroupsForPersistence(canvasInstance, `saveState:${saveReason}`);
            lastHotSaveSanitizeAt = Date.now();
        } else if ((Date.now() - lastHotSaveSanitizeAt) > 1200) {
            sanitizeCanvasObjectStack(canvasInstance, `saveState:${saveReason}:throttled`);
            lastHotSaveSanitizeAt = Date.now();
        }

        // CRITICAL: Don't push/save empty canvas if the page already has data.
        // This can happen during transient clears (page switch/load) and it pollutes undo history
        // (Ctrl/Cmd+Z appears to "black screen" by undoing to an empty state).
        if (targetPageIndexStart >= 0 && project.pages.length > targetPageIndexStart && project.pages[targetPageIndexStart]) {
            const currentPage = project.pages[targetPageIndexStart];
            const existingObjectCount = currentPage?.canvasData?.objects?.length || 0;
            const liveObjectCount = canvasInstance?.getObjects?.()?.length || 0;
            // `allowEmptyOverwrite` is used by user-driven Fabric events; `forceEmptyOverwrite` is a hard override.
            // We intentionally do NOT allow system saves to bypass this guard (prevents page-switch wipe).
            const allowEmptyOverwrite = canAllowEmptyOverwrite({
                forceEmptyOverwrite: opts.forceEmptyOverwrite,
                allowEmptyOverwrite: opts.allowEmptyOverwrite,
                source: opts.source
            });
            // Data-loss guard:
            // never overwrite a non-empty saved page with an empty runtime snapshot
            // unless this was an explicit forced empty-save operation.
            if (liveObjectCount === 0 && existingObjectCount > 0 && !allowEmptyOverwrite) {
                console.warn(
                    `⚠️ Pulando salvamento vazio para evitar perda de dados: canvas está vazio (${liveObjectCount}) mas página já tinha ${existingObjectCount} objetos`,
                    { pageIndex: targetPageIndexStart, reason: opts.reason || 'unspecified', pageId: targetPageId }
                );
                return;
            }
        }
        if (!isTargetPageActive()) {
            return;
        }
        
        const { canvasFrames } = prepareCanvasForSerialization({
            canvasInstance,
            isValidFabricCanvasObject,
            ensurePersistentContentFlags,
            ensureObjectPersistentId
        })
        safeRequestRenderAll();
        
        // Serialize with custom props
        let json: any
        try {
            json = canvasInstance.toJSON([...CANVAS_CUSTOM_PROPS]);
        } catch (serializeErr: any) {
            const serializeMsg = String(serializeErr?.message || serializeErr || '').toLowerCase()
            const isRecoverableSerializationError = serializeMsg.includes('toobject is not a function')
            if (!isRecoverableSerializationError) throw serializeErr

            console.warn(`[saveState] Falha na serialização (${saveReason}). Tentando recuperação...`, serializeErr)
            const removed = sanitizeCanvasObjectStack(canvasInstance, `saveState:${saveReason}:serialize-retry`)
            try {
                const liveObjects = canvasInstance?.getObjects?.() || []
                liveObjects.forEach((obj: any) => clearInvalidClipPath(obj, true))
            } catch {
                // ignore cleanup failures
            }

            try {
                json = canvasInstance.toJSON([...CANVAS_CUSTOM_PROPS]);
            } catch (retryErr: any) {
                const retryMsg = String(retryErr?.message || retryErr || '').toLowerCase()
                const isRetryRecoverable = retryMsg.includes('toobject is not a function')
                if (!isRetryRecoverable) throw retryErr

                console.warn(`[saveState] Segunda tentativa de serialização falhou (${saveReason}). Aplicando limpeza forte...`, retryErr)
                const removedSecondPass = sanitizeCanvasObjectStack(canvasInstance, `saveState:${saveReason}:serialize-retry-2`)
                try {
                    const topLevelObjects = canvasInstance?.getObjects?.() || []
                    topLevelObjects.forEach((obj: any) => {
                        if (!isValidFabricCanvasObject(obj)) {
                            try { canvasInstance.remove(obj) } catch { /* ignore */ }
                        }
                    })
                } catch {
                    // ignore hard cleanup failures
                }

                try {
                    json = canvasInstance.toJSON([...CANVAS_CUSTOM_PROPS]);
                    console.warn(`[saveState] Serialização recuperada após limpeza forte (${removed + removedSecondPass} item(ns) saneados).`)
                } catch (finalErr: any) {
                    console.error(`[saveState] Não foi possível serializar estado após recuperação (${saveReason}). Mantendo último estado válido.`, finalErr)
                    return
                }
            }
            if (removed > 0) {
                console.warn(`[saveState] Serialização recuperada após remover ${removed} item(ns) inválido(s).`)
            }
        }
        finalizeSerializedCanvasJson({
            json,
            canvasInstance,
            canvasCustomProps: [...CANVAS_CUSTOM_PROPS],
            isValidFabricCanvasObject,
            transientControlNames: TRANSIENT_CONTROL_NAMES,
            convertPresignedToPermanentUrl,
            canvasFramesForDebug: canvasFrames
        });
        
        // Persist app-level metadata alongside Fabric JSON.
        (json as any)[LABEL_TEMPLATES_JSON_KEY] = serializeLabelTemplatesForProject();
        // Persist viewport (pan/zoom) so reload restores the exact view.
        const vpt = canvasInstance?.viewportTransform;
        setSavedViewportTransform(
            json as Record<string, unknown>,
            vpt,
            canvasInstance?.getZoom?.() || (Array.isArray(vpt) ? vpt[0] : 1)
        )
        const jsonStr = JSON.stringify(json);
        const currentFingerprint = fastHashString(jsonStr);
        const source = opts.source || 'user';
        const currentPage = targetPageIndexStart >= 0 ? project.pages?.[targetPageIndexStart] : null;
        if (shouldSkipByFingerprint({
            skipIfUnchanged: opts.skipIfUnchanged,
            lastSavedFingerprint: currentPage?.lastSavedFingerprint,
            currentFingerprint
        })) {
            return;
        }
        const historyAppend = appendHistoryEntry({
            historyStack: historyStack.value,
            historyIndex: historyIndex.value,
            entry: jsonStr,
            maxEntries: 50
        })
        if (!historyAppend.didAppend) {
            return;
        }
        historyStack.value = historyAppend.historyStack
        historyIndex.value = historyAppend.historyIndex

        const reason = String(opts.reason || '')
        const persistence = persistSerializedPageState({
            targetPageId,
            json,
            source,
            reason,
            currentFingerprint,
            pages: project.pages,
            resolvePageIndexById,
            updatePageData,
            shouldSkipAutoSave,
            triggerAutoSave
        })
        if (!persistence.didUpdate || persistence.targetPageIndex < 0) return

        if (canGenerateThumbnailNow({
            source,
            reason,
            lastThumbnailAt
        })) {
            const targetPageForThumb = persistence.targetPage
            const myTicket = ++thumbnailTicket
            const dataURL = await generateThumbnailFromCanvasJson({
                sourceJson: json,
                staticCanvasCtor: fabric?.StaticCanvas,
                pageWidth: Number(targetPageForThumb?.width || 0),
                pageHeight: Number(targetPageForThumb?.height || 0),
                defaultWidth: Number(activePage.value?.width || canvas.value?.getWidth?.() || 1080),
                defaultHeight: Number(activePage.value?.height || canvas.value?.getHeight?.() || 1920)
            })
            if (dataURL && myTicket === thumbnailTicket) {
                const latestPageIndex = resolvePageIndexById(targetPageId)
                if (latestPageIndex >= 0) {
                    updatePageThumbnail(latestPageIndex, dataURL)
                }
                lastThumbnailAt = Date.now()
            }
        }
    }
    
    invokeSaveStateSafely = (opts: SaveStateOptions = {}) => {
        const nextOpts: SaveStateOptions = { ...(opts || {}) };
        if (!nextOpts.expectedPageId) {
            const pageId = getActiveProjectPageId();
            if (pageId) nextOpts.expectedPageId = pageId;
        }
        void saveState(nextOpts).catch((err: any) => {
            console.error('❌ [saveState] Falha ao salvar estado:', err);
            if (canvas.value) sanitizeCanvasObjectStack(canvas.value as any, 'saveState-catch');
        });
    };

    // Export for external use
    saveCurrentState = invokeSaveStateSafely;

    // Capture initial state - only if canvas has objects OR page is new/empty
    const currentObjectCount = canvas.value.getObjects().length;
    const currentPage = project.pages[project.activePageIndex];
    const pageHasData = currentPage?.canvasData?.objects?.length > 0;

    // Only save initial state if canvas has objects, or if page is completely new (no existing data)
    if (currentObjectCount > 0 || !pageHasData) {
        invokeSaveStateSafely({ reason: 'initial-history-capture', source: 'system', skipIfUnchanged: true });
    } else {
        console.log('ℹ️ Pullando saveState inicial: canvas vazio mas página já tem dados');
    }

    const canvasInstanceForHistory = canvas.value
    if (!canvasInstanceForHistory) return

    teardownHistoryListeners = registerHistorySaveListeners({
        canvas: canvasInstanceForHistory,
        getCanvas: () => canvas.value,
        invalidateScrollbarBounds,
        invalidateContainmentZoneCache,
        updateScrollbars,
        isBulkProductMutation: () => !!isBulkProductMutation,
        isHistoryProcessing: () => !!isHistoryProcessing.value,
        isApplyingZoneUpdate: () => !!isApplyingZoneUpdate,
        getIsZoneCascadeDelete: () => !!isZoneCascadeDelete,
        setIsZoneCascadeDelete: (value: boolean) => {
            isZoneCascadeDelete = !!value
        },
        invokeSaveStateSafely,
        handleObjectModified,
        isLikelyProductZone,
        isLikelyProductCard
    })
}

// --- Sync Logic (Herd Effect) ---
const handleObjectModified = (e: any) => {
    const obj = e.target;
    if (!obj) return;
    const transformTarget = e?.transform?.target;
    const isChildImageTransformOnCard = !!(
        obj &&
        isLikelyProductCard(obj) &&
        transformTarget &&
        transformTarget !== obj &&
        transformTarget.group === obj &&
        String(transformTarget.type || '').toLowerCase() === 'image'
    );

    // Multi-selection: keep each member attached/contained and then relayout affected zones.
    if (isActiveSelectionObject(obj) && typeof obj.getObjects === 'function') {
        const members = (obj.getObjects() || []).slice();
        const affectedZones = new Map<string, any>();

        members.forEach((member: any) => {
            if (!member) return;

            if (shouldApplyContainmentConstraints(member)) {
                applyContainmentConstraints(member);
            }

            try { maybeReparentToFrameOnDrop(member); } catch {}
            try { syncObjectFrameClip(member); } catch {}

            const zoneId = String((member as any)?.parentZoneId || '').trim();
            if (!zoneId || !canvas.value) return;
            const zone = getContainmentZoneById(zoneId) || canvas.value.getObjects().find((o: any) => (
                isLikelyProductZone(o) && String((o as any)?._customId || '').trim() === zoneId
            ));
            if (!zone) return;
            applyCardFrameBinding(member, getResolvedZoneFrameId(zone));
            affectedZones.set(zoneId, zone);
        });

        affectedZones.forEach((zone: any) => {
            ensureZoneSanity(zone);
            recalculateZoneLayout(zone, getZoneChildren(zone), { save: false });
        });
        return;
    }

    // Scaling/cropping an image INSIDE the card should not trigger card reorder/zone relayout.
    if (isChildImageTransformOnCard) {
        return;
    }

    // 🔹 Normalizar scale de retângulos (Figma-style)
    // Converte scaleX/scaleY em width/height reais para evitar distorção de border-radius
    if (obj.type === 'rect') {
        normalizeRectScale(obj);
    }

    // 🔹 Normalizar scale de grupos que contêm retângulos
    // Smart objects, product cards, etc. são grupos com retângulos internos
    if (obj.type === 'group') {
        normalizeGroupRects(obj);
    }

    if (isLikelyProductZone(obj)) {
        // Cache children BEFORE any zone changes to prevent losing cards
        const cachedChildren = getZoneChildren(obj);
        syncZoneCardFrameBindings(obj, cachedChildren);
        ensureZoneSanity(obj);
        normalizeZoneScale(obj);
        recalculateZoneLayout(obj, cachedChildren, { save: false });
        return;
    }

    // Product zone: dragging a card reorders the grid (snap back into slots on drop).
    if ((obj.isSmartObject || obj.isProductCard || String(obj.name || '').startsWith('product-card') || isLikelyProductCard(obj)) && (obj as any).parentZoneId && canvas.value) {
        const zoneId = String((obj as any).parentZoneId || '').trim();
        const zone = getContainmentZoneById(zoneId) || canvas.value.getObjects().find((o: any) => isLikelyProductZone(o) && String(o?._customId || '').trim() === zoneId);
        if (zone) {
            ensureZoneSanity(zone);
            const cards = getZoneChildren(zone);
            if (cards.length > 0) {
                const action = String(e?.transform?.action || '');
                const didScale = action.includes('scale');
                const rawHighlightCount = Number((zone as any)?.highlightCount ?? 0);
                const highlightCount = Math.max(0, Math.min(cards.length, Math.round(Number.isFinite(rawHighlightCount) ? rawHighlightCount : 0)));
                const rawHighlightHeight = Number((zone as any)?.highlightHeight ?? 1);
                const highlightHeight = Math.max(1, Math.min(4, Number.isFinite(rawHighlightHeight) ? rawHighlightHeight : 1));
                const hasFeaturedLayout = highlightCount > 0 && highlightHeight > 1;
                const zoneFrameId = getResolvedZoneFrameId(zone);
                const stylesToApply: Partial<GlobalStyles> = getZoneGlobalStyles(zone);

                // Ensure a stable order index exists.
                const hasAllOrders = cards.every((c: any) => Number.isFinite((c as any)._zoneOrder));
                if (!hasAllOrders) {
                    cards
                        .slice()
                        .sort((a: any, b: any) => {
                            const rowDiff = (a.top ?? 0) - (b.top ?? 0);
                            if (Math.abs(rowDiff) > 50) return rowDiff;
                            return (a.left ?? 0) - (b.left ?? 0);
                        })
                        .forEach((c: any, i: number) => ((c as any)._zoneOrder = i));
                }

                const ordered = cards.slice().sort((a: any, b: any) => ((a as any)._zoneOrder ?? 0) - ((b as any)._zoneOrder ?? 0));
                let fromIndex = Number((obj as any)._zoneOrder);
                if (!Number.isFinite(fromIndex) || fromIndex < 0 || fromIndex >= ordered.length || ordered[fromIndex] !== obj) {
                    fromIndex = ordered.indexOf(obj);
                }

                // Find nearest slot index for the drop position.
                let toIndex = fromIndex;
                const center = typeof obj.getCenterPoint === 'function' ? obj.getCenterPoint() : null;
                if (center && ordered.length) {
                    let best = Math.max(0, fromIndex);
                    let bestD = Number.POSITIVE_INFINITY;
                    for (let i = 0; i < ordered.length; i++) {
                        const card = ordered[i];
                        const slot = (card as any)?._zoneSlot;
                        const cx = slot ? (slot.left + (slot.width / 2)) : Number(card?.left || 0);
                        const cy = slot ? (slot.top + (slot.height / 2)) : Number(card?.top || 0);
                        const dx = cx - center.x;
                        const dy = cy - center.y;
                        const d = (dx * dx) + (dy * dy);
                        if (d < bestD) {
                            bestD = d;
                            best = i;
                        }
                    }
                    toIndex = best;
                }

                const applyCardToSlot = (card: any, rawSlot: any, order: number) => {
                    if (!card || !rawSlot) return false;
                    const slotZoneId = String(rawSlot?.zoneId || '').trim();
                    if (slotZoneId && slotZoneId !== zoneId) return false;
                    const slotW = Math.max(2, Number(rawSlot?.width) || 0);
                    const slotH = Math.max(2, Number(rawSlot?.height) || 0);
                    const slotLeft = Number(rawSlot?.left);
                    const slotTop = Number(rawSlot?.top);
                    if (!Number.isFinite(slotLeft) || !Number.isFinite(slotTop) || !Number.isFinite(slotW) || !Number.isFinite(slotH)) return false;

                    const cx = slotLeft + (slotW / 2);
                    const cy = slotTop + (slotH / 2);

                    card.parentZoneId = zone._customId;
                    applyCardFrameBinding(card, zoneFrameId);
                    card._zoneOrder = order;
                    (card as any)._zoneSlot = { zoneId: zone._customId, left: slotLeft, top: slotTop, width: slotW, height: slotH };

                    if (card.isSmartObject || card.name?.startsWith('product-card')) {
                        resizeSmartObject(card, slotW, slotH, stylesToApply);
                        card.set({ left: cx, top: cy, originX: 'center', originY: 'center', scaleX: 1, scaleY: 1 });
                    } else {
                        card.set({
                            left: cx,
                            top: cy,
                            originX: 'center',
                            originY: 'center',
                            scaleX: slotW / (card.width || 1),
                            scaleY: slotH / (card.height || 1)
                        });
                    }
                    card.setCoords?.();
                    return true;
                };

                // Fast path: same slot index and no scaling => snap only this card back to its slot.
	                if (!didScale && fromIndex !== -1 && toIndex === fromIndex) {
                    const slot = (obj as any)?._zoneSlot;
                    const slotZoneId = String(slot?.zoneId || '').trim();
                    if (slot && slotZoneId === zoneId) {
                        const targetCx = slot.left + (slot.width / 2);
                        const targetCy = slot.top + (slot.height / 2);
                        const currentCenter = center || { x: Number(obj.left || 0), y: Number(obj.top || 0) };
	                        if (Math.abs(currentCenter.x - targetCx) > 0.25 || Math.abs(currentCenter.y - targetCy) > 0.25) {
                            if (fabric?.Point && typeof obj.setPositionByOrigin === 'function') {
                                obj.setPositionByOrigin(new fabric.Point(targetCx, targetCy), 'center', 'center');
                            } else {
                                obj.set({ left: targetCx, top: targetCy, originX: 'center', originY: 'center' });
                            }
	                            obj.setCoords?.();
	                        }
	                        recalculateZoneLayout(zone, ordered, { save: false });
	                        return;
	                    }
	                }

                // Fast path: simple 2-card swap in standard grid (no featured layout) without full zone relayout.
	                if (!didScale && !hasFeaturedLayout && fromIndex !== -1 && toIndex !== -1 && toIndex !== fromIndex) {
                    const fromCard = ordered[fromIndex];
                    const toCard = ordered[toIndex];
                    const fromSlot = (fromCard as any)?._zoneSlot;
                    const toSlot = (toCard as any)?._zoneSlot;
	                    if (
	                        applyCardToSlot(fromCard, toSlot, toIndex) &&
	                        applyCardToSlot(toCard, fromSlot, fromIndex)
	                    ) {
	                        [ordered[fromIndex], ordered[toIndex]] = [ordered[toIndex], ordered[fromIndex]];
	                        recalculateZoneLayout(zone, ordered, { save: false });
	                        return;
	                    }
	                }

                if (fromIndex !== -1 && toIndex !== -1 && toIndex !== fromIndex) {
                    // Swap apenas os dois cards - troca completa de posição
                    [ordered[fromIndex], ordered[toIndex]] = [ordered[toIndex], ordered[fromIndex]];
                    ordered.forEach((c: any, i: number) => ((c as any)._zoneOrder = i));
                }

                // Snap everything back into the grid after drop.
                recalculateZoneLayout(zone, ordered, { save: false });
            }
        }
        return;
    }
    
    // Check if it's a Smart Object (Group) or part of one?
    // Fabric v6: if we modify a child inside a group via interactive selection, 
    // the event might fire for the group or the child depending on subTargetCheck settings.
    
    // However, usually we deal with manual property updates from PropertiesPanel.
    // The canvas 'object:modified' is mostly for mouse interactions (drag, scale).
    // Dragging one card doesn't need to drag all others (layout is looser).
    // Scaling one card... theoretically should scale all? 
    // For now, let's limit "Herd Effect" to styles applied via PropertiesPanel.
}

// --- Sync Function invoked by Properties Panel ---
const syncSmartGridStyles = (sourceObj: any, property: string, value: any) => {
    if (!sourceObj.smartGridId) return;

    const gridId = sourceObj.smartGridId;
    const targetRole = sourceObj.name; // e.g. 'priceInteger' or 'productImage'

    // Iterate all objects
    const allObjects = canvasObjects.value; // reactive list or canvas.getObjects() 
    
    // We need to traverse. 
    // Since SmartObjects are Groups, we need to find the peer Groups, then find the matching child.
    
    canvas.value.getObjects().forEach((group: any) => {
        if (group.smartGridId === gridId && group !== sourceObj.group && group !== sourceObj) { // allow group itself or parent group
             // If sourceObj is inside a group, sourceObj is the child. 
             // group is the Container (Master Group). 
             // But wait, if we selected a text inside the group, sourceObj is the Text.
             // sourceObj.group is the MasterGroup.
             
             // Case 1: sourceObj is the MasterGroup (e.g. changing background color of the card)
             if (sourceObj.type === 'group' && sourceObj.smartGridId === gridId) {
                // peer is 'group'
                // Apply property to peer
                // Access private _objects or getObjects()
                 const peerBg = group.getObjects().find((o: any) => o.name === 'offerBackground');
                 if(sourceObj.name === 'offerBackground') { // Actually source is likely the group wrapper, but changes applied to bg?
                    // If formatting background color on the group directly?
                    // Usually properties panel applies format to the active object. 
                 }
             }

             // Case 2: sourceObj is a child (Text/Image) inside the MasterGroup
             // We need to find the "Cousin" inside the peer group.
             // sourceObj.group SHOULD be the MasterGroup.
        }
    });
}

const repairZoneCardsAfterHistoryRestore = () => {
    if (!canvas.value) return;
    const objs = canvas.value.getObjects() || [];
    const zones = objs.filter((o: any) => isLikelyProductZone(o));
    if (!zones.length) return;

    const cardLike = (o: any) => {
        if (!o || o.type !== 'group') return false;
        return !!(o.isSmartObject || o.isProductCard || isLikelyProductCard(o));
    };

    let repairedZones = 0;

    zones.forEach((zone: any) => {
        const zoneId = String((zone as any)?._customId || '').trim();
        if (!zoneId) return;
        const cards = objs.filter((o: any) => cardLike(o) && String((o as any)?.parentZoneId || '').trim() === zoneId);
        if (!cards.length) return;

        cards.forEach((card: any) => {
            const cardFrameId = String((card as any).parentFrameId || '').trim();
            const hiddenByFrame = !!(cardFrameId && getFrameById(cardFrameId)?.visible === false);
            if (hiddenByFrame) card.visible = false;
            else if (card.visible === false) card.visible = true;
            if (!Number.isFinite(Number(card.opacity)) || Number(card.opacity) <= 0) card.opacity = 1;
            card.set?.({ objectCaching: false, statefullCache: false, dirty: true });
            card.setCoords?.();
        });

        const zm = getZoneMetrics(zone) ?? zone.getBoundingRect(true);
        const margin = Math.max(40, Math.min(zm.width, zm.height) * 0.08);
        const hasAnyCardNearZone = cards.some((card: any) => {
            const center = typeof card.getCenterPoint === 'function'
                ? card.getCenterPoint()
                : { x: Number(card.left || 0), y: Number(card.top || 0) };
            const nearByCenter =
                center.x >= (zm.left - margin) &&
                center.x <= (zm.left + zm.width + margin) &&
                center.y >= (zm.top - margin) &&
                center.y <= (zm.top + zm.height + margin);
            if (nearByCenter) return true;
            try {
                return typeof zone.intersectsWithObject === 'function' && zone.intersectsWithObject(card);
            } catch {
                return false;
            }
        });

        if (!hasAnyCardNearZone) {
            try {
                recalculateZoneLayout(zone, cards, { save: false });
                repairedZones += 1;
            } catch (err) {
                console.warn('[history-repair] Failed to relayout zone after undo/redo', err);
            }
        }
    });

    if (repairedZones > 0) {
        canvas.value.requestRenderAll();
        refreshCanvasObjects();
        console.log(`[history-repair] Repaired ${repairedZones} zone(s) after undo/redo`);
    }
};


const applyHistoryNavigation = async (
    mode: 'undo' | 'redo',
    searchDirection: -1 | 1
): Promise<boolean> => {
    if (!canvas.value) return false;

    const stateStr = historyStack.value[historyIndex.value];
    if (!stateStr) {
        console.error('❌ Estado vazio no histórico');
        return false;
    }

    let state = prepareHistoryStateFromString(
        stateStr,
        prepareCanvasDataForLoad,
        {
            onParseError: (err: unknown) => {
                console.warn('[history] Falha ao parsear estado JSON:', err);
            }
        }
    );
    if (!state) {
        console.error('❌ Estado inválido no histórico');
        return false;
    }

    if (!Array.isArray(state.objects) || state.objects.length === 0) {
        console.warn('⚠️ Estado sem objetos - buscando próximo válido...');
        const found = findPreparedNonEmptyHistoryState({
            historyStack: historyStack.value,
            startIndex: historyIndex.value,
            direction: searchDirection,
            prepareCanvasDataForLoad,
            onParseError: (err: unknown) => {
                console.warn('[history] Falha ao parsear estado JSON:', err);
            }
        });
        if (!found) {
            console.error(`❌ Nenhum estado válido encontrado no histórico (${mode})`);
            return false;
        }
        historyIndex.value = found.index;
        state = found.state;
        console.log(`✅ Estado válido encontrado no índice ${historyIndex.value}`);
    }

    hydrateLabelTemplatesFromProjectJson(state);

    return applyHistoryStateToCanvas({
        mode,
        state,
        canvas: canvas.value,
        fabric,
        getSavedViewportTransform,
        loadFromJsonSafe,
        sanitizeAllClipPaths,
        rehydrateCanvasZones,
        repairZoneCardsAfterHistoryRestore,
        getFallbackPageState: () => {
            const currentPage = project.pages[project.activePageIndex];
            if (!currentPage?.canvasData?.objects?.length) return null;
            return prepareCanvasDataForLoad(currentPage.canvasData);
        },
        updateZoomState,
        updateScrollbars,
        zoomToFit,
        safeRequestRenderAll,
        refreshCanvasObjects,
        updateSelection,
        removeAllClipPaths
    })
};

const undo = async () => {
    if (historyIndex.value <= 0 || isHistoryProcessing.value) return;
    if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
    const previousIndex = historyIndex.value;
    isHistoryProcessing.value = true;
    try {
        historyIndex.value--;
        const applied = await applyHistoryNavigation('undo', -1);
        if (!applied) {
            historyIndex.value = previousIndex;
        }
    } finally {
        isHistoryProcessing.value = false;
    }
}

const redo = async () => {
    if (historyIndex.value >= historyStack.value.length - 1 || isHistoryProcessing.value) return;
    if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
    const previousIndex = historyIndex.value;
    isHistoryProcessing.value = true;
    try {
        historyIndex.value++;
        const applied = await applyHistoryNavigation('redo', 1);
        if (!applied) {
            historyIndex.value = previousIndex;
        }
    } finally {
        isHistoryProcessing.value = false;
    }
}

const duplicateFrameWithContents = async (frame: any, opts: { offset?: number } = {}) => {
    if (!canvas.value || !frame) return null;
    const frameLayerName = String((frame as any)?.layerName || '').trim().toUpperCase();
    const frameName = String((frame as any)?.name || '').trim();
    const isRootFrameLike = !!(frame as any)?.isFrame ||
        frameLayerName === 'FRAMER' ||
        frameLayerName === 'FRAME' ||
        /^FRAME(?:\s+\d+)?$/i.test(frameName) ||
        /^FRAMER(?:\s+\d+)?$/i.test(frameName);
    if (!isRootFrameLike) return null;
    if (!(frame as any)._customId) (frame as any)._customId = makeCanvasObjectId();
    const rootId = String((frame as any)._customId || '');
    if (!rootId) return null;

    const rootBounds = getFrameBounds(frame);
    const fallbackRootWidth = (Number((frame as any).width) || 0) * (Number((frame as any).scaleX) || 1);
    const rootWidth = Number(rootBounds?.width) || fallbackRootWidth || 1080;
    const gap = Number(opts.offset ?? FRAME_SPAWN_GAP) || FRAME_SPAWN_GAP;
    const rootCenter = typeof (frame as any).getCenterPoint === 'function'
        ? (frame as any).getCenterPoint()
        : { x: Number((frame as any).left) || 0, y: Number((frame as any).top) || 0 };
    const spawn = rootBounds
        ? {
            left: rootBounds.left + rootBounds.width + gap + rootWidth / 2,
            top: rootBounds.top + rootBounds.height / 2
        }
        : {
            left: (Number(rootCenter.x) || 0) + rootWidth + gap,
            top: Number(rootCenter.y) || 0
        };
    const offsetX = (Number(spawn.left) || 0) - (Number(rootCenter.x) || 0);
    const offsetY = (Number(spawn.top) || 0) - (Number(rootCenter.y) || 0);

    const all = canvas.value.getObjects();
    // Hard guard: guarantee stable IDs for legacy objects so duplication mapping never drops content.
    all.forEach((o: any) => {
        if (!o || o.excludeFromExport) return;
        if (!o._customId) o._customId = makeCanvasObjectId();
    });
    const indexById = new Map<string, number>();
    all.forEach((o: any, i: number) => {
        if (o?._customId) indexById.set(String(o._customId), i);
    });

    const isFrameContainerCandidate = (obj: any) => {
        if (!obj) return false;
        const layer = String(obj.layerName || '').trim().toUpperCase();
        const name = String(obj.name || '').trim();
        return !!obj.isFrame ||
            layer === 'FRAMER' ||
            layer === 'FRAME' ||
            /^FRAME(?:\s+\d+)?$/i.test(name) ||
            /^FRAMER(?:\s+\d+)?$/i.test(name);
    };

    const getFrameArea = (obj: any) => {
        const b = getFrameBounds(obj);
        if (!b) return Number.POSITIVE_INFINITY;
        return Math.max(1, Number(b.width || 0) * Number(b.height || 0));
    };

    const isObjectInsideOrOverlappingFrame = (candidate: any, container: any) => {
        if (!candidate || !container) return false;
        try {
            if (isObjectCenterInsideFrame(candidate, container)) return true;
            if (typeof candidate.getBoundingRect !== 'function' || typeof container.getBoundingRect !== 'function') return false;
            const objBounds = candidate.getBoundingRect(true);
            const frameBounds = container.getBoundingRect(true);
            if (!objBounds || !frameBounds) return false;
            const objArea = Math.max(1, Number(objBounds.width || 0) * Number(objBounds.height || 0));
            const ix = Math.max(0, Math.min(objBounds.left + objBounds.width, frameBounds.left + frameBounds.width) - Math.max(objBounds.left, frameBounds.left));
            const iy = Math.max(0, Math.min(objBounds.top + objBounds.height, frameBounds.top + frameBounds.height) - Math.max(objBounds.top, frameBounds.top));
            const overlapRatio = (ix * iy) / objArea;
            return overlapRatio >= 0.6;
        } catch {
            return false;
        }
    };

    const resolvedParentByOriginalId = new Map<string, string | undefined>();
    resolvedParentByOriginalId.set(rootId, undefined);
    const toDuplicateIds = new Set<string>([rootId]);
    const queue: string[] = [rootId];
    while (queue.length) {
        const parentId = queue.shift()!;
        all.forEach((o: any) => {
            if (!o || o.excludeFromExport) return;
            if (!o._customId) return;
            if (String((o as any).parentFrameId || '') !== parentId) return;
            const id = String(o._customId);
            if (toDuplicateIds.has(id)) return;
            toDuplicateIds.add(id);
            resolvedParentByOriginalId.set(id, parentId);
            if (isFrameContainerCandidate(o)) queue.push(id);
        });
    }

    // Fallback espacial: inclui objetos visualmente dentro do frame mesmo sem parentFrameId.
    // Isso cobre arquivos legacy onde vínculos não foram persistidos corretamente.
    let safety = 0;
    let changed = true;
    while (changed && safety++ < 20) {
        changed = false;
        const duplicatedFrames = all
            .filter((o: any) => {
                if (!o || !o._customId) return false;
                if (!toDuplicateIds.has(String(o._customId))) return false;
                return isFrameContainerCandidate(o);
            })
            .sort((a: any, b: any) => getFrameArea(a) - getFrameArea(b));

        if (!duplicatedFrames.length) break;

        all.forEach((candidate: any) => {
            if (!candidate || candidate.excludeFromExport || !candidate._customId) return;
            const candidateId = String(candidate._customId);
            if (toDuplicateIds.has(candidateId)) return;

            let container: any = null;
            for (const f of duplicatedFrames) {
                if (f === candidate) continue;
                if (!isObjectInsideOrOverlappingFrame(candidate, f)) continue;
                container = f;
                break; // duplicatedFrames já está ordenado do menor para o maior
            }
            if (!container?._customId) return;

            toDuplicateIds.add(candidateId);
            changed = true;

            const existingParent = String((candidate as any).parentFrameId || '').trim();
            const resolvedParent = existingParent && toDuplicateIds.has(existingParent)
                ? existingParent
                : String(container._customId);
            resolvedParentByOriginalId.set(candidateId, resolvedParent || undefined);
        });
    }

    const shouldSkipWhenDuplicatingFrameContent = (obj: any) => {
        if (!obj) return false;
        // Keep product zones (container/style), but do not duplicate any product instances/cards.
        if (isLikelyProductZone(obj)) return false;
        if (isLikelyProductCard(obj) || obj.isProductCard || obj.isSmartObject) return true;
        const parentZoneId = String((obj as any).parentZoneId || '').trim();
        if (parentZoneId) return true;
        return false;
    };

    const originals = all
        .filter((o: any) => o?._customId && toDuplicateIds.has(String(o._customId)))
        .filter((o: any) => !shouldSkipWhenDuplicatingFrameContent(o));
    originals.sort((a: any, b: any) => (indexById.get(String(a._customId)) ?? 0) - (indexById.get(String(b._customId)) ?? 0));
    console.log(`[duplicateFrameWithContents] root=${rootId} totalDuplicated=${originals.length} framesInSet=${originals.filter((o: any) => isFrameContainerCandidate(o)).length}`);

    if (!originals.length) return null;

    const insertBaseIndex = Math.max(...originals.map((o: any) => indexById.get(String(o._customId)) ?? -1)) + 1;
    const extraProps = Array.from(new Set([...CANVAS_CUSTOM_PROPS, 'data', 'opacity', 'flipX', 'flipY', 'filters', 'clipPath', 'src']));

    const oldToNewId = new Map<string, string>();
    const clones: any[] = [];
    let rootClone: any = null;

    // Clone everything first (preserve z-order), then fix parentFrameId references.
    for (let i = 0; i < originals.length; i++) {
        const original = originals[i];
        let cloned: any = null;
        try {
            const res = typeof original.clone === 'function' ? original.clone(extraProps) : null;
            cloned = res && typeof res.then === 'function' ? await res : res;
        } catch (err) {
            console.warn('[duplicateFrameWithContents] clone failed', err);
        }
        if (!cloned) continue;

        const oldId = String(original._customId || '');
        const newId = Math.random().toString(36).substr(2, 9);
        oldToNewId.set(oldId, newId);

        cloned._customId = newId;
        cloned.set?.({
            left: (Number(original.left) || 0) + offsetX,
            top: (Number(original.top) || 0) + offsetY,
            evented: true,
            selectable: true,
        });

        // Avoid stale frame clip refs; keep object masks.
        const isObjectMaskClone = !!(cloned as any)?.objectMaskEnabled;
        if (!isObjectMaskClone) {
            try { cloned.clipPath = null; } catch {}
            try { delete (cloned as any)._frameClipOwner; } catch {}
        }
        try { delete (cloned as any).__clipRect; } catch {}

        // Keep the frame flag even if Fabric drops it in clone.
        if (isFrameContainerCandidate(original)) {
            cloned.isFrame = true;
            cloned.clipContent = (original as any).clipContent !== false;
            cloned.stroke = (original as any).stroke || '#0d99ff';
            if ((original as any).layerName) cloned.layerName = (original as any).layerName;
            if ((original as any).name) cloned.name = (original as any).name;
        }

        // Give a friendly copied name to the root frame.
        if (String(original._customId) === rootId) {
            rootClone = cloned;
            const baseName = String((original as any).layerName || (original as any).name || 'Frame').trim();
            const copiedName = baseName ? `${baseName} (cópia)` : 'Frame (cópia)';
            if ((original as any).layerName) cloned.layerName = copiedName;
            cloned.name = copiedName;
        }

        // Insert right above the duplicated block to keep stacking predictable.
        try {
            if (typeof (canvas.value as any).insertAt === 'function') {
                (canvas.value as any).insertAt(insertBaseIndex + clones.length, cloned);
            } else {
                canvas.value.add(cloned);
            }
        } catch {
            canvas.value.add(cloned);
        }

        clones.push(cloned);
    }

    if (!rootClone) {
        // Fallback: root may not have cloned for some reason
        rootClone = clones.find((o: any) => !!o?.isFrame) || clones[0] || null;
    }
    if (!rootClone) return null;

    // Fix parentFrameId on all clones now that we have the id map.
    const oldByNew = new Map<string, any>();
    originals.forEach((o: any) => {
        const oldId = String(o._customId || '');
        const newId = oldToNewId.get(oldId);
        if (!newId) return;
        const clone = clones.find((c: any) => String(c._customId) === newId);
        if (clone) oldByNew.set(newId, { original: o, clone });
    });
    clones.forEach((clone: any) => {
        const entry = oldByNew.get(String(clone._customId));
        const original = entry?.original;
        if (!original) return;
        const originalId = String((original as any)._customId || '');
        const resolvedParent = resolvedParentByOriginalId.get(originalId);
        const oldParent = String(resolvedParent || (original as any).parentFrameId || '');
        if (!oldParent) {
            clone.parentFrameId = undefined;
            return;
        }
        const mappedParent = oldToNewId.get(oldParent);
        clone.parentFrameId = mappedParent || undefined;

        const oldMaskSource = String((original as any).objectMaskSourceId || '').trim();
        if (!oldMaskSource) {
            delete clone.objectMaskSourceId;
        } else {
            clone.objectMaskSourceId = oldToNewId.get(oldMaskSource) || oldMaskSource;
        }
    });

    // Rebuild clipping for the new frame tree.
    try {
        clones.forEach((o: any) => {
            if (o?.isFrame) getOrCreateFrameClipRect(o);
        });
        clones.forEach((o: any) => {
            if (o?.parentFrameId || o?._frameClipOwner) syncObjectFrameClip(o);
        });
        clones.forEach((o: any) => {
            if (o?.isFrame) syncFrameClips(o);
        });
    } catch (err) {
        console.warn('[duplicateFrameWithContents] failed to rebuild frame clips', err);
    }

    try {
        clones.forEach((o: any) => {
            if (o) reapplyRuntimeVisualPatchesTree(o);
        });
    } catch (err) {
        console.warn('[duplicateFrameWithContents] failed to reapply runtime visual patches', err);
    }

    canvas.value.setActiveObject(rootClone);
    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    updateSelection();
    saveCurrentState({ reason: 'duplicate-frame' });
    return rootClone;
};

const DUPLICATE_OFFSET = 20;
const DUPLICATE_CLONE_PROPS = Array.from(new Set([
    ...CANVAS_CUSTOM_PROPS,
    'data',
    'opacity',
    'flipX',
    'flipY',
    'filters',
    'clipPath',
    'src',
    'originX',
    'originY',
    'angle',
    'scaleX',
    'scaleY',
    'parentFrameId',
    'parentZoneId',
    'isSmartObject',
    'isProductCard',
    'name',
    'layerName',
    'clipContent',
    'smartGridId',
    '_cardWidth',
    '_cardHeight',
    '_zoneOrder',
    '_zoneSlot',
    'subTargetCheck',
    'interactive',
]));

const isActiveSelectionObject = (obj: any) => String(obj?.type || '').toLowerCase() === 'activeselection';

const isProductCardContainer = (group: any) => {
    if (!group) return false;
    if (String(group.type || '').toLowerCase() !== 'group') return false;
    return !!(
        group.isSmartObject ||
        group.isProductCard ||
        String(group.name || '').startsWith('product-card') ||
        isLikelyProductCard(group)
    );
};

const assignNewCustomIdsDeep = (obj: any) => {
    if (!obj || typeof obj !== 'object') return;
    obj._customId = Math.random().toString(36).substr(2, 9);
    if (typeof obj.getObjects === 'function') {
        (obj.getObjects() || []).forEach((child: any) => assignNewCustomIdsDeep(child));
    }
};

const findProductCardParentGroup = (obj: any) => {
    if (!obj || !canvas.value) return null;
    const direct = (obj as any).group;
    if (isProductCardContainer(direct)) return direct;
    const directParent = (obj as any).parent;
    if (isProductCardContainer(directParent)) return directParent;

    const targetId = String((obj as any)?._customId || '').trim();
    const all = canvas.value.getObjects();

    const containsObjectDeep = (node: any): boolean => {
        if (!node) return false;
        if (node === obj) return true;
        if (targetId && String((node as any)?._customId || '').trim() === targetId) return true;
        if (typeof (node as any)?.getObjects === 'function') {
            const children = (node as any).getObjects() || [];
            for (const child of children) {
                if (containsObjectDeep(child)) return true;
            }
        }
        return false;
    };

    for (const candidate of all) {
        if (!isProductCardContainer(candidate) || typeof candidate.getObjects !== 'function') continue;
        const activeChildren = Array.isArray((candidate as any)?._activeObjects)
            ? (candidate as any)._activeObjects
            : [];
        const contains =
            containsObjectDeep(candidate) ||
            activeChildren.some((child: any) => containsObjectDeep(child));
        if (contains) return candidate;
    }
    return null;
};

const duplicateObjectWithContext = async (
    original: any,
    opts: { offsetX?: number; offsetY?: number } = {}
) => {
    if (!canvas.value || !original) return null;
    const offsetX = Number(opts.offsetX ?? DUPLICATE_OFFSET) || 0;
    const offsetY = Number(opts.offsetY ?? DUPLICATE_OFFSET) || 0;

    let cloned: any = null;
    try {
        cloned = await (original as any).clone(DUPLICATE_CLONE_PROPS);
    } catch (err) {
        console.warn('[duplicate] Falha ao clonar objeto', err);
        return null;
    }
    if (!cloned) return null;

    assignNewCustomIdsDeep(cloned);

    const parentCardGroup = findProductCardParentGroup(original);
    const cloneInsideCard =
        !!parentCardGroup &&
        original !== parentCardGroup &&
        !isProductCardContainer(original) &&
        !isActiveSelectionObject(original);

    if (cloneInsideCard && parentCardGroup) {
        const localLeft = Number((original as any).left) || 0;
        const localTop = Number((original as any).top) || 0;
        const targetCanvas = groupLocalToCanvasPoint(parentCardGroup, localLeft + offsetX, localTop + offsetY);

        cloned.set({
            left: targetCanvas.x,
            top: targetCanvas.y,
            originX: (original as any).originX || 'center',
            originY: (original as any).originY || 'center',
            angle: (original as any).angle || 0,
            scaleX: (original as any).scaleX || 1,
            scaleY: (original as any).scaleY || 1,
            flipX: !!(original as any).flipX,
            flipY: !!(original as any).flipY,
            opacity: (original as any).opacity ?? 1,
            selectable: true,
            evented: true,
            hasControls: true,
            hasBorders: true,
        });

        // Child clones inside product cards should not carry top-level zone/frame bindings.
        cloned.parentZoneId = undefined;
        cloned.parentFrameId = undefined;
        safeAddWithUpdate(parentCardGroup, cloned);
        parentCardGroup.set({ subTargetCheck: true, interactive: true });
        parentCardGroup.setCoords?.();
        return cloned;
    }

    cloned.set({
        left: (Number((original as any).left) || 0) + offsetX,
        top: (Number((original as any).top) || 0) + offsetY,
        originX: (original as any).originX || cloned.originX || 'center',
        originY: (original as any).originY || cloned.originY || 'center',
        angle: (original as any).angle || cloned.angle || 0,
        scaleX: (original as any).scaleX || cloned.scaleX || 1,
        scaleY: (original as any).scaleY || cloned.scaleY || 1,
        flipX: !!(original as any).flipX,
        flipY: !!(original as any).flipY,
        opacity: (original as any).opacity ?? cloned.opacity ?? 1,
        selectable: true,
        evented: true,
    });
    canvas.value.add(cloned);

    return cloned;
};

const duplicateActiveObjectWithContext = async (
    active: any,
    opts: { offsetX?: number; offsetY?: number } = {}
) => {
    if (!canvas.value || !active) return [] as any[];

    if (isActiveSelectionObject(active) && typeof (active as any).getObjects === 'function') {
        const members = ((active as any).getObjects?.() || []).slice();
        canvas.value.discardActiveObject();
        const clones: any[] = [];
        for (const member of members) {
            const cloned = await duplicateObjectWithContext(member, opts);
            if (cloned) clones.push(cloned);
        }
        return clones;
    }

    const cloned = await duplicateObjectWithContext(active, opts);
    return cloned ? [cloned] : [];
};

// Local (in-app) clipboard for Fabric objects. We keep it on `window` so it survives
// page switches inside the editor and allows copying from one page and pasting into another.
const CLIPBOARD_CLONE_PROPS: string[] = Array.from(new Set([
    ...((Array.isArray(CANVAS_CUSTOM_PROPS) ? (CANVAS_CUSTOM_PROPS as unknown as string[]) : []) as string[]),
    'opacity',
    'flipX',
    'flipY',
    'clipPath',
    'filters',
    'originX',
    'originY',
    'angle',
    'scaleX',
    'scaleY',
    'skewX',
    'skewY'
]));

const CLIPBOARD_SERIALIZE_PROPS: string[] = Array.from(new Set([
    ...CLIPBOARD_CLONE_PROPS,
    '_clipboardCenterX',
    '_clipboardCenterY',
    '_clipboardSourceCustomId',
    '_sourceGroupId',
    '_sourceLeft',
    '_sourceTop'
]));

const CROSS_TAB_CLIPBOARD_STORAGE_KEY = 'jobvarejo:editor:fabric-clipboard:v2';
const CROSS_TAB_CLIPBOARD_MAX_AGE_MS = 24 * 60 * 60 * 1000;
const CROSS_TAB_CLIPBOARD_MAX_BYTES = 2_000_000;

const normalizeClipboardPoint = (point: any): { x: number; y: number } => {
    const x = Number(point?.x);
    const y = Number(point?.y);
    return {
        x: Number.isFinite(x) ? x : 0,
        y: Number.isFinite(y) ? y : 0
    };
};

const serializeRuntimeClipboardForCrossTab = (runtimeClipboard: any): string | null => {
    if (!runtimeClipboard || runtimeClipboard.kind !== 'fabric-items-v2' || !Array.isArray(runtimeClipboard.items)) return null;

    const itemsJson: any[] = [];
    for (const item of runtimeClipboard.items) {
        if (!item || typeof item.toObject !== 'function') continue;
        try {
            const itemJson = item.toObject(CLIPBOARD_SERIALIZE_PROPS);
            if (itemJson && typeof itemJson === 'object') {
                itemsJson.push(itemJson);
            }
        } catch (err) {
            console.warn('[clipboard] Falha ao serializar item para cross-tab', err);
        }
    }

    if (!itemsJson.length) return null;

    const payload = {
        format: 'jobvarejo-fabric-items-v2',
        version: 1,
        copiedAt: Number(runtimeClipboard.copiedAt || Date.now()) || Date.now(),
        sourcePageId: String(runtimeClipboard.sourcePageId || '').trim(),
        selectionCenter: normalizeClipboardPoint(runtimeClipboard.selectionCenter),
        itemsJson
    };

    try {
        const raw = JSON.stringify(payload);
        if (!raw || raw.length > CROSS_TAB_CLIPBOARD_MAX_BYTES) return null;
        return raw;
    } catch (err) {
        console.warn('[clipboard] Falha ao codificar payload cross-tab', err);
        return null;
    }
};

const persistRuntimeClipboardForCrossTab = (runtimeClipboard: any) => {
    if (!process.client) return;
    try {
        const raw = serializeRuntimeClipboardForCrossTab(runtimeClipboard);
        if (!raw) return;
        window.localStorage.setItem(CROSS_TAB_CLIPBOARD_STORAGE_KEY, raw);
    } catch (err) {
        console.warn('[clipboard] Falha ao persistir clipboard cross-tab', err);
    }
};

const readCrossTabClipboardPayload = (): any | null => {
    if (!process.client) return null;
    let raw = '';
    try {
        raw = String(window.localStorage.getItem(CROSS_TAB_CLIPBOARD_STORAGE_KEY) || '');
    } catch {
        return null;
    }
    if (!raw) return null;

    try {
        const payload = JSON.parse(raw);
        if (!payload || payload.format !== 'jobvarejo-fabric-items-v2' || !Array.isArray(payload.itemsJson)) return null;
        const copiedAt = Number(payload.copiedAt || 0);
        if (!Number.isFinite(copiedAt) || copiedAt <= 0) return null;
        if ((Date.now() - copiedAt) > CROSS_TAB_CLIPBOARD_MAX_AGE_MS) {
            try { window.localStorage.removeItem(CROSS_TAB_CLIPBOARD_STORAGE_KEY); } catch {}
            return null;
        }
        if (!payload.itemsJson.length) return null;
        return payload;
    } catch {
        return null;
    }
};

const enlivenClipboardItemsFromJson = async (objectsJson: any[]): Promise<any[]> => {
    if (!Array.isArray(objectsJson) || objectsJson.length === 0) return [];
    if (!fabric?.util?.enlivenObjects) return [];
    const fn = fabric.util.enlivenObjects;
    try {
        const maybe = fn(objectsJson);
        if (maybe && typeof maybe.then === 'function') {
            const out = await maybe;
            return Array.isArray(out) ? out : [];
        }
    } catch {
        // fallback for callback signature
    }
    return await new Promise<any[]>((resolve) => {
        try {
            fn(objectsJson, (enlivened: any[]) => resolve(Array.isArray(enlivened) ? enlivened : []));
        } catch {
            resolve([]);
        }
    });
};

const hydrateRuntimeClipboardFromCrossTabPayload = async (payload: any): Promise<any | null> => {
    if (!payload || !Array.isArray(payload.itemsJson)) return null;
    const enlivened = await enlivenClipboardItemsFromJson(payload.itemsJson);
    if (!Array.isArray(enlivened) || !enlivened.length) return null;
    return {
        kind: 'fabric-items-v2',
        items: enlivened,
        selectionCenter: normalizeClipboardPoint(payload.selectionCenter),
        sourcePageId: String(payload.sourcePageId || '').trim(),
        copiedAt: Number(payload.copiedAt || Date.now()) || Date.now()
    };
};

const getObjectAbsoluteCenter = (obj: any): { x: number; y: number } => {
    if (!obj) return { x: 0, y: 0 };
    try {
        const p = obj.getCenterPoint?.();
        if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) return { x: Number(p.x), y: Number(p.y) };
    } catch { /* ignore */ }
    return { x: Number(obj.left || 0) || 0, y: Number(obj.top || 0) || 0 };
};

const computeCentersBoundingCenter = (centers: Array<{ x: number; y: number }>): { x: number; y: number } => {
    if (!Array.isArray(centers) || centers.length === 0) return { x: 0, y: 0 };
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    centers.forEach((p) => {
        const x = Number(p?.x || 0) || 0;
        const y = Number(p?.y || 0) || 0;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
    });
    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return { x: 0, y: 0 };
    return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
};

const regenerateCustomIdsRecursive = (root: any, idMap: Map<string, string>) => {
    if (!root || typeof root !== 'object') return;
    // Skip user guides/artboard/control-like objects (shouldn't be on clipboard anyway).
    try { if (isUserGuideObject(root)) return; } catch {}
    if (isControlLikeObject(root)) return;

    const prev = String((root as any)._customId || '').trim();
    const next = makeCanvasObjectId();
    if (prev) idMap.set(prev, next);
    (root as any)._customId = next;

    if (typeof root.getObjects === 'function') {
        try {
            const kids = root.getObjects() || [];
            kids.forEach((child: any) => regenerateCustomIdsRecursive(child, idMap));
        } catch { /* ignore */ }
    }
    if (root.clipPath && typeof root.clipPath === 'object') {
        regenerateCustomIdsRecursive(root.clipPath, idMap);
    }
};

const remapOrClearBindingsRecursive = (root: any, idMap: Map<string, string>, existingIds: Set<string>) => {
    if (!root || typeof root !== 'object') return;
    const obj: any = root;

    const remapId = (id: any) => {
        const raw = String(id || '').trim();
        if (!raw) return '';
        const mapped = idMap.get(raw);
        if (mapped) return mapped;
        if (existingIds.has(raw)) return raw;
        return '';
    };

    if (obj.parentFrameId) {
        const next = remapId(obj.parentFrameId);
        if (next) obj.parentFrameId = next;
        else delete obj.parentFrameId;
    }
    if (obj.parentZoneId) {
        const next = remapId(obj.parentZoneId);
        if (next) obj.parentZoneId = next;
        else delete obj.parentZoneId;
    }
    if (obj.objectMaskSourceId) {
        const next = remapId(obj.objectMaskSourceId);
        if (next) obj.objectMaskSourceId = next;
        else delete obj.objectMaskSourceId;
    }

    if (typeof obj.getObjects === 'function') {
        try {
            const kids = obj.getObjects() || [];
            kids.forEach((child: any) => remapOrClearBindingsRecursive(child, idMap, existingIds));
        } catch { /* ignore */ }
    }
    if (obj.clipPath && typeof obj.clipPath === 'object') {
        remapOrClearBindingsRecursive(obj.clipPath, idMap, existingIds);
    }
};

const reapplyRuntimeVisualPatchesTree = (root: any) => {
    const patchNode = (node: any) => {
        if (!node) return;

        if (isRectObject(node) && (node as any).cornerRadii) {
            applyRectCornerRadiiPatch(node);
        }

        const type = String((node as any)?.type || '').toLowerCase();
        if (type === 'image') {
            // Filters can be present but stale after clone; force a lightweight refresh.
            if (Array.isArray((node as any).filters) && (node as any).filters.length > 0 && typeof (node as any).applyFilters === 'function') {
                try { (node as any).applyFilters(); } catch {}
            }

            // Sticker outline uses a runtime render patch and cache that must be rebuilt on clones.
            if ((node as any).__stickerOutlineEnabled) {
                applyStickerOutlinePatch(node);
                setTimeout(() => {
                    if ((node as any)?.__stickerOutlineEnabled && !(node as any)?.__stickerOutlineCache) {
                        applyStickerOutlinePatch(node);
                    }
                }, 1200);
                setTimeout(() => {
                    if ((node as any)?.__stickerOutlineEnabled && !(node as any)?.__stickerOutlineCache) {
                        applyStickerOutlinePatch(node);
                    }
                }, 3200);
            }
        }

        if (type === 'group' && typeof (node as any).getObjects === 'function') {
            ((node as any).getObjects() || []).forEach((child: any) => patchNode(child));
        }
    };

    patchNode(root);
};

const finalizeDuplicatedObjects = (clones: any[]) => {
    if (!canvas.value || !Array.isArray(clones) || clones.length === 0) return;

    const affectedZones = new Map<string, any>();
    clones.forEach((obj: any) => {
        if (!obj) return;
        reapplyRuntimeVisualPatchesTree(obj);
        if (obj?.isFrame) {
            getOrCreateFrameClipRect(obj);
            syncFrameClips(obj);
        } else if (obj?.parentFrameId || obj?._frameClipOwner) {
            syncObjectFrameClip(obj);
        }

        if (shouldApplyContainmentConstraints(obj)) {
            applyContainmentConstraints(obj);
        }

        const zoneId = String((obj as any)?.parentZoneId || '').trim();
        if (!zoneId) return;
        const zone = getContainmentZoneById(zoneId) || canvas.value?.getObjects()?.find((o: any) => (
            isLikelyProductZone(o) && String((o as any)?._customId || '').trim() === zoneId
        ));
        if (!zone) return;
        applyCardFrameBinding(obj, getResolvedZoneFrameId(zone));
        affectedZones.set(zoneId, zone);
    });

    affectedZones.forEach((zone: any) => {
        ensureZoneSanity(zone);
        recalculateZoneLayout(zone, getZoneChildren(zone), { save: false });
    });

    const topLevelClones = clones.filter((obj: any) => !obj?.group);
    if (topLevelClones.length > 1 && fabric?.ActiveSelection) {
        const selection = new fabric.ActiveSelection(topLevelClones, { canvas: canvas.value });
        canvas.value.setActiveObject(selection);
    } else {
        canvas.value.setActiveObject(clones[0]);
    }

    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    updateSelection();
};

const deleteActiveSelectionFromCanvas = (): boolean => {
    if (!canvas.value) return false;

    // Node-editing delete parity (same behavior as keyboard Delete/Backspace).
    if (isNodeEditing.value && selectedPathNodeIndex.value !== null && currentEditingPath.value) {
        removePathPoint(currentEditingPath.value, selectedPathNodeIndex.value);
        return true;
    }

    const active = (canvas.value.getActiveObjects?.() || []).filter((o: any) => !!o);
    if (!active.length) return false;

    const containsFrameLikeObject = (items: any[]): boolean =>
        items.some((item: any) => !!item && (item.isFrame || isFrameLikeObject(item)));

    const confirmFrameDeletion = (origin: 'canvas' | 'layers'): boolean => {
        if (typeof window === 'undefined') return true;
        const where = origin === 'layers' ? 'painel de camadas' : 'canvas';
        return window.confirm(
            `Excluir Frame no ${where}? Isso remove tambem todo o conteudo dentro dele.`
        );
    };

    if (containsFrameLikeObject(active) && !confirmFrameDeletion('canvas')) {
        return false;
    }

    const deleteTargets = new Set<any>(active);

    // Ao remover um frame, remover em cascata TODO o conteúdo interno (incluindo nested frames).
    active.forEach((obj: any) => {
        if (!obj) return;
        if (!(obj.isFrame || isFrameLikeObject(obj))) return;
        const frameTargets = collectFrameVisibilityTargets(obj);
        frameTargets.forEach((target: any) => {
            if (!target) return;
            if (isControlLikeObject(target) || isTransientCanvasObject(target)) return;
            if (String(target.id || '') === 'artboard-bg') return;
            deleteTargets.add(target);
        });
    });
    const activeWithCascade = Array.from(deleteTargets);

    // Collect objects to delete - separate those in real groups vs canvas root
    const toDeleteFromCanvas: any[] = [];
    const toDeleteFromGroup: { obj: any, group: any }[] = [];

    for (const obj of activeWithCascade) {
        // Get the group reference, but IGNORE ActiveSelection
        let parentGroup = (obj as any).group;

        // CRITICAL: ActiveSelection is NOT a real parent group - skip it
        if (parentGroup && (
            parentGroup.type === 'activeSelection' ||
            parentGroup.type === 'ActiveSelection' ||
            String(parentGroup.type || '').toLowerCase() === 'activeselection'
        )) {
            parentGroup = null;
        }

        // Try global search if no direct parent found
        if (!parentGroup) {
            parentGroup = findParentGroupForObjectGlobal(obj);
        }

        // Double-check it's not an ActiveSelection
        if (parentGroup && (
            parentGroup.type === 'activeSelection' ||
            parentGroup.type === 'ActiveSelection' ||
            String(parentGroup.type || '').toLowerCase() === 'activeselection'
        )) {
            parentGroup = null;
        }

        if (parentGroup && typeof parentGroup.remove === 'function') {
            toDeleteFromGroup.push({ obj, group: parentGroup });
        } else {
            toDeleteFromCanvas.push(obj);
        }
    }

    // First discard active selection to release objects
    canvas.value.discardActiveObject();

    // Delete from groups first
    for (const { obj, group } of toDeleteFromGroup) {
        try {
            group.remove(obj);
            group.set('dirty', true);
            if (typeof group.setCoords === 'function') group.setCoords();
        } catch (err) {
            console.warn('[Delete] Erro ao remover do grupo, tentando canvas:', err);
            try { canvas.value.remove(obj); } catch {}
        }
    }

    // Delete from canvas
    for (const obj of toDeleteFromCanvas) {
        try {
            // Grid cell: also delete all sibling cells and their children
            if ((obj as any).isGridCell && (obj as any).gridGroupId) {
                const gid = (obj as any).gridGroupId;
                const siblings = canvas.value.getObjects().filter(
                    (o: any) => o !== obj && o.gridGroupId === gid && o.isGridCell
                );
                for (const sib of siblings) {
                    // Remove children parented to this cell
                    const children = canvas.value.getObjects().filter(
                        (ch: any) => ch.parentFrameId === sib._customId
                    );
                    children.forEach((ch: any) => { try { canvas.value!.remove(ch); } catch {} });
                    try { canvas.value.remove(sib); } catch {}
                }
                // Remove children of the deleted cell itself
                const ownChildren = canvas.value.getObjects().filter(
                    (ch: any) => ch.parentFrameId === (obj as any)._customId
                );
                ownChildren.forEach((ch: any) => { try { canvas.value!.remove(ch); } catch {} });
            }
            canvas.value.remove(obj);
        } catch (err) {
            console.warn('[Delete] Erro ao remover do canvas:', err);
        }
    }

    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    updateSelection();
    saveCurrentState();
    return true;
};

const handleKeyDown = async (e: KeyboardEvent) => {
    if (!canvas.value) return;

    // If editing a Fabric IText, let Fabric/browser handle undo/redo (text-level), not canvas-history.
    try {
        const active: any = canvas.value.getActiveObject?.();
        if (active?.isEditing) return;
    } catch {}
    
    // Ignore input fields so we don't trigger shortcuts while typing
    const target = e.target as HTMLElement;
    if (target.tagName === 'INPUT' || 
        target.tagName === 'TEXTAREA' || 
        target.isContentEditable ||
        target.closest('input, textarea, [contenteditable="true"]')) {
        return;
    }

    if (e.code === 'Space') {
        isSpacePanPressed = true;
        if (!isPenMode.value && !isNodeEditing.value && !isDrawing.value) {
            canvas.value.defaultCursor = 'grab';
        }
        e.preventDefault();
        return;
    }

    const isCtrl = e.ctrlKey || e.metaKey;

    // --- Undo/Redo Shortcuts (Ctrl+Z / Cmd+Z, Ctrl+Shift+Z / Cmd+Shift+Z) ---
    // Verificar primeiro para garantir prioridade
    if (isCtrl && (e.key === 'z' || e.key === 'Z')) {
        // Não processar undo/redo se já estiver processando histórico
        if (isHistoryProcessing.value) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        if (e.shiftKey) {
            redo();
        } else {
            undo();
        }
        return;
    }

    // --- Zoom Shortcuts ---
    if (isCtrl && (e.key === '=' || e.key === '+')) {
        e.preventDefault(); // Prevent browser zoom
        handleZoomIn();
        return;
    }
    if (isCtrl && e.key === '-') {
        e.preventDefault(); // Prevent browser zoom
        handleZoomOut();
        return;
    }
    if (isCtrl && e.key === '0') {
        e.preventDefault();
        handleZoom100();
        return;
    }
    // Fit to screen (enquadrar área de design inteira na viewport)
    // Use `code` because on many layouts Shift+1 yields `!` (not `1`).
    if (e.shiftKey && (e.code === 'Digit1' || e.key === '1' || e.key === '!')) {
        e.preventDefault();
        zoomToFit({ persist: true });
        return;
    }
    // Extra shortcut: `F` (when not using Ctrl/Cmd) for quick fit-to-screen.
    if (!isCtrl && (e.key === 'f' || e.key === 'F')) {
        e.preventDefault();
        zoomToFit({ persist: true });
        return;
    }

    // Layer order (Figma): Cmd/Ctrl+[ ] and Option+Cmd/Ctrl+[ ]
    if (isCtrl && (e.key === '[' || e.key === ']')) {
        e.preventDefault();
        const mode: ArrangeMode =
            e.key === ']'
                ? (e.altKey ? 'bring-to-front' : 'bring-forward')
                : (e.altKey ? 'send-to-back' : 'send-backward');
        arrangeActiveObjects(mode);
        return;
    }

    // Object mask (Ctrl/Cmd+Shift+M)
    if (isCtrl && e.shiftKey && String(e.key || '').toLowerCase() === 'm') {
        e.preventDefault();
        await handleAction('toggle-mask');
        return;
    }

    // Delete
    if (e.key === 'Delete' || e.key === 'Backspace') {
        const deleted = deleteActiveSelectionFromCanvas();
        if (deleted) e.preventDefault();
    }
    
    // Curve function shortcuts (only when editing path nodes)
    if (isNodeEditing.value && selectedPathNodeIndex.value !== null && currentEditingPath.value) {
        if (e.key === 's' || e.key === 'S') {
            e.preventDefault();
            smoothHandles(currentEditingPath.value, selectedPathNodeIndex.value);
            return;
        }
        if (e.key === 'c' || e.key === 'C') {
            e.preventDefault();
            convertPointToCorner(currentEditingPath.value, selectedPathNodeIndex.value);
            return;
        }
        if (e.key === 'm' || e.key === 'M') {
            e.preventDefault();
            mirrorHandles(currentEditingPath.value, selectedPathNodeIndex.value);
            return;
        }
    }

    // Arrows Movement (Nudge) + Alt+Arrows para resize frames
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        const active = canvas.value.getActiveObject();

        // Alt+Setas = Redimensionar frame de 1 pixel
        if (active && active.isFrame && e.altKey) {
            if (active.lockScalingX || active.lockScalingY) { e.preventDefault(); return; }
            e.preventDefault();
            const step = e.shiftKey ? 10 : 1; // Shift = 10px

            if (e.key === 'ArrowUp') active.height -= step;
            if (e.key === 'ArrowDown') active.height += step;
            if (e.key === 'ArrowLeft') active.width -= step;
            if (e.key === 'ArrowRight') active.width += step;

            active.setCoords();
            getOrCreateFrameClipRect(active);
            invalidateScrollbarBounds();
            canvas.value.requestRenderAll();
            keyboardNudgeDirty = true;
            return;
        }

        // Setas normais = Mover objeto
        if (active) {
            if (active.lockMovementX || active.lockMovementY) { e.preventDefault(); return; }
            e.preventDefault();
            const step = e.shiftKey ? 10 : 1;
            const prevLeft = active.left;
            const prevTop = active.top;
            if (e.key === 'ArrowUp') active.top -= step;
            if (e.key === 'ArrowDown') active.top += step;
            if (e.key === 'ArrowLeft') active.left -= step;
            if (e.key === 'ArrowRight') active.left += step;
            active.setCoords();

            if (isLikelyProductZone(active)) {
                ensureZoneSanity(active);
                const dx = active.left - prevLeft;
                const dy = active.top - prevTop;
                moveZoneChildren(active, dx, dy);
                maybeReparentToFrameOnDrop(active);
                syncZoneCardFrameBindings(active);
            }
            if (active.isFrame) {
                const dx = active.left - prevLeft;
                const dy = active.top - prevTop;
                moveFrameDescendants(active, dx, dy);
                getOrCreateFrameClipRect(active);
            }
            invalidateScrollbarBounds();
            canvas.value.requestRenderAll();
            throttledUpdateScrollbars();
            keyboardNudgeDirty = true;
        } else {
            // If no object selected, arrows pan the canvas
            e.preventDefault();
            const step = 20;
            const vpt = canvas.value.viewportTransform;
            if (e.key === 'ArrowUp') vpt[5] += step;
            if (e.key === 'ArrowDown') vpt[5] -= step;
            if (e.key === 'ArrowLeft') vpt[4] += step;
            if (e.key === 'ArrowRight') vpt[4] -= step;
            canvas.value.requestRenderAll();
            throttledUpdateScrollbars();
            scheduleViewportStateSave('keyboard-pan');
            keyboardNudgeDirty = true;
        }
    }

    // Copy / Paste (Simple Clone)
    // Fabric v7 clone() returns a Promise; the legacy callback signature throws ("t2 is not iterable").
    if (isCtrl && String(e.key || '').toLowerCase() === 'c') {
        const actives = (canvas.value.getActiveObjects?.() || []).slice();
        if (actives.length > 0) {
            e.preventDefault();
            try {
                const items: any[] = [];
                const centers: Array<{ x: number; y: number }> = [];
                for (const active of actives) {
                    if (!active) continue;
                    // Skip non-user content.
                    if (isTransientCanvasObject(active) || String((active as any).id || '') === 'artboard-bg') continue;
                    try { ensureObjectPersistentId(active); } catch {}

                    const center = getObjectAbsoluteCenter(active);
                    centers.push(center);

                    const cloned = await (active as any).clone(CLIPBOARD_CLONE_PROPS);

                    // Store absolute center so we can paste on another page keeping relative layout.
                    (cloned as any)._clipboardCenterX = center.x;
                    (cloned as any)._clipboardCenterY = center.y;

                    // Store the original id so we can rebuild parentFrameId/parentZoneId mappings on paste.
                    (cloned as any)._clipboardSourceCustomId = String((active as any)._customId || '').trim() || null;

                    // Store the parent group reference for paste operation (single inner-image convenience).
                    const parentGroup = (active as any).group;
                    (cloned as any)._sourceGroupRef = parentGroup;
                    (cloned as any)._sourceGroupId = parentGroup?._customId || null;
                    (cloned as any)._sourceLeft = Number((active as any).left) || 0;
                    (cloned as any)._sourceTop = Number((active as any).top) || 0;

                    // Fallback: detect product card parent for deep-selected images.
                    if (!parentGroup && String((active as any).type || '').toLowerCase() === 'image') {
                        const allObjects = canvas.value.getObjects();
                        for (const obj of allObjects) {
                            if (obj.type === 'group' && ((obj as any).isSmartObject || (obj as any).isProductCard || isLikelyProductCard(obj))) {
                                if (typeof (obj as any).getObjects === 'function') {
                                    const children = (obj as any).getObjects();
                                    const containsImage = (children || []).some((child: any) =>
                                        child === active || child?._customId === (active as any)?._customId
                                    );
                                    if (containsImage) {
                                        (cloned as any)._sourceGroupRef = obj;
                                        (cloned as any)._sourceGroupId = (obj as any)._customId;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    items.push(cloned);
                }

                if (items.length > 0) {
                    const selectionCenter = computeCentersBoundingCenter(centers);
                    const runtimeClipboard = {
                        kind: 'fabric-items-v2',
                        items,
                        selectionCenter,
                        sourcePageId: getActiveProjectPageId(),
                        copiedAt: Date.now()
                    };
                    (window as any)._clipboard = runtimeClipboard;
                    persistRuntimeClipboardForCrossTab(runtimeClipboard);
                }
            } catch (err) {
                console.warn('[clipboard] Falha ao copiar (clone)', err);
            }
        }
    }

    if (isCtrl && String(e.key || '').toLowerCase() === 'v') {
        let clipAny = (window as any)._clipboard;
        const localCopiedAt = Number((clipAny as any)?.copiedAt || 0);
        const crossTabPayload = readCrossTabClipboardPayload();
        const crossCopiedAt = Number((crossTabPayload as any)?.copiedAt || 0);
        const shouldHydrateFromCrossTab = !!crossTabPayload && (
            !clipAny ||
            (Number.isFinite(crossCopiedAt) && crossCopiedAt > localCopiedAt)
        );

        if (shouldHydrateFromCrossTab) {
            e.preventDefault();
            try {
                const hydrated = await hydrateRuntimeClipboardFromCrossTabPayload(crossTabPayload);
                if (hydrated) {
                    clipAny = hydrated;
                    (window as any)._clipboard = hydrated;
                } else if (!clipAny) {
                    return;
                }
            } catch (err) {
                console.warn('[clipboard] Falha ao hidratar clipboard cross-tab', err);
                if (!clipAny) return;
            }
        }
        if (clipAny) {
            e.preventDefault();

            // CRITICAL: Get active object BEFORE discarding to check parent group
            const activeBeforePaste = canvas.value.getActiveObject();

            try {
                // Clipboard v2 (multi-items) format
                const isV2 = !!clipAny?.kind && clipAny.kind === 'fabric-items-v2' && Array.isArray(clipAny.items);
                if (isV2) {
                    const clipData = clipAny as any;
                    const items: any[] = (clipData.items || []).slice();
                    if (!items.length) return;

                    const viewCenter = getCenterOfView();
                    const selectionCenter = clipData.selectionCenter || { x: viewCenter.x, y: viewCenter.y };
                    const pasted: any[] = [];
                    const idMap = new Map<string, string>();
                    const existingIds = new Set<string>((canvas.value.getObjects?.() || [])
                        .map((o: any) => String(o?._customId || '').trim())
                        .filter(Boolean));

                    // Special-case: single copied inner image -> paste back into product card if it exists.
                    if (items.length === 1) {
                        const clipItem = items[0];
                        const cloned: any = await (clipItem as any).clone(CLIPBOARD_CLONE_PROPS);

                        let originalParentGroup: any = null;
                        const sourceGroupId = (clipItem as any)._sourceGroupId;
                        const sourceGroupRef = (clipItem as any)._sourceGroupRef;
                        if (sourceGroupId || sourceGroupRef) {
                            const allObjects = canvas.value.getObjects();
                            if (sourceGroupId) {
                                originalParentGroup = allObjects.find((obj: any) =>
                                    obj._customId === sourceGroupId &&
                                    obj.type === 'group' &&
                                    (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))
                                ) || null;
                            }
                            if (!originalParentGroup && sourceGroupRef) {
                                originalParentGroup = allObjects.find((obj: any) =>
                                    obj === sourceGroupRef &&
                                    (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))
                                ) || null;
                            }
                        }
                        if (!originalParentGroup && activeBeforePaste && String(activeBeforePaste.type || '').toLowerCase() === 'image') {
                            const allObjects = canvas.value.getObjects();
                            for (const obj of allObjects) {
                                if (obj.type === 'group' && (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))) {
                                    if (typeof obj.getObjects === 'function') {
                                        const children = obj.getObjects();
                                        const containsActiveImage = children.some((child: any) =>
                                            child === activeBeforePaste ||
                                            child._customId === (activeBeforePaste as any)._customId
                                        );
                                        if (containsActiveImage) {
                                            originalParentGroup = obj;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if (!originalParentGroup && activeBeforePaste) {
                            if (activeBeforePaste.type === 'group' && (activeBeforePaste.isSmartObject || activeBeforePaste.isProductCard || isLikelyProductCard(activeBeforePaste))) {
                                originalParentGroup = activeBeforePaste;
                            } else if ((activeBeforePaste as any).group) {
                                const parentGroup = (activeBeforePaste as any).group;
                                if (parentGroup.isSmartObject || parentGroup.isProductCard || isLikelyProductCard(parentGroup)) {
                                    originalParentGroup = parentGroup;
                                }
                            }
                        }

                        const isProductCardGroup =
                            originalParentGroup &&
                            String(originalParentGroup.type || '').toLowerCase() === 'group' &&
                            (originalParentGroup.isSmartObject || originalParentGroup.isProductCard || String(originalParentGroup.name || '').startsWith('product-card') || isLikelyProductCard(originalParentGroup));
                        const isInnerImage = String((clipItem as any).type || '').toLowerCase() === 'image';

                        canvas.value.discardActiveObject();

                        if (isProductCardGroup && isInnerImage && originalParentGroup) {
                            // Paste inside the existing card group.
                            regenerateCustomIdsRecursive(cloned, idMap);
                            remapOrClearBindingsRecursive(cloned, idMap, existingIds);

                            let targetLeft = Number((clipItem as any)._sourceLeft) || 0;
                            let targetTop = Number((clipItem as any)._sourceTop) || 0;
                            targetLeft += 20;
                            targetTop += 20;
                            const targetCanvas = groupLocalToCanvasPoint(originalParentGroup, targetLeft, targetTop);
                            cloned.set({
                                left: targetCanvas.x,
                                top: targetCanvas.y,
                                originX: 'center',
                                originY: 'center',
                                angle: (clipItem as any).angle || 0,
                                scaleX: (clipItem as any).scaleX || 1,
                                scaleY: (clipItem as any).scaleY || 1,
                                flipX: !!(clipItem as any).flipX,
                                flipY: !!(clipItem as any).flipY,
                                opacity: (clipItem as any).opacity ?? 1,
                                selectable: true,
                                evented: true,
                                hasControls: true,
                                hasBorders: true,
                            });

                            safeAddWithUpdate(originalParentGroup, cloned);
                            originalParentGroup.set({ subTargetCheck: true, interactive: true });
                            originalParentGroup.setCoords?.();
                            canvas.value.setActiveObject(cloned);
                            canvas.value.requestRenderAll();
                            refreshCanvasObjects();
                            saveCurrentState({ reason: 'paste' });
                            return;
                        }

                        // Fall through to regular multi-paste path by treating it as a 1-item list.
                        items.length = 0;
                        items.push(clipItem);
                    }

                    canvas.value.discardActiveObject();

                    for (const clipItem of items) {
                        if (!clipItem) continue;
                        const cloned: any = await (clipItem as any).clone(CLIPBOARD_CLONE_PROPS);
                        const cx = Number((clipItem as any)._clipboardCenterX);
                        const cy = Number((clipItem as any)._clipboardCenterY);
                        const dx = (Number.isFinite(cx) ? cx : Number(cloned.left || 0)) - Number(selectionCenter.x || 0);
                        const dy = (Number.isFinite(cy) ? cy : Number(cloned.top || 0)) - Number(selectionCenter.y || 0);

                        cloned.set({
                            left: Number(viewCenter.x || 0) + dx + 20,
                            top: Number(viewCenter.y || 0) + dy + 20,
                            originX: 'center',
                            originY: 'center',
                            evented: true,
                            selectable: true,
                        });

                        regenerateCustomIdsRecursive(cloned, idMap);
                        pasted.push(cloned);
                    }

                    // Rebind children to the newly pasted frame/zone ids (and clear dangling refs).
                    pasted.forEach((obj) => remapOrClearBindingsRecursive(obj, idMap, existingIds));

                    // Add all objects to canvas, then run the same finalization used by duplicate.
                    pasted.forEach((obj) => {
                        try {
                            if (obj) canvas.value.add(obj);
                        } catch (addErr) {
                            console.warn('[clipboard] Falha ao adicionar objeto colado:', addErr);
                        }
                    });

                    finalizeDuplicatedObjects(pasted);
                    saveCurrentState({ reason: 'paste' });
                    return;
                }

                // Clipboard v1 (single fabric clone) format (backward compatible)
                const clip = clipAny;
                const cloned: any = await (clip as any).clone(CLIPBOARD_CLONE_PROPS);

                // Find product card group context (same logic as before)
                let originalParentGroup = null;
                const sourceGroupId = (clip as any)._sourceGroupId;
                const sourceGroupRef = (clip as any)._sourceGroupRef;
                if (sourceGroupId || sourceGroupRef) {
                    const allObjects = canvas.value.getObjects();
                    if (sourceGroupId) {
                        originalParentGroup = allObjects.find((obj: any) =>
                            obj._customId === sourceGroupId &&
                            obj.type === 'group' &&
                            (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))
                        ) || null;
                    }
                    if (!originalParentGroup && sourceGroupRef) {
                        originalParentGroup = allObjects.find((obj: any) =>
                            obj === sourceGroupRef &&
                            (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))
                        ) || null;
                    }
                }
                if (!originalParentGroup && activeBeforePaste && String(activeBeforePaste.type || '').toLowerCase() === 'image') {
                    const allObjects = canvas.value.getObjects();
                    for (const obj of allObjects) {
                        if (obj.type === 'group' && (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))) {
                            if (typeof obj.getObjects === 'function') {
                                const children = obj.getObjects();
                                const containsActiveImage = children.some((child: any) =>
                                    child === activeBeforePaste ||
                                    child._customId === activeBeforePaste._customId
                                );
                                if (containsActiveImage) {
                                    originalParentGroup = obj;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (!originalParentGroup && activeBeforePaste) {
                    if (activeBeforePaste.type === 'group' && (activeBeforePaste.isSmartObject || activeBeforePaste.isProductCard || isLikelyProductCard(activeBeforePaste))) {
                        originalParentGroup = activeBeforePaste;
                    } else if ((activeBeforePaste as any).group) {
                        const parentGroup = (activeBeforePaste as any).group;
                        if (parentGroup.isSmartObject || parentGroup.isProductCard || isLikelyProductCard(parentGroup)) {
                            originalParentGroup = parentGroup;
                        }
                    }
                }

                const isProductCardGroup =
                    originalParentGroup &&
                    String(originalParentGroup.type || '').toLowerCase() === 'group' &&
                    (originalParentGroup.isSmartObject || originalParentGroup.isProductCard || String(originalParentGroup.name || '').startsWith('product-card') || isLikelyProductCard(originalParentGroup));
                const isInnerImage = String((clip as any).type || '').toLowerCase() === 'image';

                canvas.value.discardActiveObject();

                // If pasting an image that was inside a product card, paste it back into the same group
                if (isProductCardGroup && isInnerImage && originalParentGroup) {
                    const idMap = new Map<string, string>();
                    const existingIds = new Set<string>((canvas.value.getObjects?.() || [])
                        .map((o: any) => String(o?._customId || '').trim())
                        .filter(Boolean));
                    regenerateCustomIdsRecursive(cloned, idMap);
                    remapOrClearBindingsRecursive(cloned, idMap, existingIds);

                    let targetLeft = Number((clip as any)._sourceLeft) || 0;
                    let targetTop = Number((clip as any)._sourceTop) || 0;
                    targetLeft += 20;
                    targetTop += 20;
                    const targetCanvas = groupLocalToCanvasPoint(originalParentGroup, targetLeft, targetTop);

                    cloned.set({
                        left: targetCanvas.x,
                        top: targetCanvas.y,
                        originX: 'center',
                        originY: 'center',
                        angle: (clip as any).angle || 0,
                        scaleX: (clip as any).scaleX || 1,
                        scaleY: (clip as any).scaleY || 1,
                        flipX: !!(clip as any).flipX,
                        flipY: !!(clip as any).flipY,
                        opacity: (clip as any).opacity ?? 1,
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true,
                    });

                    safeAddWithUpdate(originalParentGroup, cloned);
                    originalParentGroup.set({ subTargetCheck: true, interactive: true });
                    originalParentGroup.setCoords?.();

                    canvas.value.setActiveObject(cloned);
                    canvas.value.requestRenderAll();
                    refreshCanvasObjects();
                    saveCurrentState({ reason: 'paste' });
                } else {
                    // Regular paste behavior for non-product-card objects
                    const idMap = new Map<string, string>();
                    const existingIds = new Set<string>((canvas.value.getObjects?.() || [])
                        .map((o: any) => String(o?._customId || '').trim())
                        .filter(Boolean));
                    regenerateCustomIdsRecursive(cloned, idMap);
                    remapOrClearBindingsRecursive(cloned, idMap, existingIds);

                    const center = getCenterOfView();
                    cloned.set({
                        left: (Number(center.x) || 0) + 20,
                        top: (Number(center.y) || 0) + 20,
                        originX: 'center',
                        originY: 'center',
                        evented: true,
                        selectable: true,
                    });

                    canvas.value.add(cloned);
                    finalizeDuplicatedObjects([cloned]);
                    saveCurrentState({ reason: 'paste' });
                }
            } catch (err) {
                console.warn('[clipboard] Falha ao colar (clone)', err);
            }
        }
    }

    // Tool Shortcuts
    if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        togglePenMode();
        return;
    }
    
    if (e.key === 'v' || e.key === 'V') {
        if (!isCtrl) {
            e.preventDefault();
            setTool('select');
            return;
        }
    }
    
    if (e.key === 't' || e.key === 'T') {
        if (!isCtrl) {
            e.preventDefault();
            addText();
            return;
        }
    }

    // Duplicate (Ctrl+D / Cmd+D)
    // - Normal objects: duplicate on canvas (like Figma).
    // - If a product card inner image is selected (deep select), duplicate inside the same card.
    if (isCtrl && String(e.key || '').toLowerCase() === 'd') {
        e.preventDefault();
        const active = canvas.value.getActiveObject();
        if (!active) return;

        // Frames: duplicate frame + everything inside it.
        // Fallback robusto: alguns frames legacy podem perder `isFrame` em runtime.
        const activeLayerName = String((active as any)?.layerName || '').trim().toUpperCase();
        const activeName = String((active as any)?.name || '').trim();
        const looksLikeFrame = !!(active as any)?.isFrame ||
            activeLayerName === 'FRAMER' ||
            activeLayerName === 'FRAME' ||
            /^FRAME(?:\s+\d+)?$/i.test(activeName) ||
            /^FRAMER(?:\s+\d+)?$/i.test(activeName);
        if (looksLikeFrame) {
            const duplicatedFrame = await duplicateFrameWithContents(active);
            if (duplicatedFrame) return;
        }

        try {
            const clones = await duplicateActiveObjectWithContext(active, { offsetX: DUPLICATE_OFFSET, offsetY: DUPLICATE_OFFSET });
            if (!clones.length) return;
            finalizeDuplicatedObjects(clones);
            const reason = isActiveSelectionObject(active) ? 'duplicate-selection-multi' : 'duplicate-selection';
            saveCurrentState({ reason });
        } catch (err) {
            console.warn('[duplicate] Falha ao duplicar seleção', err);
        }
        return;
    }

    // Group / Ungroup (Ctrl+G, Ctrl+Shift+G)
    if (isCtrl && e.key === 'g') {
        e.preventDefault();
        if (e.shiftKey) {
            ungroupSelection();
        } else {
            groupSelection();
        }
        return;
    }
}

const setupZoomPan = () => {
    if (!canvas.value) return; 
    if ((canvas.value as any).__zoomPanSetupDone) return;
    (canvas.value as any).__zoomPanSetupDone = true;

    // Helper to get pointer position from event (local to setupZoomPan)
    // Uses the same logic as Fabric.js internally - corrected calculation
    const getPointerFromEvent = (e: MouseEvent | any) => {
        if (!canvas.value) return { x: 0, y: 0 };
        
        // Try to get canvas element from canvas instance
        const canvasElement = canvasEl.value || canvas.value.getElement();
        if (!canvasElement) return { x: 0, y: 0 };
        
        const rect = canvasElement.getBoundingClientRect();
        const vpt = canvas.value.viewportTransform || [1, 0, 0, 1, 0, 0];
        const zoom = canvas.value.getZoom() || 1;
        
        // Get mouse position relative to canvas element (in pixels)
        const pointerX = e.clientX - rect.left;
        const pointerY = e.clientY - rect.top;
        
        // Transform to canvas coordinates using Fabric.js transform logic
        // The viewport transform matrix is: [zoom, 0, 0, zoom, translateX, translateY]
        // vpt[4] = translateX (pan X), vpt[5] = translateY (pan Y)
        // 
        // IMPORTANT: The viewport transform applies: newX = (oldX * zoom) + translateX
        // So to reverse: oldX = (newX - translateX) / zoom
        // But we need to account for the fact that vpt[4] and vpt[5] are already in screen space
        const canvasX = (pointerX - vpt[4]) / zoom;
        const canvasY = (pointerY - vpt[5]) / zoom;
        
        return { x: canvasX, y: canvasY };
    };

    // Wheel Zoom & Pan (coalesced in RAF to avoid stutter on trackpads/high-frequency wheels)
    let wheelRafPending = false;
    let wheelAccumZoomDelta = 0;
    let wheelAccumPanX = 0;
    let wheelAccumPanY = 0;
    let wheelZoomPoint = { x: 0, y: 0 };
    let wheelMode: 'none' | 'zoom' | 'pan' = 'none';

    const flushWheel = () => {
        wheelRafPending = false;
        if (!canvas.value) return;

        if (wheelMode === 'zoom') {
            let zoom = canvas.value.getZoom();
            // Apply the accumulated delta only once per frame for smoother zoom.
            zoom *= 0.999 ** wheelAccumZoomDelta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            canvas.value.zoomToPoint(wheelZoomPoint, zoom);
            updateZoomState();
            safeRequestRenderAll();
            updateFloatingUI();
            scheduleViewportCulling('wheel-zoom');
            scheduleViewportStateSave('wheel-zoom');
        } else if (wheelMode === 'pan') {
            const vpt = canvas.value.viewportTransform;
            if (vpt) {
                vpt[4] += wheelAccumPanX;
                vpt[5] += wheelAccumPanY;
                safeRequestRenderAll();
                updateFloatingUI();
                throttledUpdateScrollbars();
                scheduleViewportCulling('wheel-pan');
                scheduleViewportStateSave('wheel-pan');
            }
        }

        wheelAccumZoomDelta = 0;
        wheelAccumPanX = 0;
        wheelAccumPanY = 0;
        wheelMode = 'none';
    };

    const scheduleWheelFlush = () => {
        if (wheelRafPending) return;
        wheelRafPending = true;
        requestAnimationFrame(flushWheel);
    };

    canvas.value.on('mouse:wheel', (opt: any) => {
        const evt = opt.e;
        if (!evt) return;
        const deltaY = Number(evt.deltaY || 0);
        const deltaX = Number(evt.deltaX || 0);

        // Ctrl/Cmd + Wheel to ZOOM
        if (evt.ctrlKey || evt.metaKey) {
            wheelMode = 'zoom';
            wheelAccumZoomDelta += deltaY;
            wheelZoomPoint = { x: Number(evt.offsetX || 0), y: Number(evt.offsetY || 0) };
        } else {
            wheelMode = 'pan';
            // Vertical pan by default
            wheelAccumPanY -= deltaY;
            // Horizontal pan with shift or native deltaX
            if (evt.shiftKey || deltaX !== 0) {
                wheelAccumPanX -= (deltaX || deltaY);
            }
        }

        scheduleWheelFlush();
        evt.preventDefault();
        evt.stopPropagation();
    });

    // Touch Gesture (tablet): two-finger pinch to zoom + pan viewport.
    // Keep one-finger interaction untouched so object selection/editing keeps working.
    let isTouchGestureActive = false;
    let touchStartDistance = 0;
    let touchStartZoom = 1;
    let touchLastCenter = { x: 0, y: 0 };
    let touchPrevSkipTargetFind: boolean | null = null;
    let touchPrevSelection: boolean | null = null;
    let touchRafPending = false;
    let touchPendingCenter: { x: number; y: number } | null = null;
    let touchPendingDistance = 0;
    let touchTapStartAt = 0;
    let touchTapStartX = 0;
    let touchTapStartY = 0;
    let touchTapMoved = false;
    let lastSingleTapAt = 0;
    let lastSingleTapX = 0;
    let lastSingleTapY = 0;
    const TOUCH_TAP_MAX_MOVEMENT = 16;
    const TOUCH_DBL_TAP_MS = 360;
    const TOUCH_DBL_TAP_MAX_GAP = 36;

    const clampZoom = (value: number) => {
        if (value > 20) return 20;
        if (value < 0.01) return 0.01;
        return value;
    };

    const getTouchCenter = (touches: TouchList) => {
        const t1 = touches[0];
        const t2 = touches[1];
        if (!t1 || !t2) {
            return { x: 0, y: 0 };
        }
        return {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        };
    };

    const getTouchDistance = (touches: TouchList) => {
        const t1 = touches[0];
        const t2 = touches[1];
        if (!t1 || !t2) return 1;
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        return Math.hypot(dx, dy);
    };

    const centerToCanvasPoint = (clientX: number, clientY: number) => {
        const canvasElement = canvasEl.value || canvas.value?.getElement?.();
        if (!canvasElement) return { x: 0, y: 0 };
        const rect = canvasElement.getBoundingClientRect();
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    };

    const beginTouchGesture = (touches: TouchList) => {
        if (!canvas.value || touches.length < 2) return;
        isTouchGestureActive = true;
        touchStartDistance = Math.max(1, getTouchDistance(touches));
        touchStartZoom = canvas.value.getZoom() || 1;
        touchLastCenter = getTouchCenter(touches);
        touchPendingCenter = touchLastCenter;
        touchPendingDistance = touchStartDistance;

        // Performance: while multi-touching, we don't need Fabric hit-tests.
        if (touchPrevSkipTargetFind === null) touchPrevSkipTargetFind = !!canvas.value.skipTargetFind;
        if (touchPrevSelection === null) touchPrevSelection = !!canvas.value.selection;
        canvas.value.skipTargetFind = true;
        canvas.value.selection = false;
    };

    const endTouchGesture = () => {
        isTouchGestureActive = false;
        touchStartDistance = 0;
        touchPendingCenter = null;
        touchPendingDistance = 0;
        // Restore Fabric hit-test flags.
        if (canvas.value) {
            if (touchPrevSkipTargetFind !== null) canvas.value.skipTargetFind = touchPrevSkipTargetFind;
            if (touchPrevSelection !== null) canvas.value.selection = touchPrevSelection;
        }
        touchPrevSkipTargetFind = null;
        touchPrevSelection = null;
    };

    const fireSyntheticDblClickFromTouch = (evt: TouchEvent) => {
        if (!canvas.value) return;
        const now = Date.now();
        if (now - lastDomDblClickAt < 220) return;
        lastDomDblClickAt = now;

        const touch = evt.changedTouches?.[0] || evt.touches?.[0];
        if (!touch) return;

        let syntheticMouseEvent: any = null;
        try {
            syntheticMouseEvent = new MouseEvent('dblclick', {
                bubbles: true,
                cancelable: true,
                clientX: touch.clientX,
                clientY: touch.clientY,
                screenX: touch.screenX,
                screenY: touch.screenY,
                ctrlKey: evt.ctrlKey,
                shiftKey: evt.shiftKey,
                altKey: evt.altKey,
                metaKey: evt.metaKey
            });
        } catch {
            syntheticMouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                screenX: touch.screenX,
                screenY: touch.screenY,
                ctrlKey: evt.ctrlKey,
                shiftKey: evt.shiftKey,
                altKey: evt.altKey,
                metaKey: evt.metaKey,
                target: evt.target
            };
        }

        const c: any = canvas.value as any;
        let info: any = null;
        try {
            info = (typeof c.findTarget === 'function') ? c.findTarget(syntheticMouseEvent) : null;
        } catch {
            info = null;
        }
        const target = info?.target ?? info ?? null;
        try {
            c.fire?.('mouse:dblclick', { e: syntheticMouseEvent, originalEvent: evt, target });
        } catch {
            // ignore
        }
    };

    if (canvas.value?.upperCanvasEl && !domCanvasTouchStartHandler) {
        const flushTouchGesture = () => {
            touchRafPending = false;
            if (!canvas.value || !isTouchGestureActive || !touchPendingCenter) return;

            const currentCenter = touchPendingCenter;
            const currentDistance = Math.max(1, touchPendingDistance || 1);
            const scaleFactor = currentDistance / Math.max(1, touchStartDistance);
            const nextZoom = clampZoom(touchStartZoom * scaleFactor);

            const centerPoint = centerToCanvasPoint(currentCenter.x, currentCenter.y);
            canvas.value.zoomToPoint(centerPoint as any, nextZoom);

            const vpt = canvas.value.viewportTransform;
            if (vpt) {
                vpt[4] += currentCenter.x - touchLastCenter.x;
                vpt[5] += currentCenter.y - touchLastCenter.y;
            }

            touchLastCenter = currentCenter;
            updateZoomState();
            safeRequestRenderAll();
            updateFloatingUI();
            throttledUpdateScrollbars();
            scheduleViewportCulling('touch-gesture');
            scheduleViewportStateSave('touch-gesture');
        };

        const scheduleTouchFlush = () => {
            if (touchRafPending) return;
            touchRafPending = true;
            requestAnimationFrame(flushTouchGesture);
        };

        domCanvasTouchStartHandler = (evt: TouchEvent) => {
            if (!canvas.value) return;
            if (evt.touches.length === 1 && !isTouchGestureActive) {
                const t = evt.touches[0];
                if (t) {
                    touchTapStartAt = Date.now();
                    touchTapStartX = t.clientX;
                    touchTapStartY = t.clientY;
                    touchTapMoved = false;
                }
                return;
            }
            if (evt.touches.length < 2) return;
            touchTapStartAt = 0;
            touchTapMoved = true;
            beginTouchGesture(evt.touches);
            evt.preventDefault();
            evt.stopPropagation();
        };

        domCanvasTouchMoveHandler = (evt: TouchEvent) => {
            if (!canvas.value) return;
            if (evt.touches.length === 1 && !isTouchGestureActive) {
                const t = evt.touches[0];
                if (t && touchTapStartAt > 0) {
                    const move = Math.hypot(t.clientX - touchTapStartX, t.clientY - touchTapStartY);
                    if (move > TOUCH_TAP_MAX_MOVEMENT) touchTapMoved = true;
                }
                return;
            }
            if (evt.touches.length < 2) return;

            if (!isTouchGestureActive) {
                beginTouchGesture(evt.touches);
            }

            // Coalesce high-frequency touch events into a single RAF update (much smoother on tablets).
            touchPendingCenter = getTouchCenter(evt.touches);
            touchPendingDistance = Math.max(1, getTouchDistance(evt.touches));
            scheduleTouchFlush();

            evt.preventDefault();
            evt.stopPropagation();
        };

        domCanvasTouchEndHandler = (evt: TouchEvent) => {
            if (evt.touches.length < 2) {
                endTouchGesture();
                flushViewportStateSave('touch-gesture-end');
            }

            // Tablet fallback: convert double-tap into Fabric `mouse:dblclick`.
            if (isTouchGestureActive) return;
            const changed = evt.changedTouches?.[0];
            if (!changed) {
                touchTapStartAt = 0;
                return;
            }

            const now = Date.now();
            const tapDuration = touchTapStartAt > 0 ? (now - touchTapStartAt) : Number.POSITIVE_INFINITY;
            const endMove = touchTapStartAt > 0
                ? Math.hypot(changed.clientX - touchTapStartX, changed.clientY - touchTapStartY)
                : Number.POSITIVE_INFINITY;
            const isQuickTap = tapDuration <= 320 && endMove <= TOUCH_TAP_MAX_MOVEMENT && !touchTapMoved;

            if (isQuickTap) {
                const gap = now - lastSingleTapAt;
                const distanceFromPrevTap = Math.hypot(changed.clientX - lastSingleTapX, changed.clientY - lastSingleTapY);
                if (gap > 0 && gap <= TOUCH_DBL_TAP_MS && distanceFromPrevTap <= TOUCH_DBL_TAP_MAX_GAP) {
                    fireSyntheticDblClickFromTouch(evt);
                    lastSingleTapAt = 0;
                    lastSingleTapX = 0;
                    lastSingleTapY = 0;
                } else {
                    lastSingleTapAt = now;
                    lastSingleTapX = changed.clientX;
                    lastSingleTapY = changed.clientY;
                }
            } else if (tapDuration <= 0 || tapDuration > 1200) {
                lastSingleTapAt = 0;
                lastSingleTapX = 0;
                lastSingleTapY = 0;
            }

            touchTapStartAt = 0;
            touchTapMoved = false;
        };

        domCanvasTouchCancelHandler = () => {
            endTouchGesture();
        };

        canvas.value.upperCanvasEl.addEventListener('touchstart', domCanvasTouchStartHandler, { passive: false });
        canvas.value.upperCanvasEl.addEventListener('touchmove', domCanvasTouchMoveHandler as EventListener, { passive: false });
        canvas.value.upperCanvasEl.addEventListener('touchend', domCanvasTouchEndHandler, { passive: true });
        canvas.value.upperCanvasEl.addEventListener('touchcancel', domCanvasTouchCancelHandler, { passive: true });
    }

    // Middle Click Pan / Space Pan logic often handled by keydown space
    let isDragging = false;
    let lastPosX = 0;
    let lastPosY = 0;
    let panDxPending = 0;
    let panDyPending = 0;
    let panRafPending = false;
    let panPrevSelection: boolean | null = null;
    let panPrevSkipTargetFind: boolean | null = null;
    const restorePanInteractionFlags = () => {
        if (!canvas.value) {
            panPrevSelection = null;
            panPrevSkipTargetFind = null;
            return;
        }
        if (panPrevSelection !== null) {
            canvas.value.selection = panPrevSelection;
        } else {
            canvas.value.selection = true;
        }
        if (panPrevSkipTargetFind !== null) {
            canvas.value.skipTargetFind = panPrevSkipTargetFind;
        } else {
            canvas.value.skipTargetFind = false;
        }
        panPrevSelection = null;
        panPrevSkipTargetFind = null;
    };
    const flushPan = () => {
        if (!canvas.value || !canvas.value.viewportTransform) return;
        if (panDxPending !== 0 || panDyPending !== 0) {
            canvas.value.viewportTransform[4] += panDxPending;
            canvas.value.viewportTransform[5] += panDyPending;
            panDxPending = 0;
            panDyPending = 0;
        }
        safeRequestRenderAll();
        throttledUpdateScrollbars();
        scheduleViewportCulling('pan-drag');
        scheduleViewportStateSave('pan-drag');
    };
    const schedulePanFlush = () => {
        if (panRafPending) return;
        panRafPending = true;
        requestAnimationFrame(() => {
            panRafPending = false;
            flushPan();
        });
    };

    canvas.value.on('mouse:down', (opt: any) => {
        const evt = opt.e;

        // Pan with middle mouse button OR Space + left click.
        if (
            (evt?.button === 1 || (evt?.button === 0 && isSpacePanPressed)) &&
            !isPenMode.value &&
            !isNodeEditing.value &&
            !isDrawing.value
        ) {
            isDragging = true;
            lastPosX = evt.clientX;
            lastPosY = evt.clientY;
            if (panPrevSelection === null) panPrevSelection = !!canvas.value.selection;
            if (panPrevSkipTargetFind === null) panPrevSkipTargetFind = !!canvas.value.skipTargetFind;
            canvas.value.selection = false;
            canvas.value.skipTargetFind = true;
            canvas.value.defaultCursor = 'grabbing';
            evt.preventDefault();
            evt.stopPropagation();
            return;
        }
        
        // Handle node selection during path editing (before pen tool check)
        if (isNodeEditing.value && opt.target && opt.target.name === 'path_node') {
            const index = opt.target.data.index;
            const pathObj = opt.target.data.parentPath;
            if (pathObj) {
                selectPathNode(index, pathObj);
            }
            return;
        }
        
        // Handle adding point to segment during path editing
        if (isNodeEditing.value && !opt.target && currentEditingPath.value) {
            // Click on empty space - try to add point to nearest segment
            const pointer = opt.pointer || getPointerFromEvent(evt);
            if (pointer) {
                const pathObj = currentEditingPath.value;
                const pathData = pathObj.penPathData || [];
                
                // Find nearest segment (supports closed paths too)
                let minDist = Infinity;
                let nearestSegmentIndex = -1;
                const closed = isVectorPathClosed(pathObj);
                const segmentCount = closed ? pathData.length : (pathData.length - 1);

                for (let i = 0; i < segmentCount; i++) {
                    const p1 = pathData[i];
                    const p2 = pathData[(i + 1) % pathData.length];
                    
                    // Calculate distance from point to line segment
                    const A = pointer.x - p1.x;
                    const B = pointer.y - p1.y;
                    const C = p2.x - p1.x;
                    const D = p2.y - p1.y;
                    
                    const dot = A * C + B * D;
                    const lenSq = C * C + D * D;
                    let param = -1;
                    
                    if (lenSq !== 0) param = dot / lenSq;
                    
                    let xx, yy;
                    if (param < 0) {
                        xx = p1.x;
                        yy = p1.y;
                    } else if (param > 1) {
                        xx = p2.x;
                        yy = p2.y;
                    } else {
                        xx = p1.x + param * C;
                        yy = p1.y + param * D;
                    }
                    
                    const dx = pointer.x - xx;
                    const dy = pointer.y - yy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < minDist && dist < 10) { // 10px threshold
                        minDist = dist;
                        nearestSegmentIndex = i;
                    }
                }
                
                if (nearestSegmentIndex >= 0) {
                    addPointAtSegment(pathObj, nearestSegmentIndex, pointer);
                    evt.preventDefault();
                    evt.stopPropagation();
                    return;
                }
            }
        }
        
        // Pen Tool Mode - Add point on click (works on frames and empty areas)
        if (isPenMode.value) {
            // Try multiple methods to get accurate pointer coordinates
            let pointer;
            
            // Method 1: Use Fabric's opt.pointer if available
            if (opt.pointer && typeof opt.pointer.x === 'number' && typeof opt.pointer.y === 'number') {
                pointer = opt.pointer;
            }
            // Method 2: Try Fabric's internal _getPointer method
            else if (typeof (canvas.value as any)._getPointer === 'function') {
                try {
                    pointer = (canvas.value as any)._getPointer(evt);
                } catch (e) {
                    // Fall through to manual calculation
                }
            }
            
            // Method 3: Fallback to manual calculation
            if (!pointer || typeof pointer.x !== 'number' || typeof pointer.y !== 'number') {
                const clickEvt = evt || opt.e || opt.originalEvent;
                if (!clickEvt || typeof clickEvt.clientX === 'undefined') return;
                pointer = getPointerFromEvent(clickEvt);
            }
            
            addPenPoint(pointer, evt.shiftKey); // Shift = bezier handles
            evt.preventDefault();
            evt.stopPropagation();
            return;
        }
        
        // Double-click path to enter node editing
        if (opt.target && opt.target.isVectorPath && !isNodeEditing.value) {
            // Will be handled by mouse:dblclick
        }
        
        // Standard interaction handled by Fabric
    });
    
    // Pen Tool: Track mouse movement for preview line - REAL-TIME with RAF for smooth updates
    let rafPending = false;
    canvas.value.on('mouse:move', (opt: any) => {
        if (isDragging) {
            const evt = opt?.e;
            if (!evt) return;
            if (evt.buttons === 0) {
                isDragging = false;
                restorePanInteractionFlags();
                canvas.value.defaultCursor = isSpacePanPressed ? 'grab' : 'default';
                flushPan();
                flushViewportStateSave('pan-drag-end');
                return;
            }
            panDxPending += evt.clientX - lastPosX;
            panDyPending += evt.clientY - lastPosY;
            lastPosX = evt.clientX;
            lastPosY = evt.clientY;
            schedulePanFlush();
            return;
        }

        if (isPenMode.value && penPathPoints.value.length > 0) {
            // Get pointer coordinates - try multiple methods for maximum compatibility
            let pointer: {x: number, y: number} | null = null;
            
            // Method 1: Use Fabric's opt.pointer if available (most reliable - already transformed)
            if (opt.pointer && typeof opt.pointer.x === 'number' && typeof opt.pointer.y === 'number') {
                pointer = { x: opt.pointer.x, y: opt.pointer.y };
            }
            // Method 2: Try Fabric's internal _getPointer method (if available in this version)
            else if (typeof (canvas.value as any)._getPointer === 'function') {
                const evt = opt.e || opt.originalEvent;
                if (evt) {
                    try {
                        const fabricPointer = (canvas.value as any)._getPointer(evt);
                        if (fabricPointer && typeof fabricPointer.x === 'number' && typeof fabricPointer.y === 'number') {
                            pointer = { x: fabricPointer.x, y: fabricPointer.y };
                        }
                    } catch (e) {
                        // Fall through to manual calculation
                    }
                }
            }
            
            // Method 3: Fallback to manual calculation
            if (!pointer) {
                const evt = opt.e || opt.originalEvent;
                if (!evt || typeof evt.clientX === 'undefined') return;
                pointer = getPointerFromEvent(evt);
            }
            
            // Store the pointer coordinates
            if (pointer && typeof pointer.x === 'number' && typeof pointer.y === 'number') {
                currentMousePos.value = pointer;
                
                // Use requestAnimationFrame for smooth updates without blocking
                if (!rafPending) {
                    rafPending = true;
                    requestAnimationFrame(() => {
                        updatePenPreview();
                        rafPending = false;
                    });
                }
            }
        }
    });
    
    // Clear mouse position when mouse leaves canvas in pen mode
    canvas.value.on('mouse:out', () => {
        if (isPenMode.value) {
            currentMousePos.value = null;
            updatePenPreview();
        }
    });
    
    // Removed manual drag logic for gridZone as it conflicted with default behavior

    canvas.value.on('mouse:dblclick', (opt: any) => {
        if (opt.target) {
            // Product zone import/edit on double-click:
            // works on zone itself and also on cards/children inside the zone.
            // Keep price label nested-edit (priceGroup) untouched.
            if (tryOpenProductReviewFromDblClickTarget(opt.target)) {
                return;
            } else if (opt.target.type === 'polygon' || opt.target.type === 'polyline') {
                enterNodeEditing(opt.target);
            } else if (opt.target.isVectorPath) {
                // Enter node editing for vector paths
                enterPathNodeEditing(opt.target);
            }
        } else if (isPenMode.value && penPathPoints.value.length >= 2) {
            // Double-click empty space in pen mode = finish path
            finishPenPath();
        }
    });
    
    
    // Node Moving Logic
    // Real-time path update throttling (scoped to setupZoomPan)
    let pathUpdateRaf: number | null = null;
    
    canvas.value.on('object:moving', (e: any) => {
        // Handle polygon/polyline control points
        if (isNodeEditing.value && e.target.name === 'control_point') {
             const p = e.target;
             const parent = p.data.parentObj;
             const index = p.data.index;
             
             // Inverse transform canvas point to polygon local point
             const matrix = parent.calcTransformMatrix();
             const invertMatrix = fabric.util.invertTransform(matrix);
             const localPoint = fabric.util.transformPoint({ x: p.left, y: p.top }, invertMatrix);
             
             // Update the specific point in the array
             const finalX = localPoint.x + parent.pathOffset.x;
             const finalY = localPoint.y + parent.pathOffset.y;
             
             parent.points[index] = { x: finalX, y: finalY };
             
             // Workaround: We wait until 'mouse:up' to commit changes to avoid heavy re-render loop
        }
        // Handle vector path nodes and handles - REAL-TIME UPDATE
        else if (isNodeEditing.value && (e.target.name === 'path_node' || e.target.name === 'bezier_handle')) {
            const target = e.target;
            const parentPath = target.data.parentPath;
            
            if (parentPath && parentPath.isVectorPath) {
                // Auto-mirror handles if moving a handle (Figma behavior - only if Alt is NOT pressed)
                // Alt key allows independent handle movement
                if (target.name === 'bezier_handle' && target.data.type && !e.e.altKey) {
                    const handleType = target.data.type;
                    const nodeIndex = target.data.index;
                    
                    // Get the node and both handles
                    const vpt = canvas.value.viewportTransform;
                    const zoom = canvas.value.getZoom();
                    
                    const nodes = canvas.value.getObjects().filter((o: any) => 
                        o.name === 'path_node' && o.data.parentPath === parentPath && o.data.index === nodeIndex
                    );
                    const handles = canvas.value.getObjects().filter((o: any) => 
                        o.name === 'bezier_handle' && o.data.parentPath === parentPath && o.data.index === nodeIndex
                    );
                    
                    if (nodes.length > 0 && handles.length >= 2) {
                        const node = nodes[0];
                        const handleIn = handles.find((h: any) => h.data.type === 'handle_in');
                        const handleOut = handles.find((h: any) => h.data.type === 'handle_out');
                        
                        if (handleIn && handleOut && node) {
                            const nodeX = (node.left - vpt[4]) / zoom;
                            const nodeY = (node.top - vpt[5]) / zoom;
                            
                            // Calculate distance from node to moved handle
                            const movedHandleX = (target.left - vpt[4]) / zoom;
                            const movedHandleY = (target.top - vpt[5]) / zoom;
                            
                            const dx = movedHandleX - nodeX;
                            const dy = movedHandleY - nodeY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 0) {
                                // Mirror the opposite handle (symmetric)
                                if (handleType === 'handle_in') {
                                    // Moving in handle - mirror out handle
                                    handleOut.set({
                                        left: (nodeX - dx) * zoom + vpt[4],
                                        top: (nodeY - dy) * zoom + vpt[5]
                                    });
                                } else {
                                    // Moving out handle - mirror in handle
                                    handleIn.set({
                                        left: (nodeX - dx) * zoom + vpt[4],
                                        top: (nodeY - dy) * zoom + vpt[5]
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Throttle updates using requestAnimationFrame
                if (pathUpdateRaf !== null) {
                    cancelAnimationFrame(pathUpdateRaf);
                }
                
                pathUpdateRaf = requestAnimationFrame(() => {
                    // Update path in real-time (skip save during movement)
                    updatePathFromNodes(parentPath, true);
                    // Update handle lines visually
                    updateHandleLines(parentPath);
                    pathUpdateRaf = null;
                });
            }
        } else {
             handleInteraction();
        }
    });
    
	    canvas.value.on('mouse:up', (opt: any) => {
        if (isDragging) {
            isDragging = false;
            restorePanInteractionFlags();
            canvas.value.defaultCursor = isSpacePanPressed ? 'grab' : 'default';
            flushPan();
            flushViewportStateSave('pan-drag-end');
            return;
        }
        
        // Commit Node Changes for polygons/polylines
        if (isNodeEditing.value) {
             const controls = canvas.value.getObjects().filter((o: any) => o.name === 'control_point');
	             if(controls.length > 0) {
	                 const parent = controls[0].data.parentObj;
	                 // Trigger update
	                 parent.set({ points: parent.points }); 
	                 // Fabric often needs _calcDimensions or similar
	                 parent._calcDimensions();
	                 parent.setCoords();
	                 canvas.value.requestRenderAll();
	             }
	        }
        
        // Commit Path Node Changes (final save)
        if (isNodeEditing.value) {
            const pathNodes = canvas.value.getObjects().filter((o: any) => o.name === 'path_node' || o.name === 'bezier_handle');
            if (pathNodes.length > 0) {
                const parentPath = pathNodes[0].data.parentPath;
                if (parentPath && parentPath.isVectorPath) {
                    // Rebuild path from updated nodes and save state
                    updatePathFromNodes(parentPath, false);
                }
            }
        }
        
	        // Remove direct guide access here as they are scoped to setupSnapping
	        // verticalGuide.set({ visible: false }); 
	        // horizontalGuide.set({ visible: false });
	        
	        flushZoneRelayoutOnDrop();
	        canvas.value.requestRenderAll();
        
        // Also ensure reactivity properties update on drop
        if (selectedObjectRef.value) {
             triggerRef(selectedObjectRef);
        }
    });
    
    // Update path from edited nodes
    const updatePathFromNodes = (pathObj: any, skipSave = false) => {
        const vpt = canvas.value.viewportTransform;
        const zoom = canvas.value.getZoom();
        
        const pathNodes = canvas.value.getObjects()
            .filter((o: any) => o.name === 'path_node' && o.data.parentPath === pathObj)
            .sort((a: any, b: any) => a.data.index - b.data.index);
        
        const handles = canvas.value.getObjects()
            .filter((o: any) => o.name === 'bezier_handle' && o.data.parentPath === pathObj);
        
        // Rebuild path data
        const updatedPathData = pathNodes.map((node: any) => {
            const localX = (node.left - vpt[4]) / zoom;
            const localY = (node.top - vpt[5]) / zoom;
            
            const handleIn = handles.find((h: any) => h.data.index === node.data.index && h.data.type === 'handle_in');
            const handleOut = handles.find((h: any) => h.data.index === node.data.index && h.data.type === 'handle_out');
            
            const point: any = { x: localX, y: localY };
            
            if (handleIn || handleOut) {
                point.handles = {};
                if (handleIn) {
                    point.handles.in = {
                        x: (handleIn.left - vpt[4]) / zoom,
                        y: (handleIn.top - vpt[5]) / zoom
                    };
                }
                if (handleOut) {
                    point.handles.out = {
                        x: (handleOut.left - vpt[4]) / zoom,
                        y: (handleOut.top - vpt[5]) / zoom
                    };
                }
            }
            
            return point;
        });
        
        const closed = isVectorPathClosed(pathObj) && updatedPathData.length > 2;
        const pathString = buildPathStringFromPenData(updatedPathData, closed);
        if (!pathString) return;
        
        // Update path
        pathObj.set('path', fabric.util.parsePath(pathString));
        pathObj.penPathData = updatedPathData;
        pathObj.isClosedPath = closed;
        pathObj.setCoords();
        canvas.value.requestRenderAll();
        
        // Only save state if not skipping (skip during real-time updates)
        if (!skipSave) {
            saveCurrentState();
        }
    }
}

// ============================================================================
// FIGMA CURVE FUNCTIONS - Convert, Mirror, Reset, Smooth
// ============================================================================

// Convert point to smooth (with handles)
const convertPointToSmooth = (pathObj: any, index: number) => {
    if (!pathObj || !pathObj.isVectorPath || !pathObj.penPathData) return;
    
    const pathData = pathObj.penPathData;
    if (index < 0 || index >= pathData.length) return;
    
    const point = pathData[index];
    
    // If point already has handles, make them symmetric
    if (point.handles) {
        smoothHandles(pathObj, index);
        return;
    }
    
    // Calculate direction from adjacent segments
    const prevPoint = index > 0 ? pathData[index - 1] : null;
    const nextPoint = index < pathData.length - 1 ? pathData[index + 1] : null;
    
    let handleLength = 30; // Default handle length
    
    if (prevPoint && nextPoint) {
        // Calculate average direction
        const dx1 = point.x - prevPoint.x;
        const dy1 = point.y - prevPoint.y;
        const dx2 = nextPoint.x - point.x;
        const dy2 = nextPoint.y - point.y;
        
        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        
        if (len1 > 0 && len2 > 0) {
            const avgDx = (dx1 / len1 + dx2 / len2) / 2;
            const avgDy = (dy1 / len1 + dy2 / len2) / 2;
            const avgLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
            
            if (avgLen > 0) {
                handleLength = Math.min(len1, len2) * 0.3;
                const normalizedDx = avgDx / avgLen;
                const normalizedDy = avgDy / avgLen;
                
                point.handles = {
                    in: {
                        x: point.x - normalizedDx * handleLength,
                        y: point.y - normalizedDy * handleLength
                    },
                    out: {
                        x: point.x + normalizedDx * handleLength,
                        y: point.y + normalizedDy * handleLength
                    }
                };
            }
        }
    } else if (prevPoint) {
        // Only previous point - use its direction
        const dx = point.x - prevPoint.x;
        const dy = point.y - prevPoint.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
            point.handles = {
                in: {
                    x: point.x - (dx / len) * handleLength,
                    y: point.y - (dy / len) * handleLength
                },
                out: {
                    x: point.x + (dx / len) * handleLength,
                    y: point.y + (dy / len) * handleLength
                }
            };
        }
    } else if (nextPoint) {
        // Only next point - use its direction
        const dx = nextPoint.x - point.x;
        const dy = nextPoint.y - point.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
            point.handles = {
                in: {
                    x: point.x - (dx / len) * handleLength,
                    y: point.y - (dy / len) * handleLength
                },
                out: {
                    x: point.x + (dx / len) * handleLength,
                    y: point.y + (dy / len) * handleLength
                }
            };
        }
    }
    
    // Rebuild path
    rebuildPathFromData(pathObj);
    // Refresh editing mode if active
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        exitNodeEditing();
        enterPathNodeEditing(pathObj);
    }
}

// Convert point to corner (remove handles)
const convertPointToCorner = (pathObj: any, index: number) => {
    if (!pathObj || !pathObj.isVectorPath || !pathObj.penPathData) return;
    
    const pathData = pathObj.penPathData;
    if (index < 0 || index >= pathData.length) return;
    
    const point = pathData[index];
    delete point.handles;
    
    // Rebuild path
    rebuildPathFromData(pathObj);
    // Refresh editing mode if active
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        exitNodeEditing();
        enterPathNodeEditing(pathObj);
    }
}

// Mirror handles (make symmetric)
const mirrorHandles = (pathObj: any, index: number) => {
    if (!pathObj || !pathObj.isVectorPath || !pathObj.penPathData) return;
    
    const pathData = pathObj.penPathData;
    if (index < 0 || index >= pathData.length) return;
    
    const point = pathData[index];
    if (!point.handles) return;
    
    // Get current handle positions from canvas if in editing mode
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        const vpt = canvas.value.viewportTransform;
        const zoom = canvas.value.getZoom();
        
        const handles = canvas.value.getObjects().filter((o: any) => 
            o.name === 'bezier_handle' && 
            o.data.parentPath === pathObj && 
            o.data.index === index
        );
        
        const handleIn = handles.find((h: any) => h.data.type === 'handle_in');
        const handleOut = handles.find((h: any) => h.data.type === 'handle_out');
        
        if (handleIn && handleOut) {
            // Calculate node position
            const nodes = canvas.value.getObjects().filter((o: any) => 
                o.name === 'path_node' && o.data.parentPath === pathObj && o.data.index === index
            );
            if (nodes.length > 0) {
                const node = nodes[0];
                const nodeX = (node.left - vpt[4]) / zoom;
                const nodeY = (node.top - vpt[5]) / zoom;
                
                const handleInX = (handleIn.left - vpt[4]) / zoom;
                const handleInY = (handleIn.top - vpt[5]) / zoom;
                
                // Calculate distance and angle
                const dx = handleInX - nodeX;
                const dy = handleInY - nodeY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Mirror: out handle should be opposite direction
                    point.handles.out = {
                        x: nodeX - dx,
                        y: nodeY - dy
                    };
                    
                    // Update handle position in canvas
                    handleOut.set({
                        left: point.handles.out.x * zoom + vpt[4],
                        top: point.handles.out.y * zoom + vpt[5]
                    });
                }
            }
        }
    } else {
        // Mirror based on stored data
        if (point.handles.in && point.handles.out) {
            const dx = point.handles.in.x - point.x;
            const dy = point.handles.in.y - point.y;
            point.handles.out = {
                x: point.x - dx,
                y: point.y - dy
            };
        }
    }
    
    rebuildPathFromData(pathObj);
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        updateHandleLines(pathObj);
        canvas.value.requestRenderAll();
    }
}

// Reset handles (remove them)
const resetHandles = (pathObj: any, index: number) => {
    convertPointToCorner(pathObj, index);
}

// Smooth handles (make symmetric and colinear)
const smoothHandles = (pathObj: any, index: number) => {
    if (!pathObj || !pathObj.isVectorPath || !pathObj.penPathData) return;
    
    const pathData = pathObj.penPathData;
    if (index < 0 || index >= pathData.length) return;
    
    const point = pathData[index];
    const prevPoint = index > 0 ? pathData[index - 1] : null;
    const nextPoint = index < pathData.length - 1 ? pathData[index + 1] : null;
    
    if (!prevPoint && !nextPoint) return;
    
    // Calculate average direction
    let avgDx = 0;
    let avgDy = 0;
    let totalWeight = 0;
    
    if (prevPoint) {
        const dx = point.x - prevPoint.x;
        const dy = point.y - prevPoint.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
            avgDx += dx / len;
            avgDy += dy / len;
            totalWeight += len;
        }
    }
    
    if (nextPoint) {
        const dx = nextPoint.x - point.x;
        const dy = nextPoint.y - point.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
            avgDx += dx / len;
            avgDy += dy / len;
            totalWeight += len;
        }
    }
    
    if (totalWeight > 0) {
        avgDx /= 2;
        avgDy /= 2;
        const avgLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
        
        if (avgLen > 0) {
            const normalizedDx = avgDx / avgLen;
            const normalizedDy = avgDy / avgLen;
            
            // Use average segment length for handle length
            let handleLength = 30;
            if (prevPoint && nextPoint) {
                const len1 = Math.sqrt(
                    Math.pow(point.x - prevPoint.x, 2) + 
                    Math.pow(point.y - prevPoint.y, 2)
                );
                const len2 = Math.sqrt(
                    Math.pow(nextPoint.x - point.x, 2) + 
                    Math.pow(nextPoint.y - point.y, 2)
                );
                handleLength = Math.min(len1, len2) * 0.3;
            }
            
            point.handles = {
                in: {
                    x: point.x - normalizedDx * handleLength,
                    y: point.y - normalizedDy * handleLength
                },
                out: {
                    x: point.x + normalizedDx * handleLength,
                    y: point.y + normalizedDy * handleLength
                }
            };
        }
    }
    
    // Rebuild path
    rebuildPathFromData(pathObj);
    // Refresh editing mode if active
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        exitNodeEditing();
        enterPathNodeEditing(pathObj);
    }
}

// Helper: Rebuild path from penPathData
const rebuildPathFromData = (pathObj: any) => {
    const pathData = pathObj.penPathData || [];
    if (pathData.length < 2) return;
    const closed = isVectorPathClosed(pathObj) && pathData.length > 2;
    pathObj.isClosedPath = closed;
    const pathString = buildPathStringFromPenData(pathData, closed);
    if (!pathString) return;
    pathObj.set('path', fabric.util.parsePath(pathString));
    pathObj.setCoords();
    canvas.value.requestRenderAll();
    saveCurrentState();
}

// Add point at segment midpoint
const addPointAtSegment = (pathObj: any, segmentIndex: number, position?: {x: number, y: number}) => {
    if (!pathObj || !pathObj.isVectorPath || !pathObj.penPathData) return;
    
    const pathData = pathObj.penPathData;
    const closed = isVectorPathClosed(pathObj);
    const maxSegmentIndex = closed ? (pathData.length - 1) : (pathData.length - 2);
    if (segmentIndex < 0 || segmentIndex > maxSegmentIndex) return;
    
    const point1 = pathData[segmentIndex];
    const point2 = closed
        ? pathData[(segmentIndex + 1) % pathData.length]
        : pathData[segmentIndex + 1];
    
    // Calculate midpoint or use provided position
    const newPoint: any = position || {
        x: (point1.x + point2.x) / 2,
        y: (point1.y + point2.y) / 2
    };
    
    // Insert new point
    pathData.splice(segmentIndex + 1, 0, newPoint);
    
    // Update indices in editing mode
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        exitNodeEditing();
        enterPathNodeEditing(pathObj);
    } else {
        rebuildPathFromData(pathObj);
    }
}

// Remove point from path
const removePathPoint = (pathObj: any, index: number) => {
    if (!pathObj || !pathObj.isVectorPath || !pathObj.penPathData) return;
    
    const pathData = pathObj.penPathData;
    const closed = isVectorPathClosed(pathObj);
    const minPoints = closed ? 3 : 2;
    if (index < 0 || index >= pathData.length || pathData.length <= minPoints) return;
    
    // Remove point
    pathData.splice(index, 1);
    
    // Clear selection
    selectedPathNodeIndex.value = null;
    
    // Rebuild path
    rebuildPathFromData(pathObj);
    
    // Refresh editing mode if active
    if (isNodeEditing.value && currentEditingPath.value === pathObj) {
        exitNodeEditing();
        enterPathNodeEditing(pathObj);
    }
}

let didLoadFonts = false

// When webfonts finish loading, Fabric's previous measurements may have been done with fallback fonts.
// That can permanently "shrink" manual templates because the fitting algorithm runs with wrong glyph widths.
// After clearing Fabric's font cache and re-initializing text dimensions, re-fit manual label templates.
const refitManualLabelTemplatesAfterFontMetrics = (canvasInstance: any) => {
    if (!canvasInstance || typeof canvasInstance.getObjects !== 'function') return;

    const seen = new Set<any>();
    const stack: any[] = [...(canvasInstance.getObjects() || [])];

    const isGroup = (o: any) => String(o?.type || '').toLowerCase() === 'group';
    const isPriceGroupCandidate = (o: any) => {
        if (!isGroup(o)) return false;
        if (String(o?.name || '') === 'priceGroup') return true;
        // Fallback heuristic (runtime-created groups might lose `name`).
        try {
            return typeof (isLikelyPriceGroupObject as any) === 'function' && (isLikelyPriceGroupObject as any)(o);
        } catch {
            return false;
        }
    };

    while (stack.length) {
        const obj = stack.pop();
        if (!obj || seen.has(obj)) continue;
        seen.add(obj);

        if (isPriceGroupCandidate(obj)) {
            try {
                // Ensure flags/base sizes exist (some older JSON may miss them).
                try {
                    restoreMissingManualTemplateFlags(obj);
                } catch {
                    // ignore
                }

                if (shouldPreserveManualTemplateVisual(obj)) {
                    // Force anchors to be recomputed with real font metrics (prevents stale currency/gap offsets).
                    try { delete (obj as any).__manualSingleAnchors; } catch { /* ignore */ }
                    // Re-fit dynamic values with correct font metrics.
                    if (isRedBurstPriceGroup(obj)) {
                        tuneRedBurstPriceGroupLayout(obj);
                    } else {
                        const all = collectObjectsDeep(obj);
                        const hasAtac = !!findByName(all, 'atac_retail_bg');
                        if (hasAtac) {
                            fitManualAtacarejoValuesIntoTemplate(obj);
                        } else {
                            fitManualSinglePriceValuesIntoTemplate(obj);
                        }
                    }
                }
            } catch {
                // best-effort only
            }
        }

        if (typeof obj.getObjects === 'function') {
            const kids = obj.getObjects() || [];
            for (const k of kids) stack.push(k);
        }
    }
};

const loadFonts = () => {
    if (didLoadFonts) return
    didLoadFonts = true

    // Only load WebFont on client-side (not during SSR)
    if (import.meta.client) {
        import('webfontloader').then((WebFontModule) => {
            const WebFont = WebFontModule.default || WebFontModule
            WebFont.load({
                google: {
                    families: GOOGLE_WEBFONT_FAMILIES
                },
                active: () => {
                    console.log("Fonts loaded!");
                    // CRITICAL: Clear Fabric's character-width cache so initDimensions()
                    // re-measures every glyph with the REAL font instead of reusing stale
                    // widths that were measured with the browser's fallback font.
                    try {
                        const fabricCache = (fabric as any)?.cache;
                        if (fabricCache && typeof fabricCache.clearFontCache === 'function') {
                            fabricCache.clearFontCache(); // wipe ALL font families
                        }
                    } catch (_e) { /* ignore */ }

                    if (canvas.value) {
                        const recalcText = (obj: any) => {
                            if (!obj) return;
                            const t = String(obj.type || '').toLowerCase();
                            if (t === 'i-text' || t === 'textbox' || t === 'text') {
                                if (typeof obj.initDimensions === 'function') obj.initDimensions();
                                obj.set('dirty', true);
                                if (typeof obj.setCoords === 'function') obj.setCoords();
                            }
                            // Recurse into groups (product cards, etc.)
                            if (typeof obj.getObjects === 'function') {
                                obj.getObjects().forEach(recalcText);
                                obj.set('dirty', true);
                            }
                        };
                        canvas.value.getObjects().forEach(recalcText);
                        // Re-run manual template fitting now that real font metrics are available.
                        // This is what keeps the product card label identical to the mini editor.
                        refitManualLabelTemplatesAfterFontMetrics(canvas.value);
                        canvas.value.requestRenderAll();
                    }
                }
            });
        })
    }
}

// --- User Guides (persistent, draggable via rulers) ---
const USER_GUIDE_COLOR = '#38bdf8'
const USER_GUIDE_EXTENT = 100000

const userGuidesIndex = ref<Array<{ id: string; axis: 'x' | 'y'; pos: number }>>([])

const isUserGuideObject = (o: any): boolean => {
    const id = String(o?.id || '')
    return !!o && (o.isUserGuide === true || o.guideAxis === 'x' || o.guideAxis === 'y' || id.startsWith('guide-user-'))
}

const getUserGuideAxisAndPos = (o: any): { axis: 'x' | 'y'; pos: number } | null => {
    if (!o) return null
    const axis = (o.guideAxis === 'x' || o.guideAxis === 'y')
        ? o.guideAxis
        : (typeof o.x1 === 'number' && typeof o.x2 === 'number' && Math.abs(o.x1 - o.x2) < 1e-6 ? 'x' : 'y')
    const pos = axis === 'x' ? Number(o.x1 ?? o.left ?? 0) : Number(o.y1 ?? o.top ?? 0)
    if (!Number.isFinite(pos)) return null
    return { axis, pos }
}

const refreshUserGuidesIndex = () => {
    if (!canvas.value) {
        userGuidesIndex.value = []
        return
    }
    const guides: Array<{ id: string; axis: 'x' | 'y'; pos: number }> = []
    const list = canvas.value.getObjects?.() || []
    for (const o of list) {
        if (!isUserGuideObject(o)) continue
        const id = String(o?.id || '').trim()
        if (!id) continue
        const meta = getUserGuideAxisAndPos(o)
        if (!meta) continue
        guides.push({ id, axis: meta.axis, pos: meta.pos })
    }
    userGuidesIndex.value = guides
}

const normalizeUserGuides = (canvasInstance: any) => {
    if (!canvasInstance || !fabric) return
    const list = canvasInstance.getObjects?.() || []
    let changed = false
    for (const o of list) {
        if (!isUserGuideObject(o)) continue
        const id = String(o?.id || '').trim()
        if (!id) continue
        const meta = getUserGuideAxisAndPos(o)
        if (!meta) continue

        // Force persistent/runtime props
        try {
            o.isUserGuide = true
            o.guideAxis = meta.axis
            o.excludeFromExport = true
            o.selectable = false
            o.evented = false
            o.hasControls = false
            o.hasBorders = false
            o.hoverCursor = 'default'
            o.stroke = USER_GUIDE_COLOR
            o.strokeWidth = 1
            o.opacity = 0.9
            o.strokeDashArray = [6, 4]
            o.visible = viewShowGuides.value

            if (meta.axis === 'x') {
                o.set?.({ x1: meta.pos, y1: -USER_GUIDE_EXTENT, x2: meta.pos, y2: USER_GUIDE_EXTENT })
            } else {
                o.set?.({ x1: -USER_GUIDE_EXTENT, y1: meta.pos, x2: USER_GUIDE_EXTENT, y2: meta.pos })
            }
            o.setCoords?.()
            changed = true
        } catch {
            // ignore
        }
    }
    if (changed) {
        try { ensureFramesBelowContents() } catch {}
        try { safeRequestRenderAll(canvasInstance) } catch {}
    }
    refreshUserGuidesIndex()
}

const applyUserGuidesVisibility = () => {
    if (!canvas.value) return
    const list = canvas.value.getObjects?.() || []
    let dirty = false
    for (const o of list) {
        if (!isUserGuideObject(o)) continue
        if (o.visible !== viewShowGuides.value) {
            o.set?.({ visible: viewShowGuides.value })
            dirty = true
        }
    }
    if (dirty) safeRequestRenderAll()
    refreshUserGuidesIndex()
}

const makeUserGuideId = (axis: 'x' | 'y') => {
    const rand = Math.random().toString(36).slice(2, 10)
    return axis === 'x' ? `guide-user-v-${rand}` : `guide-user-h-${rand}`
}

const handleCreateUserGuide = ({ axis, pos }: { axis: 'x' | 'y'; pos: number }) => {
    if (!canvas.value || !fabric) return
    const p = Number(pos || 0)
    if (!Number.isFinite(p)) return
    const id = makeUserGuideId(axis)
    const coords = axis === 'x'
        ? [p, -USER_GUIDE_EXTENT, p, USER_GUIDE_EXTENT]
        : [-USER_GUIDE_EXTENT, p, USER_GUIDE_EXTENT, p]
    const line = new fabric.Line(coords, {
        stroke: USER_GUIDE_COLOR,
        strokeWidth: 2,
        opacity: 0.95,
        strokeDashArray: [12, 6],
        strokeLineCap: 'round',
        strokeUniform: true,
        objectCaching: false,
        selectable: false,
        evented: false,
        visible: viewShowGuides.value,
        excludeFromExport: true
    })
    ;(line as any).id = id
    ;(line as any).isUserGuide = true
    ;(line as any).guideAxis = axis
    canvas.value.add(line)
    try { ensureFramesBelowContents() } catch {}
    safeRequestRenderAll()
    refreshUserGuidesIndex()
    saveCurrentState({ reason: 'guide-create' })
}

const handleUpdateUserGuide = ({ id, pos, commit }: { id: string; pos: number; commit?: boolean }) => {
    if (!canvas.value) return
    const target = (canvas.value.getObjects?.() || []).find((o: any) => String(o?.id || '') === String(id)) as any
    if (!target) return
    const meta = getUserGuideAxisAndPos(target)
    if (!meta) return
    const p = Number(pos || 0)
    if (!Number.isFinite(p)) return
    try {
        if (meta.axis === 'x') target.set?.({ x1: p, y1: -USER_GUIDE_EXTENT, x2: p, y2: USER_GUIDE_EXTENT })
        else target.set?.({ x1: -USER_GUIDE_EXTENT, y1: p, x2: USER_GUIDE_EXTENT, y2: p })
        target.setCoords?.()
    } catch {}
    safeRequestRenderAll()
    refreshUserGuidesIndex()
    if (commit !== false) saveCurrentState({ reason: 'guide-update' })
}

const handleDeleteUserGuide = ({ id }: { id: string }) => {
    if (!canvas.value) return
    const target = (canvas.value.getObjects?.() || []).find((o: any) => String(o?.id || '') === String(id)) as any
    if (!target) return
    try { canvas.value.remove(target) } catch {}
    safeRequestRenderAll()
    refreshUserGuidesIndex()
    saveCurrentState({ reason: 'guide-delete' })
}

const rulerGuides = computed(() => (viewShowGuides.value ? userGuidesIndex.value : []))

// --- Guias Inteligentes (Smart Guides) ---
// More visible + consistent at any zoom (strokeUniform).
const GUIDE_COLOR = '#ff2fb3';
const GUIDE_STROKE_WIDTH = 2;
const SNAP_RANGE_PX = 12;
const SNAP_HYSTERESIS_HOLD_FACTOR = 1.6;
const SNAP_HYSTERESIS_HOLD_FACTOR_RECT_IMAGE = 1.08;
const SNAP_MOVE_EPSILON_PX = 1.8;
const SNAP_MOVE_EPSILON_PX_RECT_IMAGE = 9;
const SNAP_RANGE_FACTOR_RECT_IMAGE = 0.28;

const setupSnapping = () => {
    if (!canvas.value) return;

    if (teardownSnapping) {
        teardownSnapping();
        teardownSnapping = null;
    }
    if (!canvas.value) return;
    const canvasInstance = canvas.value;

    // Defensive cleanup for old guide instances left from prior setup runs.
    const staleGuides = canvasInstance
        .getObjects()
        .filter((o: any) => o?.id === 'guide-vertical' || o?.id === 'guide-horizontal');
    staleGuides.forEach((g: any) => {
        try {
            canvasInstance.remove(g);
        } catch {
            // ignore stale guide removal errors
        }
    });

    const verticalGuide = new fabric.Line([0, 0, 0, 100], {
        stroke: GUIDE_COLOR,
        strokeWidth: GUIDE_STROKE_WIDTH,
        selectable: false,
        evented: false,
        visible: false,
        opacity: 1,
        strokeDashArray: [10, 6],
        strokeLineCap: 'round',
        strokeUniform: true,
        objectCaching: false,
        id: 'guide-vertical',
        excludeFromExport: true
    });
    const horizontalGuide = new fabric.Line([0, 0, 100, 0], {
        stroke: GUIDE_COLOR,
        strokeWidth: GUIDE_STROKE_WIDTH,
        selectable: false,
        evented: false,
        visible: false,
        opacity: 1,
        strokeDashArray: [10, 6],
        strokeLineCap: 'round',
        strokeUniform: true,
        objectCaching: false,
        id: 'guide-horizontal',
        excludeFromExport: true
    });

    canvasInstance.add(verticalGuide);
    canvasInstance.add(horizontalGuide);
    // Ensure snap overlays are always on top of content (otherwise large rects/images can cover them).
    try {
        if (typeof canvasInstance.bringObjectToFront === 'function') {
            canvasInstance.bringObjectToFront(verticalGuide);
            canvasInstance.bringObjectToFront(horizontalGuide);
        }
    } catch {
        // ignore
    }

    type SnapBounds = {
        left: number;
        right: number;
        top: number;
        bottom: number;
        centerX: number;
        centerY: number;
        width: number;
        height: number;
    };

    // FIXED: Use local coordinates to avoid jump/snap issues
    // getBoundingRect(true, true) returns world coordinates which conflict with local positioning
    const getBounds = (o: any): SnapBounds => {
        // For objects inside groups, we need to calculate bounds relative to the canvas
        // Use origin-aware calculations to get consistent bounds
        const width = Math.abs((o.width || 0) * (o.scaleX || 1));
        const height = Math.abs((o.height || 0) * (o.scaleY || 1));

        // Calculate actual left/top based on originX/originY
        let actualLeft = o.left || 0;
        let actualTop = o.top || 0;

        if (o.originX === 'center') {
            actualLeft = (o.left || 0) - width / 2;
        } else if (o.originX === 'right') {
            actualLeft = (o.left || 0) - width;
        }

        if (o.originY === 'center') {
            actualTop = (o.top || 0) - height / 2;
        } else if (o.originY === 'bottom') {
            actualTop = (o.top || 0) - height;
        }

        return {
            left: actualLeft,
            right: actualLeft + width,
            top: actualTop,
            bottom: actualTop + height,
            centerX: actualLeft + width / 2,
            centerY: actualTop + height / 2,
            width,
            height
        };
    };

    const w = (o: any) => Math.abs((o.width || 0) * (o.scaleX || 1));
    const h = (o: any) => Math.abs((o.height || 0) * (o.scaleY || 1));

    // FIXED: Use Fabric.js native methods for reliable positioning
    const setObjLeft = (obj: any, x: number) => {
        // Set the left edge to x, considering originX
        const width = w(obj);
        if (obj.originX === 'center') {
            obj.set('left', x + width / 2);
        } else if (obj.originX === 'right') {
            obj.set('left', x + width);
        } else {
            obj.set('left', x);
        }
    };
    const setObjRight = (obj: any, x: number) => {
        // Set the right edge to x, considering originX
        const width = w(obj);
        if (obj.originX === 'center') {
            obj.set('left', x - width / 2);
        } else if (obj.originX === 'right') {
            obj.set('left', x);
        } else {
            obj.set('left', x - width);
        }
    };
    const setObjTop = (obj: any, y: number) => {
        // Set the top edge to y, considering originY
        const height = h(obj);
        if (obj.originY === 'center') {
            obj.set('top', y + height / 2);
        } else if (obj.originY === 'bottom') {
            obj.set('top', y + height);
        } else {
            obj.set('top', y);
        }
    };
    const setObjBottom = (obj: any, y: number) => {
        // Set the bottom edge to y, considering originY
        const height = h(obj);
        if (obj.originY === 'center') {
            obj.set('top', y - height / 2);
        } else if (obj.originY === 'bottom') {
            obj.set('top', y);
        } else {
            obj.set('top', y - height);
        }
    };
    const setObjCenterX = (obj: any, x: number) => {
        // FIXED: Position center at x
        // When originX='left', center is at left + width/2, so left = x - width/2
        // When originX='center', center is at left, so left = x
        // When originX='right', center is at left - width/2, so left = x + width/2
        const width = w(obj);
        if (obj.originX === 'left') {
            obj.set('left', x - width / 2);
        } else if (obj.originX === 'right') {
            obj.set('left', x + width / 2);
        } else {
            obj.set('left', x);
        }
    };
    const setObjCenterY = (obj: any, y: number) => {
        // FIXED: Position center at y
        // When originY='top', center is at top + height/2, so top = y - height/2
        // When originY='center', center is at top, so top = y
        // When originY='bottom', center is at top - height/2, so top = y + height/2
        const height = h(obj);
        if (obj.originY === 'top') {
            obj.set('top', y - height / 2);
        } else if (obj.originY === 'bottom') {
            obj.set('top', y + height / 2);
        } else {
            obj.set('top', y);
        }
    };

    const isControl = (o: any) => {
        const n = (o?.name || '').toString();
        return n === 'path_node' || n === 'bezier_handle' || n === 'control_point' || n === 'handle_line';
    };

    // === SNAP TARGET CACHING: avoid recalculating on every mouse move ===
    let cachedSnapTargets: any[] | null = null;
    let cachedSnapExclude: any = null;
    let cachedTargetBounds: Map<any, SnapBounds> | null = null;
    const frameLookup = new Map<string, any | null>();
    let cachedZones: any[] | null = null;
    let cachedZoneById: Map<string, any> | null = null;
    let cachedZoneMetrics: Map<any, any> | null = null;

    const invalidateSnapCache = () => {
        cachedSnapTargets = null;
        cachedSnapExclude = null;
        cachedTargetBounds = null;
        cachedZones = null;
        cachedZoneById = null;
        cachedZoneMetrics = null;
        frameLookup.clear();
    };

    const getSnapTargets = (exclude: any) => {
        // Return cached targets if same object being dragged
        if (cachedSnapTargets && cachedSnapExclude === exclude && cachedTargetBounds) return cachedSnapTargets;

        const all = canvasInstance.getObjects();
        // Get the parent frame ID of the object being moved (if any)
        const parentFrameId = (exclude as any)?.parentFrameId as string | undefined;
        // When moving a frame, exclude its descendants from snap targets. Otherwise the frame
        // "snaps" to its own children (distance is often 0) and guides feel broken/noisy.
        const frameDescendants = (exclude as any)?.isFrame ? new Set(getFrameDescendants(exclude)) : null;
        const nextTargets: any[] = [];
        const nextBounds = new Map<any, SnapBounds>();

        for (const o of all) {
            if (!o || o === exclude) continue;
            if (frameDescendants && frameDescendants.has(o)) continue;
            if (o.excludeFromExport || isControl(o)) continue;
            if (o.id === 'artboard-bg' || o.id === 'guide-vertical' || o.id === 'guide-horizontal') continue;
            // CRITICAL: Exclude the parent frame from snap targets to prevent the object
            // from being "stuck" snapping to its own container
            if (parentFrameId && o.isFrame && o._customId === parentFrameId) continue;
            nextTargets.push(o);
            nextBounds.set(o, getBounds(o));
        }

        cachedSnapTargets = nextTargets;
        cachedTargetBounds = nextBounds;
        cachedSnapExclude = exclude;
        return cachedSnapTargets;
    };

    const getCachedBounds = (o: any): SnapBounds => {
        const cached = cachedTargetBounds?.get(o);
        if (cached) return cached;
        const fresh = getBounds(o);
        if (cachedTargetBounds) cachedTargetBounds.set(o, fresh);
        return fresh;
    };

    const getSnapFrameById = (frameId: string | undefined) => {
        if (!frameId) return null;
        if (frameLookup.has(frameId)) return frameLookup.get(frameId) || null;
        const frame = canvasInstance.getObjects().find((o: any) => o.isFrame && o._customId === frameId) || null;
        frameLookup.set(frameId, frame);
        return frame;
    };

    const getCachedZoneMetrics = (zone: any) => {
        if (!zone) return null;
        if (!cachedZoneMetrics) cachedZoneMetrics = new Map<any, any>();
        if (cachedZoneMetrics.has(zone)) return cachedZoneMetrics.get(zone) || null;
        const metrics = getZoneMetrics(zone) ?? zone.getBoundingRect(true);
        cachedZoneMetrics.set(zone, metrics);
        return metrics;
    };

    const getCachedZones = () => {
        if (cachedZones && cachedZoneById && cachedZoneMetrics) return cachedZones;
        const zones = canvasInstance.getObjects().filter((o: any) => isLikelyProductZone(o));
        const byId = new Map<string, any>();
        const metricsMap = new Map<any, any>();
        zones.forEach((zone: any) => {
            const id = String(zone?._customId || '').trim();
            if (id) byId.set(id, zone);
            metricsMap.set(zone, getZoneMetrics(zone) ?? zone.getBoundingRect(true));
        });
        cachedZones = zones;
        cachedZoneById = byId;
        cachedZoneMetrics = metricsMap;
        return zones;
    };

    const getCachedZoneById = (zoneId: string) => {
        const id = String(zoneId || '').trim();
        if (!id) return null;
        if (!cachedZoneById) getCachedZones();
        return cachedZoneById?.get(id) || null;
    };

    let lastPointer = { x: 0, y: 0 };
    let constrainAxis: 'x' | 'y' | null = null;
    let constrainRef = { left: 0, top: 0 };
    let stickySnapOwner: any = null;
    let stickyVerticalSnap: { x: number; type: 'left' | 'right' | 'center' } | null = null;
    let stickyHorizontalSnap: { y: number; type: 'top' | 'bottom' | 'center' } | null = null;
    let lastMoveEvalPoint = { x: 0, y: 0 };
    let hasLastMoveEvalPoint = false;
    let moveActivationPoint = { x: 0, y: 0 };
    let hasMoveActivationPoint = false;
    let isMoveArmedForSnap = false;
    const clearStickySnaps = () => {
        stickyVerticalSnap = null;
        stickyHorizontalSnap = null;
    };
    let lastGuideRender = {
        vVisible: false,
        hVisible: false,
        vX: 0,
        hY: 0
    };
    const getVerticalSnapDistance = (
        bounds: SnapBounds,
        snap: { x: number; type: 'left' | 'right' | 'center' }
    ) => {
        if (snap.type === 'left') return Math.abs(bounds.left - snap.x);
        if (snap.type === 'right') return Math.abs(bounds.right - snap.x);
        return Math.abs(bounds.centerX - snap.x);
    };
    const getHorizontalSnapDistance = (
        bounds: SnapBounds,
        snap: { y: number; type: 'top' | 'bottom' | 'center' }
    ) => {
        if (snap.type === 'top') return Math.abs(bounds.top - snap.y);
        if (snap.type === 'bottom') return Math.abs(bounds.bottom - snap.y);
        return Math.abs(bounds.centerY - snap.y);
    };
    const hideGuides = () => {
        if (verticalGuide.visible) verticalGuide.set({ visible: false });
        if (horizontalGuide.visible) horizontalGuide.set({ visible: false });
        lastGuideRender.vVisible = false;
        lastGuideRender.hVisible = false;
    };

    // Canvas-space bounds of what is currently visible in the viewport.
    // This fixes "guides not showing" when the user pans far from (0,0):
    // previous implementation drew lines around the origin only.
    const getViewportBounds = () => {
        const vpt = canvasInstance.viewportTransform || [1, 0, 0, 1, 0, 0];
        const w = (typeof canvasInstance.getWidth === 'function' ? canvasInstance.getWidth() : canvasInstance.width) || 0;
        const h = (typeof canvasInstance.getHeight === 'function' ? canvasInstance.getHeight() : canvasInstance.height) || 0;
        try {
            const inv = fabric.util.invertTransform(vpt);
            const tl = fabric.util.transformPoint({ x: 0, y: 0 }, inv);
            const br = fabric.util.transformPoint({ x: w, y: h }, inv);
            const minX = Math.min(tl.x, br.x);
            const maxX = Math.max(tl.x, br.x);
            const minY = Math.min(tl.y, br.y);
            const maxY = Math.max(tl.y, br.y);
            return { minX, maxX, minY, maxY };
        } catch {
            // Fallback: big range so guides are still visible.
            return { minX: -100000, maxX: 100000, minY: -100000, maxY: 100000 };
        }
    };

    const syncMovingFrameClip = (target: any) => {
        if (!target || target.isFrame || target.excludeFromExport) return;
        if (!(target as any).parentFrameId) return;
        try {
            syncObjectFrameClip(target);
        } catch {
            // ignore clip sync errors during drag
        }
    };

    const getPointer = (evt: MouseEvent) => {
        const el = canvasEl.value || canvasInstance.getElement?.();
        if (!el) return { x: 0, y: 0 };
        const rect = el.getBoundingClientRect();
        const vpt = canvasInstance.viewportTransform || [1, 0, 0, 1, 0, 0];
        const z = canvasInstance.getZoom() || 1;
        return {
            x: (evt.clientX - rect.left - vpt[4]) / z,
            y: (evt.clientY - rect.top - vpt[5]) / z
        };
    };

    const objectMovingHandler = (e: any) => {
        const obj = e.target;
        const evt = e.e as MouseEvent | undefined;
        const currentTransform: any = (canvasInstance as any)?._currentTransform;
        const transformAction = String(currentTransform?.action || '').toLowerCase();
        const isScaleTransform = !!currentTransform && transformAction.includes('scale');
        const zoom = Math.max(0.01, Number(canvasInstance.getZoom?.() || 1));
        const snapRange = SNAP_RANGE_PX / zoom;
        const isRectOrImage = String(obj.type || '').toLowerCase() === 'rect' || String(obj.type || '').toLowerCase() === 'image';
        const activeSnapRange = snapRange * (isRectOrImage ? SNAP_RANGE_FACTOR_RECT_IMAGE : 1);
        const snapReleaseFactor = isRectOrImage ? SNAP_HYSTERESIS_HOLD_FACTOR_RECT_IMAGE : SNAP_HYSTERESIS_HOLD_FACTOR;

        // Skip for controls (nodes/handles/etc). Frames can snap too.
        if (!obj || isControl(obj)) {
            hideGuides();
            return;
        }

        if (!evt?.shiftKey && !evt?.altKey && !isScaleTransform) {
            const currentMoveX = Number(obj.left || 0);
            const currentMoveY = Number(obj.top || 0);
            const moveGatePx = isRectOrImage ? SNAP_MOVE_EPSILON_PX_RECT_IMAGE : SNAP_MOVE_EPSILON_PX;

            if (!hasMoveActivationPoint) {
                moveActivationPoint = { x: currentMoveX, y: currentMoveY };
                hasMoveActivationPoint = true;
                isMoveArmedForSnap = false;
            }

            if (!isMoveArmedForSnap) {
                const moveFromActivation = Math.hypot(currentMoveX - moveActivationPoint.x, currentMoveY - moveActivationPoint.y);
                if (moveFromActivation < moveGatePx) {
                    hasLastMoveEvalPoint = true;
                    lastMoveEvalPoint = { x: currentMoveX, y: currentMoveY };
                    hideGuides();
                    syncMovingFrameClip(obj);
                    return;
                }
                isMoveArmedForSnap = true;
            }

            const perFrameMoveGatePx = isRectOrImage ? moveGatePx : SNAP_MOVE_EPSILON_PX;
            if (hasLastMoveEvalPoint) {
                const moveDelta = Math.hypot(currentMoveX - lastMoveEvalPoint.x, currentMoveY - lastMoveEvalPoint.y);
                if (moveDelta < perFrameMoveGatePx) {
                    lastMoveEvalPoint = { x: currentMoveX, y: currentMoveY };
                    hideGuides();
                    syncMovingFrameClip(obj);
                    return;
                }
            } else {
                hasLastMoveEvalPoint = true;
            }
            lastMoveEvalPoint = { x: currentMoveX, y: currentMoveY };
        } else {
            hasMoveActivationPoint = false;
            hasLastMoveEvalPoint = false;
            isMoveArmedForSnap = false;
        }

        // While transforming (scale/rotate/skew), we keep showing guides but do NOT reposition the object here
        // to avoid cursor drift/jumps (each transform type has its own normalization path).
        const isTransforming =
            !!currentTransform &&
            (transformAction.includes('scale') || transformAction.includes('rotate') || transformAction.includes('skew'));
        const allowPositionSnap = !(isTransforming && currentTransform?.target === obj);
        if (stickySnapOwner !== obj) {
            stickySnapOwner = obj;
            clearStickySnaps();
            hasMoveActivationPoint = false;
            isMoveArmedForSnap = false;
            hasLastMoveEvalPoint = false;
        }

        // Multi-selection: enforce containment/bindings per member.
        if (isActiveSelectionObject(obj) && typeof obj.getObjects === 'function') {
            const members = (obj.getObjects() || []).slice();
            members.forEach((member: any) => {
                if (!member) return;
                if (member.group && !member.group.isSmartObject && !member.group.isProductCard && isLikelyProductCard(member.group)) {
                    member.group.isSmartObject = true;
                    member.group.isProductCard = true;
                }
                if (shouldApplyContainmentConstraints(member)) {
                    applyContainmentConstraints(member);
                }
                try {
                    if (member.parentFrameId) syncObjectFrameClip(member);
                } catch {
                    // ignore clip sync errors during drag
                }
            });
            hideGuides();
            clearStickySnaps();
            return;
        }

        // If moving a child inside a legacy product card, upgrade the parent group so containment works.
        if (obj.group && !obj.group.isSmartObject && !obj.group.isProductCard && isLikelyProductCard(obj.group)) {
            obj.group.isSmartObject = true;
            obj.group.isProductCard = true;
        }

        // SmartObject containment
        if (obj.group && (obj.group as any).isSmartObject) {
            hideGuides();
            clearStickySnaps();
            const parentGroup = obj.group;
            const cardW = (parentGroup as any)._cardWidth || parentGroup.width;
            const cardH = (parentGroup as any)._cardHeight || parentGroup.height;

            // Mark as user-customized so future relayouts (zone recalculation / reload) don't override placement.
            // Persisted via `CANVAS_CUSTOM_PROPS`.
            (obj as any).__manualTransform = true;
            (obj as any).__manualTransformCardW = Number(cardW) || (obj as any).__manualTransformCardW;
            (obj as any).__manualTransformCardH = Number(cardH) || (obj as any).__manualTransformCardH;

            const halfW = cardW / 2, halfH = cardH / 2;
            const objW = obj.getScaledWidth(), objH = obj.getScaledHeight();
            let minX = -halfW, maxX = halfW, minY = -halfH, maxY = halfH;
            if (obj.originX === 'center') { minX = -halfW + objW / 2; maxX = halfW - objW / 2; } else if (obj.originX === 'left') { maxX = halfW - objW; }
            if (obj.originY === 'center') { minY = -halfH + objH / 2; maxY = halfH - objH / 2; } else if (obj.originY === 'top') { maxY = halfH - objH; }
            // If the inner object is larger than the card, the computed range is inverted.
            // Swap so clamping does not "teleport" the object to the opposite side.
            if (minX > maxX) { const t = minX; minX = maxX; maxX = t; }
            if (minY > maxY) { const t = minY; minY = maxY; maxY = t; }
            if (obj.left < minX) obj.set('left', minX); if (obj.left > maxX) obj.set('left', maxX);
            if (obj.top < minY) obj.set('top', minY); if (obj.top > maxY) obj.set('top', maxY);
            obj.setCoords?.();
            syncMovingFrameClip(obj);
            return;
        }

        // Card-in-zone containment (cards are NOT children of the zone group; they are bound via parentZoneId)
        // Legacy cards detected by heuristic use parentZoneId or _zoneSlot as a fast hint.
        const isCardLike = !!(
            obj.isSmartObject ||
            obj.isProductCard ||
            String(obj.name || '').startsWith('product-card') ||
            isLikelyProductCard(obj) ||
            String((obj as any).parentZoneId || '').trim().length
        );
        let handledCardZoneDrag = false;
        if (isCardLike) {
            // Upgrade legacy cards so downstream logic is consistent.
            if (!obj.isProductCard && !obj.isSmartObject && isLikelyProductCard(obj)) {
                obj.isProductCard = true;
                obj.isSmartObject = true;
            }

            let zone: any = null;
            const zoneId = String((obj as any).parentZoneId || '').trim();
            if (zoneId) {
                zone = getCachedZoneById(zoneId);
            }
            if (!zone) {
                const slotZoneId = String((obj as any)?._zoneSlot?.zoneId || '').trim();
                if (slotZoneId) {
                    zone = getCachedZoneById(slotZoneId);
                }
            }

            // Keep card drag lightweight when no zone is attached yet.
            if (!zone) {
                hideGuides();
                clearStickySnaps();
                syncMovingFrameClip(obj);
                return;
            }

            if (zone) {
                const boundZone = zone;
                const center = typeof obj.getCenterPoint === 'function' ? obj.getCenterPoint() : null;
                const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
                const objW = obj.getScaledWidth?.() ?? 0;
                const objH = obj.getScaledHeight?.() ?? 0;

                // Zone bounds constraint while dragging (reorder happens on drop).
                if (center) {
                    const zr = getCachedZoneMetrics(boundZone) ?? boundZone.getBoundingRect(true);
                    const pad = typeof (boundZone as any)._zonePadding === 'number' ? (boundZone as any)._zonePadding : 20;
                    let minCx = zr.left + pad + (objW / 2);
                    let maxCx = (zr.left + zr.width) - pad - (objW / 2);
                    let minCy = zr.top + pad + (objH / 2);
                    let maxCy = (zr.top + zr.height) - pad - (objH / 2);
                    if (minCx > maxCx) {
                        const centerX = zr.left + (zr.width / 2);
                        minCx = centerX;
                        maxCx = centerX;
                    }
                    if (minCy > maxCy) {
                        const centerY = zr.top + (zr.height / 2);
                        minCy = centerY;
                        maxCy = centerY;
                    }
                    const cx = clamp(center.x, minCx, maxCx);
                    const cy = clamp(center.y, minCy, maxCy);
                    setObjCenterX(obj, cx);
                    setObjCenterY(obj, cy);
                    obj.setCoords();
                    handledCardZoneDrag = true;
                }
            }
        }

        // Product cards should feel fluid while dragging inside zones:
        // apply zone containment only and skip expensive/global snapping.
        if (handledCardZoneDrag) {
            hideGuides();
            clearStickySnaps();
            syncMovingFrameClip(obj);
            return;
        }

        // ProductZone containment
        if (obj.group && (obj.group as any).isProductZone) {
            hideGuides();
            clearStickySnaps();
            const zone = obj.group;
            const zoneW = (zone as any)._zoneWidth || zone.width;
            const zoneH = (zone as any)._zoneHeight || zone.height;
            const halfW = zoneW / 2, halfH = zoneH / 2;
            const cardW = obj.getScaledWidth(), cardH = obj.getScaledHeight();
            let minX = -halfW, maxX = halfW - cardW, minY = -halfH, maxY = halfH - cardH;
            if (obj.originX === 'center') { minX = -halfW + cardW / 2; maxX = halfW - cardW / 2; }
            if (obj.originY === 'center') { minY = -halfH + cardH / 2; maxY = halfH - cardH / 2; }
            if (obj.left < minX) obj.set('left', minX); if (obj.left > maxX) obj.set('left', maxX);
            if (obj.top < minY) obj.set('top', minY); if (obj.top > maxY) obj.set('top', maxY);
            syncMovingFrameClip(obj);
            return;
        }

        // SHIFT: constrain to axis
        if (evt?.shiftKey) {
            hideGuides();
            clearStickySnaps();
            const ptr = getPointer(evt);
            const dx = Math.abs(ptr.x - lastPointer.x);
            const dy = Math.abs(ptr.y - lastPointer.y);
            if (constrainAxis === null && (dx > 2 || dy > 2)) {
                constrainAxis = dx >= dy ? 'y' : 'x';
                constrainRef = { left: obj.left, top: obj.top };
            }
            if (constrainAxis === 'x') obj.set('top', constrainRef.top);
            if (constrainAxis === 'y') obj.set('left', constrainRef.left);
            lastPointer = ptr;
            syncMovingFrameClip(obj);
            return;
        }
        constrainAxis = null;
        if (evt) lastPointer = getPointer(evt);

        // Alt/Option: temporarily disable snapping (but keep containment constraints above).
        if (evt?.altKey) {
            hideGuides();
            clearStickySnaps();
            syncMovingFrameClip(obj);
            return;
        }

        // Deep-selected children inside groups can use local coordinates that conflict with
        // global snap targets, causing visible jump/teleport while dragging.
        // Keep drag smooth by skipping snap in this case.
        if (obj.group && String(obj.group.type || '').toLowerCase() !== 'activeselection') {
            hideGuides();
            clearStickySnaps();
            syncMovingFrameClip(obj);
            return;
        }

        const anySnapEnabled = !!(snapToObjects.value || (snapToGuides.value && viewShowGuides.value) || snapToGrid.value);
        if (!anySnapEnabled) {
            hideGuides();
            clearStickySnaps();
            syncMovingFrameClip(obj);
            return;
        }

        // === SMART GUIDES - Calculate on-the-fly ===
        const targets = snapToObjects.value ? (getSnapTargets(obj) || []) : [];
        const b = getBounds(obj);

        // Get parent frame for snap targets (if object is inside a frame)
        const parentFrameId = (obj as any).parentFrameId as string | undefined;
        const parentFrame = getSnapFrameById(parentFrameId);

        // Container (frame parent if any, else "page" rect at 0..W/H)
        const pageW = activePage.value?.width ?? 1080;
        const pageH = activePage.value?.height ?? 1920;
        const container = parentFrame
            ? (() => {
                const fb = getCachedBounds(parentFrame);
                return {
                    left: fb.left,
                    right: fb.right,
                    top: fb.top,
                    bottom: fb.bottom,
                    centerX: fb.centerX,
                    centerY: fb.centerY
                };
            })()
            : {
                left: 0,
                right: pageW,
                top: 0,
                bottom: pageH,
                centerX: pageW / 2,
                centerY: pageH / 2
            };

        let vVisible = false, hVisible = false;
        let vX = 0, hY = 0;
        let bestVDist = snapRange + 1;
        let bestHDist = snapRange + 1;
        let snapVType: 'left' | 'right' | 'center' = 'center';
        let snapHType: 'top' | 'bottom' | 'center' = 'center';

        // Snap against container (page/frame): edges + center
        if (snapToObjects.value) {
            const dlc = Math.abs(b.left - container.left);
            const drc = Math.abs(b.right - container.right);
            const dcc = Math.abs(b.centerX - container.centerX);
            if (dlc < bestVDist) { bestVDist = dlc; vX = container.left; snapVType = 'left'; }
            if (drc < bestVDist) { bestVDist = drc; vX = container.right; snapVType = 'right'; }
            if (dcc < bestVDist) { bestVDist = dcc; vX = container.centerX; snapVType = 'center'; }

            const dtc = Math.abs(b.top - container.top);
            const dbc = Math.abs(b.bottom - container.bottom);
            const dmc = Math.abs(b.centerY - container.centerY);
            if (dtc < bestHDist) { bestHDist = dtc; hY = container.top; snapHType = 'top'; }
            if (dbc < bestHDist) { bestHDist = dbc; hY = container.bottom; snapHType = 'bottom'; }
            if (dmc < bestHDist) { bestHDist = dmc; hY = container.centerY; snapHType = 'center'; }
        }

        const snapWindow = Math.max(240, snapRange * 20);
        // Check snap against other objects.
        for (const t of targets) {
            if (!t) continue;
            const tb = getCachedBounds(t);
            // Fast-path skip for distant objects. This avoids expensive per-object
            // snap math when no snap can possibly happen this frame.
            if (
                tb.right < b.left - snapWindow ||
                tb.left > b.right + snapWindow ||
                tb.bottom < b.top - snapWindow ||
                tb.top > b.bottom + snapWindow
            ) {
                continue;
            }

            // Vertical snaps (left-left, right-right, left-right, right-left, center-center)
            const dl = Math.abs(b.left - tb.left);
            const dr = Math.abs(b.right - tb.right);
            const dlr = Math.abs(b.left - tb.right);
            const drl = Math.abs(b.right - tb.left);
            const dc = Math.abs(b.centerX - tb.centerX);

            if (dl < bestVDist) { bestVDist = dl; vX = tb.left; snapVType = 'left'; }
            if (dr < bestVDist) { bestVDist = dr; vX = tb.right; snapVType = 'right'; }
            if (dlr < bestVDist) { bestVDist = dlr; vX = tb.right; snapVType = 'left'; }
            if (drl < bestVDist) { bestVDist = drl; vX = tb.left; snapVType = 'right'; }
            if (dc < bestVDist) { bestVDist = dc; vX = tb.centerX; snapVType = 'center'; }

            // Horizontal snaps (top-top, bottom-bottom, top-bottom, bottom-top, center-center)
            const dt = Math.abs(b.top - tb.top);
            const dbo = Math.abs(b.bottom - tb.bottom);
            const dtb = Math.abs(b.top - tb.bottom);
            const dbt = Math.abs(b.bottom - tb.top);
            const dcy2 = Math.abs(b.centerY - tb.centerY);

            if (dt < bestHDist) { bestHDist = dt; hY = tb.top; snapHType = 'top'; }
            if (dbo < bestHDist) { bestHDist = dbo; hY = tb.bottom; snapHType = 'bottom'; }
            if (dtb < bestHDist) { bestHDist = dtb; hY = tb.bottom; snapHType = 'top'; }
            if (dbt < bestHDist) { bestHDist = dbt; hY = tb.top; snapHType = 'bottom'; }
            if (dcy2 < bestHDist) { bestHDist = dcy2; hY = tb.centerY; snapHType = 'center'; }
        }

        // Check snap against user guides
        if (snapToGuides.value && viewShowGuides.value) {
            const gids = userGuidesIndex.value || [];
            for (const g of gids) {
                if (!g) continue;
                if (g.axis === 'x') {
                    const gx = Number(g.pos || 0);
                    const dl = Math.abs(b.left - gx);
                    const dr = Math.abs(b.right - gx);
                    const dc = Math.abs(b.centerX - gx);
                    if (dl < bestVDist) { bestVDist = dl; vX = gx; snapVType = 'left'; }
                    if (dr < bestVDist) { bestVDist = dr; vX = gx; snapVType = 'right'; }
                    if (dc < bestVDist) { bestVDist = dc; vX = gx; snapVType = 'center'; }
                } else {
                    const gy = Number(g.pos || 0);
                    const dt = Math.abs(b.top - gy);
                    const db = Math.abs(b.bottom - gy);
                    const dc = Math.abs(b.centerY - gy);
                    if (dt < bestHDist) { bestHDist = dt; hY = gy; snapHType = 'top'; }
                    if (db < bestHDist) { bestHDist = db; hY = gy; snapHType = 'bottom'; }
                    if (dc < bestHDist) { bestHDist = dc; hY = gy; snapHType = 'center'; }
                }
            }
        }

        // Snap hysteresis:
        // after snapping, keep it "locked" for a slightly wider range to avoid
        // micro-jumps when cursor oscillates near the threshold.
        const snapReleaseRange = activeSnapRange * snapReleaseFactor;

        if (!allowPositionSnap) {
            clearStickySnaps();
        }

        const verticalStickyDist = stickyVerticalSnap ? getVerticalSnapDistance(b, stickyVerticalSnap) : Number.POSITIVE_INFINITY;
        if (allowPositionSnap && stickyVerticalSnap && verticalStickyDist <= snapReleaseRange) {
            vVisible = true;
            vX = stickyVerticalSnap.x;
            snapVType = stickyVerticalSnap.type;
        } else {
            if (stickyVerticalSnap && verticalStickyDist > snapReleaseRange) {
                stickyVerticalSnap = null;
            }
            if (bestVDist <= activeSnapRange) {
                vVisible = true;
                stickyVerticalSnap = { x: vX, type: snapVType };
            }
        }

        const horizontalStickyDist = stickyHorizontalSnap ? getHorizontalSnapDistance(b, stickyHorizontalSnap) : Number.POSITIVE_INFINITY;
        if (allowPositionSnap && stickyHorizontalSnap && horizontalStickyDist <= snapReleaseRange) {
            hVisible = true;
            hY = stickyHorizontalSnap.y;
            snapHType = stickyHorizontalSnap.type;
        } else {
            if (stickyHorizontalSnap && horizontalStickyDist > snapReleaseRange) {
                stickyHorizontalSnap = null;
            }
            if (bestHDist <= activeSnapRange) {
                hVisible = true;
                stickyHorizontalSnap = { y: hY, type: snapHType };
            }
        }

        if (allowPositionSnap && vVisible) {
            if (snapVType === 'left') setObjLeft(obj, vX);
            else if (snapVType === 'right') setObjRight(obj, vX);
            else setObjCenterX(obj, vX);
        }
        if (allowPositionSnap && hVisible) {
            if (snapHType === 'top') setObjTop(obj, hY);
            else if (snapHType === 'bottom') setObjBottom(obj, hY);
            else setObjCenterY(obj, hY);
        }

        // Grid snap as fallback (only if no other snap won)
        if (allowPositionSnap && snapToGrid.value && !isRectOrImage && !vVisible && !hVisible) {
            const gs = Math.max(4, Math.round(Number(gridSize.value) || 20));
            const snappedLeft = Math.round(b.left / gs) * gs;
            const snappedTop = Math.round(b.top / gs) * gs;
            const dl = Math.abs(b.left - snappedLeft);
            const dt = Math.abs(b.top - snappedTop);
            if (dl <= activeSnapRange) {
                setObjLeft(obj, snappedLeft);
                vVisible = true;
                vX = snappedLeft;
                snapVType = 'left';
            }
            if (dt <= activeSnapRange) {
                setObjTop(obj, snappedTop);
                hVisible = true;
                hY = snappedTop;
                snapHType = 'top';
            }
        }

        // CRITICAL: Update object coordinates after snap to prevent jumping
        if (allowPositionSnap && (vVisible || hVisible)) {
            obj.setCoords();
        }

        // Draw guides across the visible viewport in canvas coordinates (works even when panned far).
        // Avoid viewport math/sets when nothing is being snapped.
        if (vVisible || hVisible) {
            const vb = getViewportBounds();
            const viewW = Math.max(1, vb.maxX - vb.minX);
            const viewH = Math.max(1, vb.maxY - vb.minY);
            const pad = Math.max(400, Math.max(viewW, viewH) * 0.5);

            if (vVisible) {
                if (!lastGuideRender.vVisible || lastGuideRender.vX !== vX) {
                    verticalGuide.set({ x1: vX, y1: vb.minY - pad, x2: vX, y2: vb.maxY + pad, visible: true });
                    lastGuideRender.vX = vX;
                }
                lastGuideRender.vVisible = true;
            } else if (lastGuideRender.vVisible) {
                verticalGuide.set({ visible: false });
                lastGuideRender.vVisible = false;
            }

            if (hVisible) {
                if (!lastGuideRender.hVisible || lastGuideRender.hY !== hY) {
                    horizontalGuide.set({ x1: vb.minX - pad, y1: hY, x2: vb.maxX + pad, y2: hY, visible: true });
                    lastGuideRender.hY = hY;
                }
                lastGuideRender.hVisible = true;
            } else if (lastGuideRender.hVisible) {
                horizontalGuide.set({ visible: false });
                lastGuideRender.hVisible = false;
            }

            // Keep them on top even after object loads / stacking changes.
            if (lastGuideRender.vVisible || lastGuideRender.hVisible) {
                try {
                    if (typeof canvasInstance.bringObjectToFront === 'function') {
                        canvasInstance.bringObjectToFront(verticalGuide);
                        canvasInstance.bringObjectToFront(horizontalGuide);
                    }
                } catch {
                    // ignore
                }
            }
        } else {
            if (lastGuideRender.vVisible) {
                verticalGuide.set({ visible: false });
                lastGuideRender.vVisible = false;
            }
            if (lastGuideRender.hVisible) {
                horizontalGuide.set({ visible: false });
                lastGuideRender.hVisible = false;
            }
        }

        // Keep clipping in sync after all snapping/containment adjustments.
        syncMovingFrameClip(obj);
    };

    // Smooth drag path: coalesce bursty Fabric move/scale/rotate events to 1 update per frame.
    let objectMoveRafId: number | null = null;
    let pendingObjectMoveEvent: { target: any; e?: MouseEvent } | null = null;

    const flushPendingObjectMove = () => {
        if (!pendingObjectMoveEvent) return;
        const nextEvent = pendingObjectMoveEvent;
        pendingObjectMoveEvent = null;
        objectMovingHandler(nextEvent as any);
    };

    const queueObjectMove = (e: any) => {
        pendingObjectMoveEvent = {
            target: e?.target,
            e: e?.e
        };
        if (objectMoveRafId !== null) return;
        objectMoveRafId = requestAnimationFrame(() => {
            objectMoveRafId = null;
            flushPendingObjectMove();
        });
    };

    const mouseUpHandler = () => {
        if (objectMoveRafId !== null) {
            cancelAnimationFrame(objectMoveRafId);
            objectMoveRafId = null;
        }
        flushPendingObjectMove();
        hideGuides();
        constrainAxis = null;
        clearStickySnaps();
        stickySnapOwner = null;
        hasLastMoveEvalPoint = false;
        hasMoveActivationPoint = false;
        isMoveArmedForSnap = false;
        invalidateSnapCache();
        flushZoneRelayoutOnDrop();
        safeRequestRenderAll(canvasInstance);
        // CRITICAL: Create fresh snapshot (not just triggerRef) so PropertiesPanel
        // sees updated position/dimension/zone values after drag/resize.
        refreshSelectedRef();
    };

    canvasInstance.on('object:moving', queueObjectMove);
    // Show guides while resizing/rotating too (without snapping position).
    canvasInstance.on('object:scaling', queueObjectMove);
    canvasInstance.on('object:rotating', queueObjectMove);
    canvasInstance.on('mouse:up', mouseUpHandler);
    canvasInstance.on('object:added', invalidateSnapCache);
    canvasInstance.on('object:removed', invalidateSnapCache);
    canvasInstance.on('object:modified', invalidateSnapCache);

    teardownSnapping = () => {
        try {
            canvasInstance.off('object:moving', queueObjectMove);
            canvasInstance.off('object:scaling', queueObjectMove);
            canvasInstance.off('object:rotating', queueObjectMove);
            canvasInstance.off('mouse:up', mouseUpHandler);
            canvasInstance.off('object:added', invalidateSnapCache);
            canvasInstance.off('object:removed', invalidateSnapCache);
            canvasInstance.off('object:modified', invalidateSnapCache);
        } catch {
            // ignore teardown errors
        }
        if (objectMoveRafId !== null) {
            cancelAnimationFrame(objectMoveRafId);
            objectMoveRafId = null;
        }
        pendingObjectMoveEvent = null;
        clearStickySnaps();
        stickySnapOwner = null;
        hideGuides();
        try {
            if (verticalGuide.canvas === canvasInstance) canvasInstance.remove(verticalGuide);
            if (horizontalGuide.canvas === canvasInstance) canvasInstance.remove(horizontalGuide);
        } catch {
            // ignore guide cleanup errors
        }
        invalidateSnapCache();
    };
}

// Global updateFloatingUI function
const updateFloatingUI = () => {
    if (!canvas.value) return;
    const active = canvas.value.getActiveObject();
    selectedObjectPos.value = getSelectedObjectFloatingPos(active, isLikelyProductZone);
}

// Global updateSelection function (used by undo/redo and event handlers)
const updateSelection = () => {
    if (!canvas.value) return;

    // NOTA: sanitizeAllClipPaths removido daqui para evitar flickering.
    // Era chamado a cada clique/seleção, tocando dirty flags de todos os objetos
    // e causando re-renders desnecessários. A sanitização agora ocorre apenas
    // em momentos críticos (loadFromJSON, thumbnail, etc).

    const payload = buildSelectionSyncPayload({
        canvas: canvas.value,
        isLikelyProductZone,
        ensureZoneSanity,
        isNodeEditing: !!isNodeEditing.value,
        currentEditingPath: currentEditingPath.value,
        snapshotForPropertiesPanel
    });
    if (!payload) return;
    const { active, selectionUiState, floatingPos } = payload;
    // Ensure selectedId is never undefined - always null if no active object
    selectedObjectId.value = selectionUiState.selectedObjectId;
    selectedObjectIds.value = Array.isArray(selectionUiState.selectedObjectIds)
        ? [...selectionUiState.selectedObjectIds]
        : [];
    // Always use a stable snapshot so the PropertiesPanel never "loses" sections (e.g. `type` can be non-enumerable on Fabric objects).
    selectedObjectRef.value = selectionUiState.selectedObjectSnapshot;
    selectedObjectPos.value = floatingPos;

    // Show contextual toolbar for selected vector paths and node-edit sessions.
    showPenContextualToolbar.value = selectionUiState.showPenContextualToolbar;
    
    // Render canvas to show frame label when frame is selected
    // NOTA: Removido requestRenderAll extra aqui — o Fabric já re-renderiza
    // automaticamente ao mudar seleção. O throttledUpdateFrameLabels (via after:render)
    // cuidará de atualizar os labels HTML dos frames.
    
    syncSelectionDomainState({
        active,
        canvas: canvas.value,
        productZoneState,
        isLikelyProductZone,
        isLikelyProductCard,
        getZoneGlobalStyles,
        getPreferredProductImageFromGroup,
        getImageSourceFromObject,
        isLikelyPlaceholderImageSrc,
        scheduleMissingProductImageRecovery
    });
}

// Clean up orphaned control/preview objects - AGGRESSIVE cleanup
const cleanupOrphanedObjects = () => {
    if (!canvas.value) return;
    
    const objs = canvas.value.getObjects();
    const toRemove: any[] = [];
    
    objs.forEach((o: any) => {
        ensurePersistentContentFlags(o);
        if (isTransientCanvasObject(o)) {
            // Snap guides are runtime overlays; keep them alive (setupSnapping owns their lifecycle).
            const id = String((o as any)?.id || '');
            if (id === 'guide-vertical' || id === 'guide-horizontal') return;
            toRemove.push(o);
            return;
        }
    });
    
    if (toRemove.length > 0) {
        console.log(`🧹 Limpando ${toRemove.length} objeto(s) órfão(ões) do canvas`);
        toRemove.forEach((obj: any) => {
            try {
                canvas.value.remove(obj);
            } catch (e) {
                // Ignore errors
            }
        });
        canvas.value.requestRenderAll();
        refreshCanvasObjects();
    }
}

// --- Reactivity & Layers Sync ---
const setupReactivity = () => {
    if (!canvas.value) return; 

    const isLikelyProductCard = (obj: any) => {
        if (!obj) return false;
        if (obj.excludeFromExport) return false;
        if (obj.isFrame) return false;
        if (isLikelyProductZone(obj)) return false;
        if (obj.type !== 'group' || typeof obj.getObjects !== 'function') return false;
        if (obj.isSmartObject || obj.isProductCard) return true;
        if (String(obj.name || '').startsWith('product-card')) return true;
        if (String((obj as any).parentZoneId || '').trim()) return true;
        const objs = obj.getObjects() || [];
        if (objs.some((o: any) => o?.name === 'offerBackground')) return true;
        const hasImage = objs.some((o: any) => String(o?.type || '').toLowerCase() === 'image');
        const hasPriceGroup = objs.some((o: any) => (
            String(o?.type || '').toLowerCase() === 'group' && String(o?.name || '') === 'priceGroup'
        ));
        return hasImage && hasPriceGroup;
    };

    const getStylesForCard = (card: any): Partial<GlobalStyles> => {
        if (!canvas.value) return normalizeGlobalStyles(productZoneState.globalStyles.value);
        const zoneId = card?.parentZoneId;
        if (zoneId) {
            const zone = canvas.value.getObjects().find((o: any) => isLikelyProductZone(o) && (o as any)._customId === zoneId);
            if (zone) return getZoneGlobalStyles(zone);
        }
        return normalizeGlobalStyles(productZoneState.globalStyles.value);
    };

    const isProductCardImage = (img: any) => {
        if (!img || String(img.type || '').toLowerCase() !== 'image') return false;
        const owner =
            (isProductCardContainer((img as any).group) ? (img as any).group : null) ||
            (isProductCardContainer((img as any).parent) ? (img as any).parent : null) ||
            findProductCardParentGroup(img);
        if (!owner) return false;
        return !!(
            owner.isSmartObject ||
            owner.isProductCard ||
            hasParentZoneBinding(owner) ||
            String(owner.name || '').startsWith('product-card') ||
            isLikelyProductCard(owner)
        );
    };

    const sanitizeProductCardImageTransform = (img: any, opts: { clampWithinCard?: boolean } = {}) => {
        if (!img || !isProductCardImage(img)) return false;
        const clampWithinCard = opts.clampWithinCard !== false;
        const nextScaleX = Math.abs(Number(img.scaleX ?? 1)) || 1;
        const nextScaleY = Math.abs(Number(img.scaleY ?? 1)) || 1;

        img.set({
            scaleX: nextScaleX,
            scaleY: nextScaleY,
            flipX: false,
            flipY: false,
            lockScalingFlip: true,
            lockSkewingX: true,
            lockSkewingY: true
        });
        img.setCoords?.();

        if (clampWithinCard) {
            applyContainmentConstraints(img);
        }

        const parent = img.group;
        if (parent) {
            parent.dirty = true;
            parent.setCoords?.();
        }

        return true;
    };

    const normalizeCardScaleAndRelayout = (card: any, opts: { save?: boolean } = {}) => {
        if (!canvas.value || !card || card.type !== 'group') return;
        if (!isLikelyProductCard(card)) return;

        const shouldSave = opts.save !== false;
        const center = typeof card.getCenterPoint === 'function' ? card.getCenterPoint() : { x: card.left ?? 0, y: card.top ?? 0 };
        const scaledW = Math.abs(typeof card.getScaledWidth === 'function' ? card.getScaledWidth() : (Number(card.width || 0) * Number(card.scaleX || 1)));
        const scaledH = Math.abs(typeof card.getScaledHeight === 'function' ? card.getScaledHeight() : (Number(card.height || 0) * Number(card.scaleY || 1)));
        const nextW = Math.max(50, Math.round(Number(scaledW) || 0));
        const nextH = Math.max(50, Math.round(Number(scaledH) || 0));
        if (!nextW || !nextH) return;

        card.set({
            originX: 'center',
            originY: 'center',
            left: center.x,
            top: center.y,
            scaleX: 1,
            scaleY: 1,
            flipX: false,
            flipY: false,
            width: nextW,
            height: nextH
        });

        const styles = getStylesForCard(card);
        resizeSmartObject(card, nextW, nextH, styles);
        card.setCoords();
        canvas.value.requestRenderAll();
        if (shouldSave) saveCurrentState();
    };

    const isProductCardImageSelectionCandidate = (obj: any) => {
        if (!isProductCardImage(obj)) return false;
        const smartType = String((obj as any)?.data?.smartType || '').toLowerCase();
        const name = String((obj as any)?.name || '').toLowerCase();
        if (name === 'price_bg_image' || name === 'splash_image') return false;
        if (smartType === 'product-image') return true;
        if (name === 'smart_image' || name === 'product_image' || name === 'productimage') return true;
        if (name.startsWith('extra_image_')) return true;
        return true;
    };

    const getCardImageCandidatesDeep = (card: any) => {
        if (!card || !isLikelyProductCard(card)) return [] as any[];
        const out: any[] = [];
        const walk = (node: any) => {
            if (!node) return;
            if (isProductCardImageSelectionCandidate(node) && node?.visible !== false) {
                out.push(node);
            }
            if (typeof node?.getObjects === 'function') {
                const children = node.getObjects() || [];
                children.forEach((child: any) => walk(child));
            }
        };
        walk(card);
        return out;
    };

    const pickPreferredProductImageFromCard = (card: any) => {
        if (!card || !isLikelyProductCard(card) || typeof card.getObjects !== 'function') return null;
        try {
            card.set?.({
                subTargetCheck: true,
                interactive: true,
                selectable: true,
                evented: true
            });
            card.setCoords?.();
        } catch {
            // ignore
        }
        const children = getCardImageCandidatesDeep(card);
        if (!children.length) return null;

        const primary = children.find((child: any) => {
            const smartType = String((child as any)?.data?.smartType || '').toLowerCase();
            const name = String((child as any)?.name || '').toLowerCase();
            return smartType === 'product-image' || name === 'smart_image' || name === 'product_image' || name === 'productimage';
        });
        const preferred = primary || children[children.length - 1] || null;
        if (!preferred) return null;
        try {
            preferred.set?.({
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true
            });
            preferred.setCoords?.();
        } catch {
            // ignore
        }
        return preferred;
    };

    const getDeepSelectedProductImageFromCard = (card: any) => {
        if (!card || !isLikelyProductCard(card)) return null;
        const deepActive = (card as any)?._activeObject;
        if (isProductCardImageSelectionCandidate(deepActive)) return deepActive;
        return null;
    };

    const resolveSelectionRootObject = (obj: any, opts: { keepCardImages?: boolean } = {}) => {
        if (!obj || isTransientCanvasObject(obj)) return null;
        const keepCardImages = opts.keepCardImages !== false;
        if (keepCardImages && isProductCardImageSelectionCandidate(obj)) return obj;
        if (keepCardImages && isLikelyProductCard(obj)) {
            const deepSelected = getDeepSelectedProductImageFromCard(obj);
            if (deepSelected) return deepSelected;
        }
        if (keepCardImages && isLikelyProductCard(obj)) {
            const preferred = pickPreferredProductImageFromCard(obj);
            if (preferred) return preferred;
        }
        if (isLikelyProductCard(obj)) return obj;
        const parentCard = findProductCardParentGroup(obj);
        if (keepCardImages && parentCard) {
            const preferred = pickPreferredProductImageFromCard(parentCard);
            if (preferred) return preferred;
        }
        if (parentCard) return parentCard;
        return obj;
    };

    const collectNormalizedSelectionMembers = (activeObj: any) => {
        if (!activeObj) return [] as any[];
        const rawMembers = isActiveSelectionObject(activeObj) && typeof activeObj.getObjects === 'function'
            ? (activeObj.getObjects() || [])
            : [activeObj];
        const keepCardImages = rawMembers.some((member: any) => isProductCardImageSelectionCandidate(member));
        const unique: any[] = [];
        rawMembers.forEach((member: any) => {
            const root = resolveSelectionRootObject(member, { keepCardImages });
            if (!root) return;
            if (!unique.includes(root)) unique.push(root);
        });
        return unique;
    };

    // Shift+multi-select:
    // - keep deep-selected product images as independent targets (allows multi-select of images in a card)
    // - still prefer whole product cards for non-image inner elements.
    const resolveShiftSelectionRootObject = (obj: any) => {
        if (!obj || isTransientCanvasObject(obj)) return null;
        if (isProductCardImageSelectionCandidate(obj)) return obj;
        if (isLikelyProductCard(obj)) {
            const deepSelected = getDeepSelectedProductImageFromCard(obj);
            if (deepSelected) return deepSelected;
            const preferred = pickPreferredProductImageFromCard(obj);
            if (preferred) return preferred;
        }
        if (isLikelyProductCard(obj)) return obj;
        const parentCard = findProductCardParentGroup(obj);
        if (parentCard) {
            const preferred = pickPreferredProductImageFromCard(parentCard);
            if (preferred) return preferred;
        }
        if (parentCard) return parentCard;

        return resolveSelectionRootObject(obj, { keepCardImages: true });
    };

    const collectShiftSelectionMembers = (activeObj: any) => {
        if (!activeObj) return [] as any[];
        const rawMembers = isActiveSelectionObject(activeObj) && typeof activeObj.getObjects === 'function'
            ? (activeObj.getObjects() || [])
            : [activeObj];
        const unique: any[] = [];
        rawMembers.forEach((member: any) => {
            const root = resolveShiftSelectionRootObject(member);
            if (!root) return;
            if (!unique.includes(root)) unique.push(root);
        });
        return unique;
    };

    let shiftSelectionBaselineMembers: any[] = [];
    const refreshShiftSelectionBaseline = (activeOverride?: any) => {
        const source = typeof activeOverride !== 'undefined'
            ? activeOverride
            : canvas.value?.getActiveObject?.();
        shiftSelectionBaselineMembers = collectShiftSelectionMembers(source);
    };

    const getScenePointFromNativeEvent = (nativeEvt: any) => {
        if (!canvas.value || !nativeEvt) return null;
        try {
            const canvasAny = canvas.value as any;
            const scenePoint = canvasAny.getScenePoint?.(nativeEvt) || canvasAny.getPointer?.(nativeEvt, true);
            if (scenePoint && Number.isFinite(scenePoint.x) && Number.isFinite(scenePoint.y)) return scenePoint;
        } catch {
            // ignore
        }
        return null;
    };

    const getFabricHitInfoAtPointer = (nativeEvt: any): { target: any; subTargets: any[] } => {
        if (!canvas.value || !nativeEvt) return { target: null, subTargets: [] };
        try {
            const canvasAny = canvas.value as any;
            const scenePoint = getScenePointFromNativeEvent(nativeEvt);
            if (!scenePoint) return { target: null, subTargets: [] };
            const rootObjects = (typeof canvasAny.getObjects === 'function' ? canvasAny.getObjects() : canvasAny._objects) || [];
            if (typeof canvasAny.searchPossibleTargets === 'function') {
                const info = canvasAny.searchPossibleTargets(rootObjects, scenePoint);
                const target = info?.target || null;
                const subTargets = Array.isArray(info?.subTargets) ? info.subTargets.filter(Boolean) : [];
                if (target || subTargets.length) return { target, subTargets };
            }
            if (typeof canvasAny.findTarget === 'function') {
                const info = canvasAny.findTarget(nativeEvt);
                const target = info?.target ?? info ?? null;
                const subTargets = Array.isArray(info?.subTargets) ? info.subTargets.filter(Boolean) : [];
                if (target || subTargets.length) return { target, subTargets };
            }
        } catch {
            // ignore
        }
        return { target: null, subTargets: [] };
    };

    const findProductImagesAtPointer = (nativeEvt: any) => {
        if (!canvas.value || !nativeEvt) return [] as any[];
        const scenePoint = getScenePointFromNativeEvent(nativeEvt);
        if (!scenePoint) return [] as any[];

        const hits: Array<{
            obj: any;
            precise: boolean;
            distance: number;
            area: number;
            zRank: number;
        }> = [];
        const seen = new Set<any>();
        let zRank = 0;
        const cards = (canvas.value.getObjects() || []).slice().reverse().filter((obj: any) => isLikelyProductCard(obj));
        for (const card of cards) {
            if (card?.visible === false || typeof card?.getObjects !== 'function') continue;
            const children = getCardImageCandidatesDeep(card).slice().reverse();

            for (const child of children) {
                zRank += 1;
                if (!child || seen.has(child)) continue;
                let isHit = false;
                let isPreciseHit = false;
                let hitArea = Number.POSITIVE_INFINITY;
                try {
                    if (typeof child?.containsPoint === 'function' && child.containsPoint(scenePoint, undefined, true)) {
                        isHit = true;
                        isPreciseHit = true;
                    }
                } catch {
                    // ignore and fallback to bounds
                }
                try {
                    const br = child?.getBoundingRect?.(true, true) || child?.getBoundingRect?.(true);
                    if (br) {
                        hitArea = Math.max(1, Math.abs(Number(br.width || 0) * Number(br.height || 0)));
                        if (!isHit && scenePoint.x >= br.left && scenePoint.x <= (br.left + br.width) && scenePoint.y >= br.top && scenePoint.y <= (br.top + br.height)) {
                            isHit = true;
                        }
                    }
                } catch {
                    // ignore
                }
                if (!isHit) continue;
                const center = typeof child?.getCenterPoint === 'function'
                    ? child.getCenterPoint()
                    : { x: Number(child?.left || 0), y: Number(child?.top || 0) };
                const dx = Number(scenePoint.x || 0) - Number(center?.x || 0);
                const dy = Number(scenePoint.y || 0) - Number(center?.y || 0);
                const distance = Math.hypot(dx, dy);
                try {
                    child.set?.({
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true
                    });
                    child.setCoords?.();
                } catch {
                    // ignore
                }
                hits.push({
                    obj: child,
                    precise: isPreciseHit,
                    distance,
                    area: hitArea,
                    zRank
                });
                seen.add(child);
            }
        }
        hits.sort((a, b) => {
            // 1) precise geometry hit beats bounds-only hit
            if (a.precise !== b.precise) return a.precise ? -1 : 1;
            // 2) nearest center to pointer first
            if (Math.abs(a.distance - b.distance) > 0.01) return a.distance - b.distance;
            // 3) smaller footprint first (avoids giant stale bbox stealing clicks)
            if (Math.abs(a.area - b.area) > 0.01) return a.area - b.area;
            // 4) fallback: top-most by z traversal
            return b.zRank - a.zRank;
        });
        return hits.map((entry) => entry.obj);
    };

    const findTopProductImageAtPointer = (nativeEvt: any, opts: { exclude?: any[] } = {}) => {
        const hits = findProductImagesAtPointer(nativeEvt);
        if (!Array.isArray(hits) || hits.length === 0) return null;
        const excluded = new Set((opts.exclude || []).filter(Boolean));
        const firstAvailable = hits.find((img: any) => !excluded.has(img));
        return firstAvailable || hits[0] || null;
    };

    const findTopProductCardAtPointer = (nativeEvt: any) => {
        if (!canvas.value || !nativeEvt) return null;
        const scenePoint = getScenePointFromNativeEvent(nativeEvt);
        if (!scenePoint) return null;
        const cards = (canvas.value.getObjects() || []).slice().reverse().filter((obj: any) => isLikelyProductCard(obj));
        for (const card of cards) {
            if (card?.visible === false || card?.selectable === false) continue;
            try {
                if (typeof card?.containsPoint === 'function' && card.containsPoint(scenePoint, undefined, true)) return card;
            } catch {
                // ignore and fallback
            }
            try {
                const br = card?.getBoundingRect?.(true, true) || card?.getBoundingRect?.(true);
                if (!br) continue;
                if (scenePoint.x >= br.left && scenePoint.x <= (br.left + br.width) && scenePoint.y >= br.top && scenePoint.y <= (br.top + br.height)) {
                    return card;
                }
            } catch {
                // ignore
            }
        }
        return null;
    };

    const isShiftSelectableTarget = (obj: any) => {
        if (!obj) return false;
        if (isTransientCanvasObject(obj) || isControlLikeObject(obj)) return false;
        if (obj.selectable === false) return false;
        return true;
    };

    const pickGenericShiftTargetAtPointer = (nativeEvt: any, opts: { exclude?: any[] } = {}) => {
        if (!canvas.value || !nativeEvt) return null;
        const excludedRoots = new Set(
            (opts.exclude || [])
                .map((entry: any) => resolveShiftSelectionRootObject(entry))
                .filter(Boolean)
        );
        const pickRoot = (candidate: any) => {
            if (!isShiftSelectableTarget(candidate)) return null;
            const root = resolveShiftSelectionRootObject(candidate);
            if (!root || !isShiftSelectableTarget(root)) return null;
            if (excludedRoots.has(root)) return null;
            return root;
        };

        const hitInfo = getFabricHitInfoAtPointer(nativeEvt);
        const hitCandidates = [
            ...(Array.isArray(hitInfo.subTargets) ? hitInfo.subTargets : []),
            hitInfo.target
        ];
        for (const candidate of hitCandidates) {
            const picked = pickRoot(candidate);
            if (picked) return picked;
        }

        const scenePoint = getScenePointFromNativeEvent(nativeEvt);
        if (!scenePoint) return null;
        const stack = (canvas.value.getObjects() || []).slice().reverse();
        for (const obj of stack) {
            const picked = pickRoot(obj);
            if (!picked) continue;
            try {
                if (typeof picked.containsPoint === 'function' && picked.containsPoint(scenePoint, undefined, true)) {
                    return picked;
                }
            } catch {
                // ignore
            }
            try {
                const br = picked.getBoundingRect?.(true, true) || picked.getBoundingRect?.(true);
                if (br && scenePoint.x >= br.left && scenePoint.x <= (br.left + br.width) && scenePoint.y >= br.top && scenePoint.y <= (br.top + br.height)) {
                    return picked;
                }
            } catch {
                // ignore
            }
        }
        return null;
    };

    const pickShiftSelectionTarget = (evtPayload: any) => {
        const primary = evtPayload?.target || null;
        const subTargets = Array.isArray(evtPayload?.subTargets) ? evtPayload.subTargets.filter(Boolean) : [];
        const preferCardImages = shiftSelectionBaselineMembers.some((member: any) => isProductCardImageSelectionCandidate(member));
        if (!preferCardImages) {
            const pointerGenericFirst = pickGenericShiftTargetAtPointer(evtPayload?.e, {
                exclude: shiftSelectionBaselineMembers
            });
            if (pointerGenericFirst) return pointerGenericFirst;
        }
        // IMPORTANT: Prefer geometric pointer hit first.
        // Fabric can occasionally report a stale active child as target when clicking inside interactive groups.
        const pointerImageFirst = findTopProductImageAtPointer(evtPayload?.e, {
            exclude: shiftSelectionBaselineMembers
        });
        if (pointerImageFirst) return pointerImageFirst;
        const pointerCardFirst = findTopProductCardAtPointer(evtPayload?.e);
        if (pointerCardFirst) {
            const preferred = pickPreferredProductImageFromCard(pointerCardFirst);
            if (preferred) return preferred;
            const deepSelected = getDeepSelectedProductImageFromCard(pointerCardFirst);
            if (deepSelected) return deepSelected;
            return pointerCardFirst;
        }
        const fabricHitInfo = getFabricHitInfoAtPointer(evtPayload?.e);
        const fabricPointerTarget = fabricHitInfo.target;
        const fabricSubTargets = Array.isArray(fabricHitInfo.subTargets) ? fabricHitInfo.subTargets : [];
        const fabricImageSubTarget = fabricSubTargets.find((item: any) => isProductCardImageSelectionCandidate(item));
        if (fabricImageSubTarget) return fabricImageSubTarget;
        if (fabricPointerTarget) {
            if (isProductCardImageSelectionCandidate(fabricPointerTarget)) return fabricPointerTarget;
            const pointerCard = isProductCardContainer(fabricPointerTarget)
                ? fabricPointerTarget
                : findProductCardParentGroup(fabricPointerTarget);
            if (pointerCard) {
                const pointerImage = findTopProductImageAtPointer(evtPayload?.e, {
                    exclude: shiftSelectionBaselineMembers
                });
                if (pointerImage) return pointerImage;
                const preferred = pickPreferredProductImageFromCard(pointerCard);
                if (preferred) return preferred;
                const deepSelected = getDeepSelectedProductImageFromCard(pointerCard);
                if (deepSelected) return deepSelected;
                return pointerCard;
            }
        }
        // Prefer deep-selected card images when available.
        const imageSubTarget = subTargets.find((item: any) => isProductCardImageSelectionCandidate(item));
        if (imageSubTarget) return imageSubTarget;
        if (primary && isProductCardImageSelectionCandidate(primary)) return primary;

        // Otherwise prefer a card-like target (sub-target or primary).
        const cardSubTarget = subTargets.find((item: any) => {
            const root = resolveSelectionRootObject(item);
            return !!(root && isLikelyProductCard(root));
        });
        if (cardSubTarget) {
            const cardRoot = resolveSelectionRootObject(cardSubTarget);
            if (preferCardImages && cardRoot && isLikelyProductCard(cardRoot)) {
                const preferredImage = pickPreferredProductImageFromCard(cardRoot);
                if (preferredImage) return preferredImage;
            }
            return cardSubTarget;
        }

        if (preferCardImages) {
            const primaryRoot = resolveSelectionRootObject(primary);
            if (primaryRoot && isLikelyProductCard(primaryRoot)) {
                const preferredImage = pickPreferredProductImageFromCard(primaryRoot);
                if (preferredImage) return preferredImage;
            }
        }

        // Fallback for product zones: when Fabric reports only zone/null on Shift+click,
        // find the top card under pointer and use it as additive selection target.
        const nativeEvt = evtPayload?.e;
        if (canvas.value && nativeEvt) {
            try {
                const canvasAny = canvas.value as any;
                const scenePoint = canvasAny.getScenePoint?.(nativeEvt) || canvasAny.getPointer?.(nativeEvt, true);
                if (scenePoint && Number.isFinite(scenePoint.x) && Number.isFinite(scenePoint.y)) {
                    const all = canvas.value.getObjects().slice().reverse();
                    for (const obj of all) {
                        if (!obj || !isLikelyProductCard(obj)) continue;
                        if (obj.visible === false || obj.selectable === false) continue;
                        try {
                            if (typeof obj.containsPoint === 'function' && obj.containsPoint(scenePoint, undefined, true)) {
                                if (preferCardImages) {
                                    const preferredImage = pickPreferredProductImageFromCard(obj);
                                    if (preferredImage) return preferredImage;
                                }
                                return obj;
                            }
                        } catch {
                            // ignore containsPoint errors for corrupted objects
                        }
                        try {
                            const br = obj.getBoundingRect?.(true);
                            if (br && scenePoint.x >= br.left && scenePoint.x <= (br.left + br.width) && scenePoint.y >= br.top && scenePoint.y <= (br.top + br.height)) {
                                if (preferCardImages) {
                                    const preferredImage = pickPreferredProductImageFromCard(obj);
                                    if (preferredImage) return preferredImage;
                                }
                                return obj;
                            }
                        } catch {
                            // ignore bounding rect errors
                        }
                    }
                }
            } catch {
                // ignore fallback errors
            }
        }

        if (isActiveSelectionObject(primary)) {
            const pointerGeneric = pickGenericShiftTargetAtPointer(evtPayload?.e, {
                exclude: shiftSelectionBaselineMembers
            });
            if (pointerGeneric) return pointerGeneric;
        }

        return primary;
    };

    let isNormalizingShiftSelection = false;
    const normalizeActiveSelectionForProductCards = () => {
        if (!canvas.value || isNormalizingShiftSelection) return false;
        const activeObj = canvas.value.getActiveObject();
        if (!isActiveSelectionObject(activeObj) || typeof activeObj.getObjects !== 'function') return false;

        const rawMembers = (activeObj.getObjects() || []).slice();
        if (!rawMembers.length) return false;
        const normalized = collectNormalizedSelectionMembers(activeObj);
        const changed =
            normalized.length !== rawMembers.length ||
            normalized.some((member: any, idx: number) => member !== rawMembers[idx]);
        if (!changed) return false;

        isNormalizingShiftSelection = true;
        try {
            canvas.value.discardActiveObject();
            if (normalized.length === 1) {
                canvas.value.setActiveObject(normalized[0]);
            } else if (normalized.length > 1 && fabric?.ActiveSelection) {
                const nextSelection = new fabric.ActiveSelection(normalized, { canvas: canvas.value });
                canvas.value.setActiveObject(nextSelection);
            }
            canvas.value.requestRenderAll();
        } finally {
            isNormalizingShiftSelection = false;
        }
        return true;
    };

    // Corner handles behavior (no crop):
    // apply pure scale and keep current crop window untouched.
    const normalizeImageScaleAndCrop = (img: any, opts: { save?: boolean } = {}) => {
        if (!canvas.value || !img) return;
        const t = String(img.type || '').toLowerCase();
        if (t !== 'image') return;

        const shouldSave = opts.save !== false;
        const center = getObjectCenterInParentPlane(img);
        const scaleX = Math.abs(Number(img.scaleX ?? 1)) || 1;
        const scaleY = Math.abs(Number(img.scaleY ?? 1)) || 1;

        img.set({
            originX: 'center',
            originY: 'center',
            left: center.x,
            top: center.y,
            // Keep image crop rectangle untouched on corner scale.
            scaleX: scaleX,
            scaleY: scaleY,
            flipX: false,
            flipY: false,
            lockScalingFlip: true,
            lockSkewingX: true,
            lockSkewingY: true
        });

        sanitizeProductCardImageTransform(img, { clampWithinCard: true });
        safeAddWithUpdate(img);
        img.setCoords?.();
        canvas.value.requestRenderAll();
        if (shouldSave) saveCurrentState();
    };

    // Canva/Figma-like behavior for side handles on images:
    // - Dragging side handles crops/hides only the side you reduced.
    // - Dragging back reveals the hidden area (no stretching).
    // - Corner handles keep normal scale behavior (handled elsewhere).
    const normalizeImageCropBySideHandle = (img: any, transform: any, opts: { save?: boolean } = {}) => {
        if (!canvas.value || !img) return;
        const t = String(img.type || '').toLowerCase();
        if (t !== 'image') return;
        const prevCenter = getObjectCenterInParentPlane(img);

        const cornerRaw = String(transform?.corner || '').toLowerCase();
        if (!cornerRaw) return;

        const original = transform?.original || {};
        const abs = (n: any) => Math.abs(Number(n ?? 0) || 0);
        const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));

        // Consider flips: a flipped image swaps left/right or top/bottom behavior.
        const flipX = !!img.flipX;
        const flipY = !!img.flipY;
        let corner = cornerRaw;
        if (flipX) {
            if (corner === 'ml') corner = 'mr';
            else if (corner === 'mr') corner = 'ml';
        }
        if (flipY) {
            if (corner === 'mt') corner = 'mb';
            else if (corner === 'mb') corner = 'mt';
        }

        const isSideHandle = corner === 'ml' || corner === 'mr' || corner === 'mt' || corner === 'mb';
        if (!isSideHandle) return;

        const shouldSave = opts.save !== false;

        // Base scale BEFORE the gesture started (critical: do NOT force >=1)
        const baseScaleX = abs(original.scaleX) || abs(img.scaleX) || 1;
        const baseScaleY = abs(original.scaleY) || abs(img.scaleY) || 1;

        // Anchor point (keep the opposite side fixed, like Canva)
        let anchorOriginX: any = 'center';
        let anchorOriginY: any = 'center';
        if (corner === 'mr') { anchorOriginX = 'left'; anchorOriginY = 'center'; }
        if (corner === 'ml') { anchorOriginX = 'right'; anchorOriginY = 'center'; }
        if (corner === 'mb') { anchorOriginX = 'center'; anchorOriginY = 'top'; }
        if (corner === 'mt') { anchorOriginX = 'center'; anchorOriginY = 'bottom'; }
        const anchorPoint = (typeof img.getPointByOrigin === 'function')
            ? img.getPointByOrigin(anchorOriginX, anchorOriginY)
            : null;

        const curW = Math.max(1, Number(img.width ?? 1) || 1);
        const curH = Math.max(1, Number(img.height ?? 1) || 1);
        const desiredDisplayW = Math.max(1, curW * (abs(img.scaleX) || 1));
        const desiredDisplayH = Math.max(1, curH * (abs(img.scaleY) || 1));

        // Source (natural) dimensions in pixels
        const el: any = (img as any)._originalElement || (img as any)._element || null;
        const srcW = Math.max(1, Number((img as any).__sourceWidth ?? el?.naturalWidth ?? el?.width ?? curW) || 1);
        const srcH = Math.max(1, Number((img as any).__sourceHeight ?? el?.naturalHeight ?? el?.height ?? curH) || 1);
        (img as any).__sourceWidth = srcW;
        (img as any).__sourceHeight = srcH;

        const prevCropX = Math.max(0, Number(img.cropX ?? 0) || 0);
        const prevCropY = Math.max(0, Number(img.cropY ?? 0) || 0);
        const prevCropW = clamp(curW, 1, srcW);
        const prevCropH = clamp(curH, 1, srcH);

        // Convert the user's handle drag (display size) into crop size at the BASE scale.
        const nextCropW = clamp(desiredDisplayW / baseScaleX, 1, srcW);
        const nextCropH = clamp(desiredDisplayH / baseScaleY, 1, srcH);

        // Only move crop origin for the axis being resized, keeping the opposite edge fixed.
        let nextCropX = prevCropX;
        let nextCropY = prevCropY;

        if (corner === 'ml') {
            nextCropX = prevCropX + (prevCropW - nextCropW);
        } else if (corner === 'mr') {
            nextCropX = prevCropX;
        }

        if (corner === 'mt') {
            nextCropY = prevCropY + (prevCropH - nextCropH);
        } else if (corner === 'mb') {
            nextCropY = prevCropY;
        }

        nextCropX = clamp(nextCropX, 0, srcW - nextCropW);
        nextCropY = clamp(nextCropY, 0, srcH - nextCropH);

        img.set({
            // Reset the scaling caused by Fabric's resize gesture back to the pre-gesture scale
            scaleX: baseScaleX,
            scaleY: baseScaleY,
            width: nextCropW,
            height: nextCropH,
            cropX: nextCropX,
            cropY: nextCropY,
            flipX: false,
            flipY: false,
            lockScalingFlip: true,
            lockSkewingX: true,
            lockSkewingY: true
        });

        if (anchorPoint && typeof img.setPositionByOrigin === 'function') {
            img.setPositionByOrigin(anchorPoint, anchorOriginX, anchorOriginY);
        }

        // Keep the orthogonal axis stable for side handles to avoid visual "jump":
        // ml/mr should preserve Y center; mt/mb should preserve X center.
        const nextCenter = getObjectCenterInParentPlane(img);
        if (corner === 'ml' || corner === 'mr') {
            if (Math.abs(Number(nextCenter.y || 0) - Number(prevCenter.y || 0)) > 0.001) {
                setObjectCenterInParentPlane(img, Number(nextCenter.x || 0), Number(prevCenter.y || 0));
            }
        } else if (corner === 'mt' || corner === 'mb') {
            if (Math.abs(Number(nextCenter.x || 0) - Number(prevCenter.x || 0)) > 0.001) {
                setObjectCenterInParentPlane(img, Number(prevCenter.x || 0), Number(nextCenter.y || 0));
            }
        }

        sanitizeProductCardImageTransform(img, { clampWithinCard: true });
        safeAddWithUpdate(img);
        img.setCoords?.();
        canvas.value.requestRenderAll();
        if (shouldSave) saveCurrentState();
    };

    let lastUpdateObjectsSanitizeAt = 0;
    const updateObjects = () => {
        const canvasInstance = canvas.value;
        if (!canvasInstance || isCanvasDestroyed.value) return;
        const now = Date.now();
        if ((now - lastUpdateObjectsSanitizeAt) > 1200) {
            sanitizeCanvasObjectStack(canvasInstance as any, 'updateObjects:throttled');
            lastUpdateObjectsSanitizeAt = now;
        }

        // CRITICAL: Preserve exact order from canvas.getObjects()
        // Don't reorder or sort - maintain order as saved
        const objs = canvasInstance.getObjects();
        const toRemove: any[] = [];
        let hasInvalid = false;

        const isGuideOverlay = (o: any): boolean => {
            const id = String(o?.id || '');
            if (id === 'guide-vertical' || id === 'guide-horizontal') return true; // snap overlays
            if (id.startsWith('guide-user-') || o?.isUserGuide === true) return true; // persistent user guides
            return false;
        };
        
        objs.forEach((o: any) => {
            if (!isValidFabricCanvasObject(o)) {
                hasInvalid = true;
                console.error('❌ [updateObjects] Objeto inválido detectado no canvas (será ignorado/purgado):', o);
                return;
            }
            ensurePersistentContentFlags(o);
            const name = o.name || '';
            
            // Clean up orphaned control objects that shouldn't be visible
            if ((name === 'path_node' || name === 'bezier_handle' || name === 'control_point' || name === 'handle_line') && !isNodeEditing.value) {
                toRemove.push(o);
                return;
            }
            
            // Clean up preview objects if not in pen mode
            if (isTransientCanvasObject(o) && !isPenMode.value && !isNodeEditing.value) {
                // Keep guide overlays; setupSnapping + rulers own their lifecycle.
                if (isGuideOverlay(o)) return;
                toRemove.push(o);
                return;
            }
            
            // Clean up small circles that are likely orphaned control points
            if (o.type === 'circle' && o.radius && o.radius <= 7 && !o._customId) {
                toRemove.push(o);
                return;
            }
            
            // Clean up lines without _customId (handle lines)
            if (o.type === 'line' && !o._customId && !isNodeEditing.value) {
                // Keep guide overlays (snap + user guides)
                if (isGuideOverlay(o)) return;
                toRemove.push(o);
                return;
            }
            
            // Only assign _customId to real objects (not control points or preview objects)
            const isControlObject = name === 'path_node' || name === 'bezier_handle' || name === 'control_point' || name === 'handle_line';
            const isSmallControlCircle = o.type === 'circle' && o.radius && o.radius <= 7;
            const hasControlData = o.data && (o.data.parentPath || o.data.parentObj);
            
            if (!o._customId && !isTransientCanvasObject(o) && !isControlObject && !isSmallControlCircle && !hasControlData) {
                o._customId = makeCanvasObjectId();
            }
        });

        // If something corrupted the internal stack (e.g., number inserted into _objects), purge it to prevent render crashes.
        if (hasInvalid) {
            const internal = (canvasInstance as any)._objects;
            if (Array.isArray(internal)) {
                const next = internal.filter((o: any) => isValidFabricCanvasObject(o));
                if (next.length !== internal.length) {
                    internal.length = 0;
                    next.forEach((o: any) => internal.push(o));
                    if (typeof (canvasInstance as any)._onStackOrderChanged === 'function') (canvasInstance as any)._onStackOrderChanged();
                }
            }
        }
        
        // Remove orphaned objects (from end to preserve order)
        if (toRemove.length > 0) {
            toRemove.forEach((obj: any) => {
                try {
                    canvasInstance.remove(obj);
                } catch (e) {
                    // Ignore errors
                }
            });
        }
        
        // CRITICAL: Preserve exact order - don't reorder or sort
        refreshCanvasObjects({ source: canvasInstance.getObjects(), immediate: true });
    };

    let updateObjectsRafId: number | null = null;
    const scheduleUpdateObjects = () => {
        if (updateObjectsRafId !== null) return;
        updateObjectsRafId = requestAnimationFrame(() => {
            updateObjectsRafId = null;
            if (!canvas.value || isCanvasDestroyed.value) return;
            updateObjects();
            scheduleViewportCulling('objects-sync');
        });
    };

    canvas.value.on('object:added', scheduleUpdateObjects);
    canvas.value.on('object:removed', scheduleUpdateObjects);
    canvas.value.on('object:modified', scheduleUpdateObjects); 

    // Frames: auto-parent new objects when created inside a frame + keep clipPaths in sync
    canvas.value.on('object:added', (e: any) => {
        const obj = e?.target;
        if (!obj || typeof obj !== 'object' || isTransientCanvasObject(obj)) return;
        ensurePersistentContentFlags(obj);
        
        // Don't assign _customId to control objects
        const name = obj.name || '';
        const isControlObject = name === 'path_node' || name === 'bezier_handle' || name === 'control_point' || name === 'handle_line';
        const isSmallControlCircle = obj.type === 'circle' && obj.radius && obj.radius <= 7;
        const hasControlData = obj.data && (obj.data.parentPath || obj.data.parentObj);
        
        if (!obj._customId && !isControlObject && !isSmallControlCircle && !hasControlData) {
            obj._customId = makeCanvasObjectId();
        }

        // Skip auto-parenting for product cards — they are managed by simulateSmartGrid
        // and should NOT be clipped by the Frame (they sit on top of it).
        if (obj.isSmartObject || obj.isProductCard) return;

        if (!obj.parentFrameId) {
            const frame = findFrameUnderObject(obj);
            if (frame && frame._customId) obj.parentFrameId = frame._customId;
        }
        syncObjectFrameClip(obj);
    });

    canvas.value.on('object:modified', (e: any) => {
        const obj = e?.target;
        if (!obj || isTransientCanvasObject(obj)) return;
        ensurePersistentContentFlags(obj);
        const action = e?.transform?.action || '';
        const didScale = typeof action === 'string' && action.includes('scale');
        const transformTarget = e?.transform?.target;
        const isChildImageTransformOnCard = !!(
            obj &&
            isLikelyProductCard(obj) &&
            transformTarget &&
            transformTarget !== obj &&
            transformTarget.group === obj &&
            String(transformTarget.type || '').toLowerCase() === 'image'
        );

        if (isActiveSelectionObject(obj) && typeof obj.getObjects === 'function') {
            const members = (obj.getObjects() || []).slice();
            members.forEach((member: any) => {
                if (!member || isTransientCanvasObject(member)) return;
                ensurePersistentContentFlags(member);
                try { maybeReparentToFrameOnDrop(member); } catch {}
                try {
                    if (isLikelyProductCard(member) && (member as any).parentZoneId && canvas.value) {
                        const zoneId = String((member as any).parentZoneId || '').trim();
                        const zone = canvas.value.getObjects().find((o: any) => (
                            isLikelyProductZone(o) && String((o as any)._customId || '') === zoneId
                        ));
                        if (zone) applyCardFrameBinding(member, getResolvedZoneFrameId(zone));
                    }
                } catch {}
                try { syncObjectFrameClip(member); } catch {}
                if (didScale && String(member.type || '').toLowerCase() === 'image' && ((member.scaleX ?? 1) !== 1 || (member.scaleY ?? 1) !== 1)) {
                    const corner = String(e?.transform?.corner || '').toLowerCase();
                    const isSide = corner === 'ml' || corner === 'mr' || corner === 'mt' || corner === 'mb';
                    if (isSide) {
                        normalizeImageCropBySideHandle(member, e?.transform, { save: false });
                    } else {
                        normalizeImageScaleAndCrop(member, { save: false });
                    }
                }
                sanitizeProductCardImageTransform(member, { clampWithinCard: true });
                if (shouldApplyContainmentConstraints(member)) {
                    applyContainmentConstraints(member);
                }
            });
            return;
        }

        // If a product card was resized (scaled), convert scale into width/height and reflow internals (image/title/limit/label).
        // This keeps layout crisp and responsive instead of just stretching the whole group.
        if (!isChildImageTransformOnCard && didScale && isLikelyProductCard(obj) && ((obj.scaleX ?? 1) !== 1 || (obj.scaleY ?? 1) !== 1)) {
            normalizeCardScaleAndRelayout(obj, { save: false });
        }
        // Images:
        // - Corner handles: normal scale behavior (no crop conversion).
        // - Side handles (ml/mr/mt/mb): crop/hide only the reduced side (Canva-like).
        if (didScale && String(obj.type || '').toLowerCase() === 'image' && ((obj.scaleX ?? 1) !== 1 || (obj.scaleY ?? 1) !== 1)) {
            const corner = String(e?.transform?.corner || '').toLowerCase();
            const isSide = corner === 'ml' || corner === 'mr' || corner === 'mt' || corner === 'mb';
            if (isSide) {
                normalizeImageCropBySideHandle(obj, e?.transform, { save: false });
            } else {
                normalizeImageScaleAndCrop(obj, { save: false });
            }
        }
        sanitizeProductCardImageTransform(obj, { clampWithinCard: true });

        // Mark dirty after modification to ensure clean render
        obj.set('dirty', true);

        maybeReparentToFrameOnDrop(obj);
        if (isLikelyProductZone(obj)) {
            syncZoneCardFrameBindings(obj);
        } else if (isLikelyProductCard(obj) && (obj as any).parentZoneId && canvas.value) {
            const zoneId = String((obj as any).parentZoneId || '').trim();
            const zone = canvas.value.getObjects().find((o: any) => isLikelyProductZone(o) && String((o as any)._customId || '') === zoneId);
            if (zone) {
                const zoneFrameId = getResolvedZoneFrameId(zone);
                applyCardFrameBinding(obj, zoneFrameId);
            }
        }
        syncObjectFrameClip(obj);

        if (obj.isFrame) {
            getOrCreateFrameClipRect(obj);
            syncFrameClips(obj);
        }
        // Keep frame stacking stable only when a frame itself changed.
        // Reordering on every child drop can cause visual "stomp" on clipped backgrounds.
        if (obj.isFrame) {
            ensureFramesBelowContents();
        }
    });

    canvas.value.on('object:modified', () => { 
        // CRITICAL: Create a fresh snapshot instead of just triggering the old one.
        // After modifications (drag, scale, etc.) the Fabric object's properties may have changed
        // (e.g. ensureZoneSanity, normalizeZoneScale). A stale snapshot causes PropertiesPanel
        // to show outdated values or lose zone detection entirely for legacy arts.
        refreshSelectedRef();
        invalidateScrollbarBounds();
        updateScrollbars(); // Update scrollbars
        updateFloatingUI();
    });
    
    // Auto-Layout: When a product card is added, find its parent zone and trigger layout
    let layoutDebounceTimer: any = null;
    let pendingZones: Set<any> = new Set();
    
    canvas.value.on('object:added', (e: any) => {
        if (isBulkProductMutation || isHistoryProcessing.value || isDesignLoading.value) return;
        const obj = e.target;
        if (!obj) return;
        const isCard = !!(obj.isProductCard || obj.isSmartObject || isLikelyProductCard(obj));
        if (!isCard) return;
        
        // Find intersecting zone
        const zones = canvas.value.getObjects().filter((o: any) => o.isGridZone || o.isProductZone);
        for (const zone of zones) {
            if (zone.intersectsWithObject(obj)) {
                // Bind to zone
                obj.parentZoneId = zone._customId;
                const zoneFrameId = getResolvedZoneFrameId(zone);
                applyCardFrameBinding(obj, zoneFrameId);
                pendingZones.add(zone);
                break;
            }
        }
        
        // Debounced layout - waits for all objects in batch to be added
        clearTimeout(layoutDebounceTimer);
        layoutDebounceTimer = setTimeout(() => {
            pendingZones.forEach(zone => {
                recalculateZoneLayout(zone, undefined, { save: false });
            });
            pendingZones.clear();
        }, 100); // 100ms debounce
    });

    // Realtime updates during interaction
    // === PERFORMANCE CACHE ===
    let frameChildrenCache: any[] = [];
    let lastFrameState = { left: 0, top: 0 };
    let gridGroupSiblingCache: any[] = [];
    let gridGroupSiblingCacheId: string | null = null;
    let zoneChildrenCache: any[] = [];
    let lastZoneState = { left: 0, top: 0 };

    canvas.value.on('mouse:down:before', (e: any) => {
        if (e?.e?.shiftKey) {
            refreshShiftSelectionBaseline(canvas.value.getActiveObject?.());
            return;
        }
        shiftSelectionBaselineMembers = [];
    });

    canvas.value.on('mouse:down', (e: any) => {
         const evt: MouseEvent | undefined = e?.e;
         const isContextClick = !!evt && (evt.button === 2 || (evt.button === 0 && (evt as any).ctrlKey && !(evt as any).metaKey));
         if (isContextClick) {
             evt?.preventDefault?.();
             evt?.stopPropagation?.();
             if (layersContextMenu.value.show) layersContextMenu.value.show = false;

             // Figma-like: right-click selects the target under cursor (if any).
             const current = canvas.value.getActiveObject?.();
             const keepActiveSelection =
                 current &&
                 current.type === 'activeSelection' &&
                 e.target &&
                 typeof current.getObjects === 'function' &&
                 current.getObjects().includes(e.target);

             if (e.target && !keepActiveSelection) {
                 canvas.value.setActiveObject(e.target);
                 updateSelection();
             }

             canvasContextMenu.value.x = (evt as any).clientX ?? 0;
             canvasContextMenu.value.y = (evt as any).clientY ?? 0;
             canvasContextMenu.value.show = true;
             return;
         }

        if (canvasContextMenu.value.show) canvasContextMenu.value.show = false;
        if (layersContextMenu.value.show) layersContextMenu.value.show = false;
        const target = e.target;

        // Global Shift+click additive multi-selection:
        // keep existing selection and append target in all editor contexts.
        if (evt?.shiftKey && !isNormalizingShiftSelection) {
            evt.preventDefault?.();
            evt.stopPropagation?.();
            const shiftTarget = pickShiftSelectionTarget(e) || target;
            let normalizedTarget = resolveShiftSelectionRootObject(shiftTarget);
            if (!normalizedTarget || isActiveSelectionObject(normalizedTarget)) {
                const pointerGeneric = pickGenericShiftTargetAtPointer(e?.e, {
                    exclude: shiftSelectionBaselineMembers
                });
                if (pointerGeneric) {
                    normalizedTarget = pointerGeneric;
                }
            }
            if (import.meta.dev) {
                console.log('[shift-product-multi] resolve', {
                    rawTargetType: String(target?.type || ''),
                    rawTargetName: String(target?.name || ''),
                    rawTargetId: String((target as any)?._customId || ''),
                    shiftTargetType: String((shiftTarget as any)?.type || ''),
                    shiftTargetName: String((shiftTarget as any)?.name || ''),
                    shiftTargetId: String((shiftTarget as any)?._customId || ''),
                    normalizedType: String((normalizedTarget as any)?.type || ''),
                    normalizedName: String((normalizedTarget as any)?.name || ''),
                    normalizedId: String((normalizedTarget as any)?._customId || ''),
                    normalizedIsImage: String((normalizedTarget as any)?.type || '').toLowerCase() === 'image',
                    normalizedParentCard: !!findProductCardParentGroup(normalizedTarget),
                });
            }
            if (normalizedTarget) {
                const currentMembersRaw = shiftSelectionBaselineMembers.length
                    ? shiftSelectionBaselineMembers
                    : collectShiftSelectionMembers(canvas.value.getActiveObject());
                const currentMembers = currentMembersRaw
                    .map((member: any) => resolveShiftSelectionRootObject(member))
                    .filter((member: any) => !!member)
                    .filter((member: any, idx: number, arr: any[]) => arr.indexOf(member) === idx);
                let finalTarget = normalizedTarget;
                let isAlreadySelected = currentMembers.includes(finalTarget);
                if (isAlreadySelected) {
                    const pointerImage = findTopProductImageAtPointer(e?.e, {
                        exclude: currentMembers
                    });
                    if (pointerImage && !currentMembers.includes(pointerImage)) {
                        finalTarget = pointerImage;
                        isAlreadySelected = false;
                    } else {
                        const pointerCard = findTopProductCardAtPointer(e?.e);
                        if (pointerCard) {
                            const pointerPreferred =
                                pickPreferredProductImageFromCard(pointerCard) ||
                                getDeepSelectedProductImageFromCard(pointerCard) ||
                                pointerCard;
                            if (pointerPreferred && !currentMembers.includes(pointerPreferred)) {
                                finalTarget = pointerPreferred;
                                isAlreadySelected = false;
                            }
                        }
                    }
                    if (isAlreadySelected) {
                        const pointerGeneric = pickGenericShiftTargetAtPointer(e?.e, {
                            exclude: currentMembers
                        });
                        if (pointerGeneric && !currentMembers.includes(pointerGeneric)) {
                            finalTarget = pointerGeneric;
                            isAlreadySelected = false;
                        }
                    }
                }
                if (import.meta.dev) {
                    console.log('[shift-product-multi] baseline', {
                        baselineCount: currentMembers.length,
                        isAlreadySelected,
                        currentMemberIds: currentMembers.map((member: any) => String((member as any)?._customId || '')),
                        finalTargetId: String((finalTarget as any)?._customId || ''),
                        finalTargetType: String((finalTarget as any)?.type || ''),
                        finalTargetName: String((finalTarget as any)?.name || '')
                    });
                }
                if (!isAlreadySelected) {
                    const nextMembers = [...currentMembers, finalTarget];
                    if (import.meta.dev) {
                        console.log('[shift-product-multi] nextMembers', nextMembers.map((member: any) => ({
                            type: String(member?.type || ''),
                            name: String(member?.name || ''),
                            isImage: String(member?.type || '').toLowerCase() === 'image',
                            hasCardParent: !!findProductCardParentGroup(member),
                            selectable: member?.selectable,
                            evented: member?.evented
                        })));
                    }
                    nextMembers.forEach((member: any) => {
                        if (!member || String(member?.type || '').toLowerCase() !== 'image') return;
                        try {
                            member.set?.({
                                selectable: true,
                                evented: true,
                                hasControls: true,
                                hasBorders: true
                            });
                            member.setCoords?.();
                        } catch {
                            // ignore
                        }
                    });
                    canvas.value.discardActiveObject();
                    if (nextMembers.length === 1) {
                        canvas.value.setActiveObject(nextMembers[0]);
                    } else if (fabric?.ActiveSelection) {
                        const nextSelection = new fabric.ActiveSelection(nextMembers, { canvas: canvas.value });
                        canvas.value.setActiveObject(nextSelection);
                    }
                    if (import.meta.dev) {
                        const activeAfter = canvas.value.getActiveObject?.();
                        const activeType = String(activeAfter?.type || '').toLowerCase();
                        const activeMembers = activeType === 'activeselection' && typeof activeAfter?.getObjects === 'function'
                            ? (activeAfter.getObjects() || []).map((member: any) => ({
                                type: String(member?.type || ''),
                                name: String(member?.name || ''),
                                isImage: String(member?.type || '').toLowerCase() === 'image',
                                hasCardParent: !!findProductCardParentGroup(member)
                            }))
                            : [];
                        console.log('[shift-product-multi] activeAfter', {
                            activeType,
                            activeName: String(activeAfter?.name || ''),
                            activeMembers
                        });
                    }
                    updateSelection();
                    canvas.value.requestRenderAll();
                }
                refreshShiftSelectionBaseline(canvas.value.getActiveObject?.());
                // Intercept Shift behavior in this mode to avoid Fabric default toggle/deselect.
                return;
            }
        }

        if (target && target.isFrame) {
            frameChildrenCache = getFrameDescendants(target);
            lastFrameState = { left: target.left, top: target.top };
            getOrCreateFrameClipRect(target);
            if (target.gridGroupId && target.isGridCell) {
                gridGroupSiblingCacheId = String(target.gridGroupId);
                gridGroupSiblingCache = canvas.value.getObjects().filter(
                    (o: any) => o !== target && o.gridGroupId === target.gridGroupId && o.isGridCell
                );
            } else {
                gridGroupSiblingCache = [];
                gridGroupSiblingCacheId = null;
            }
            // Renderizar canvas para mostrar o label do frame
            canvas.value.requestRenderAll();
        } else {
            if (!e.e?.shiftKey) frameChildrenCache = [];
            gridGroupSiblingCache = [];
            gridGroupSiblingCacheId = null;
        }

	        if (target && isLikelyProductZone(target)) {
             ensureZoneSanity(target);
             // Cache children once on start drag
             zoneChildrenCache = getZoneChildren(target);
             
             lastZoneState = { left: target.left, top: target.top };
         } else {
             // Clear cache if clicking elsewhere
             if (!e.e?.shiftKey) zoneChildrenCache = [];
         }
    });
    
    // Realtime updates during interaction
    // Throttled floating UI update (avoid expensive getBoundingRect on every move frame)
    let floatingUIRafPending = false;
    let pendingObjectMoveViewportCull = false;
    const flushObjectMoveViewportCull = () => {
        if (!pendingObjectMoveViewportCull) return;
        pendingObjectMoveViewportCull = false;
        scheduleViewportCulling('object-move-end');
    };
    canvas.value.on('object:moving', (e: any) => {
        lastTransformMutationAt = Date.now();
        const target = e.target;
        const isCardImageTarget = !!(
            target &&
            String(target.type || '').toLowerCase() === 'image' &&
            isProductCardImage(target)
        );
        if (!isCardImageTarget) {
            pendingObjectMoveViewportCull = true;
        }

        const activeObj = canvas.value.getActiveObject?.();
        const shouldUpdateFloatingUI = !!(
            !isCardImageTarget &&
            target &&
            activeObj &&
            (
                activeObj === target ||
                (
                    activeObj.type === 'activeSelection' &&
                    typeof (activeObj as any).getObjects === 'function' &&
                    (activeObj as any).getObjects().includes(target)
                )
            )
        );
        if (shouldUpdateFloatingUI && !floatingUIRafPending) {
            floatingUIRafPending = true;
            requestAnimationFrame(() => {
                updateFloatingUI();
                floatingUIRafPending = false;
            });
        }

        // Frame moves its descendants (Figma-like parenting)
        if (target && target.isFrame) {
            // Mark dirty to ensure fresh render (keep caching for performance)
            target.set('dirty', true);

            const dx = target.left - lastFrameState.left;
            const dy = target.top - lastFrameState.top;

            if (frameChildrenCache.length === 0) {
                frameChildrenCache = getFrameDescendants(target);
            }
            moveFrameDescendants(target, dx, dy, frameChildrenCache);
            lastFrameState.left = target.left;
            lastFrameState.top = target.top;
            getOrCreateFrameClipRect(target);

            // ─── Grid group: move sibling cells together ────────────────
            if (target.gridGroupId && target.isGridCell && (dx || dy)) {
                const gridId = String(target.gridGroupId);
                let siblings = (gridGroupSiblingCacheId === gridId) ? gridGroupSiblingCache : [];
                if (siblings.length === 0) {
                    siblings = canvas.value.getObjects().filter(
                        (o: any) => o !== target && o.gridGroupId === target.gridGroupId && o.isGridCell
                    );
                    gridGroupSiblingCache = siblings;
                    gridGroupSiblingCacheId = gridId;
                }
                siblings.forEach((sib: any) => {
                    sib.set({ left: (sib.left ?? 0) + dx, top: (sib.top ?? 0) + dy });
                    sib.setCoords?.();
                    // Also move the sibling's frame descendants
                    const sibDescendants = getFrameDescendants(sib);
                    moveFrameDescendants(sib, dx, dy, sibDescendants);
                    if (sib.clipContent) {
                        getOrCreateFrameClipRect(sib);
                        sibDescendants.forEach((child: any) => {
                            syncObjectFrameClip(child);
                        });
                    }
                });
            }

            // Update clipPath para todos os filhos (absolutePositioned: false
            // = relativo ao objeto, mas como o frame moveu e os filhos também,
            // precisamos recalcular o offset relativo)
            if (target.clipContent) {
                const fc = target.getCenterPoint ? target.getCenterPoint() : { x: target.left, y: target.top };
                const DEG2RAD = Math.PI / 180;
                frameChildrenCache.forEach((child: any) => {
                    if (child.clipPath && (child as any)._frameClipOwner === target._customId) {
                        const childCenter = child.getCenterPoint ? child.getCenterPoint() : { x: child.left, y: child.top };
                        const dxW = fc.x - childCenter.x;
                        const dyW = fc.y - childCenter.y;
                        const childAngle = child.angle || 0;
                        const aRad = -childAngle * DEG2RAD;
                        const cosA = Math.cos(aRad);
                        const sinA = Math.sin(aRad);
                        child.clipPath.set({
                            left: (dxW * cosA - dyW * sinA) / (child.scaleX || 1),
                            top: (dxW * sinA + dyW * cosA) / (child.scaleY || 1),
                            scaleX: (target.scaleX || 1) / (child.scaleX || 1),
                            scaleY: (target.scaleY || 1) / (child.scaleY || 1),
                            angle: (target.angle || 0) - childAngle,
                        });
                        child.clipPath.setCoords();
                        child.clipPath.dirty = true;
                        child.set('dirty', true);
                    }
                });
            }

            // Fabric renders after object:moving — no explicit requestRenderAll needed
            return;
        }

        // Optimized Zone Move
        if (target && isLikelyProductZone(target)) {
            ensureZoneSanity(target);
            if (zoneChildrenCache.length === 0) {
                zoneChildrenCache = getZoneChildren(target);
            }

            const dx = target.left - lastZoneState.left;
            const dy = target.top - lastZoneState.top;

            // Move all cached children by delta
            zoneChildrenCache.forEach((child: any) => {
                child.set({
                    left: child.left + dx,
                    top: child.top + dy
                });
                child.setCoords();
            });

            // Update last state
            lastZoneState.left = target.left;
            lastZoneState.top = target.top;
        }

        // Containment during drag is handled in setupSnapping/object:moving and
        // finalized in object:modified. Re-running here causes jitter.
    });

    // Smart Scaling for Textbox Reflow & Product Zone AutoLayout
    canvas.value.on('object:scaling', (e: any) => {
        lastTransformMutationAt = Date.now();
        updateFloatingUI();
        const obj = e.target;
        const scalingCorner = String(e?.transform?.corner || '').toLowerCase();
        const isSideScaleHandle = scalingCorner === 'ml' || scalingCorner === 'mr' || scalingCorner === 'mt' || scalingCorner === 'mb';

        // Smooth side-handle crop preview (Canva-like):
        // apply crop conversion on every scaling tick to avoid the "compress first, crop after release" jump.
        if (obj && String(obj.type || '').toLowerCase() === 'image' && isSideScaleHandle) {
            normalizeImageCropBySideHandle(obj, e?.transform, { save: false });
            if ((obj as any).parentFrameId) {
                syncObjectFrameClip(obj);
            }
            return;
        }

        // Frames: keep clip rect synced while resizing + update children clips
        if (obj && obj.isFrame) {
            getOrCreateFrameClipRect(obj);
            // Atualizar clips dos filhos em tempo real durante redimensionamento do frame
            if (obj.clipContent) {
                syncFrameClips(obj);
            }
        }

        // Filhos de frame: recalcular clip durante scaling do objeto
        if (obj && !obj.isFrame && obj.parentFrameId && obj.clipPath) {
            syncObjectFrameClip(obj);
        }

        // 1. Textbox Reflow
        if (obj && obj.type === 'textbox' && obj.lockScalingY) {
            const w = obj.width * obj.scaleX;
            obj.set({
                width: w,
                scaleX: 1
            });

            // Keep centered text inside product card groups
            if (obj.originX === 'center' && obj.group && (obj.group.isSmartObject || obj.group.isProductCard || isLikelyProductCard(obj.group))) {
                obj.set({ left: 0 });
                const cardGroup = obj.group;
                const cardW = Number((cardGroup as any)?._cardWidth ?? cardGroup?.width ?? cardGroup?.getScaledWidth?.() ?? 0);
                const cardH = Number((cardGroup as any)?._cardHeight ?? cardGroup?.height ?? cardGroup?.getScaledHeight?.() ?? 0);
                const maxCardW = Number.isFinite(cardW) && cardW > 0 ? Math.max(20, cardW) : Number.POSITIVE_INFINITY;
                const safeW = Math.min(maxCardW, Math.max(20, Number(w) || 0));
                obj.set({ width: safeW, scaleX: 1 });
                (obj as any).__manualTransform = true;
                (obj as any).__manualTextWidth = safeW;
                if (Number.isFinite(cardW) && cardW > 0) {
                    (obj as any).__manualTextWidthRatio = Math.min(1, Math.max(0.1, safeW / cardW));
                    (obj as any).__manualTransformCardW = cardW;
                }
                if (Number.isFinite(cardH) && cardH > 0) {
                    (obj as any).__manualTransformCardH = cardH;
                }
            }
        }

        // 2. Rect Border-Radius Preservation (Figma-style)
        // Atualiza o border-radius em tempo real durante o redimensionamento
        if (obj && obj.type === 'rect' && (obj.rx || obj.ry)) {
            const scaledWidth = Math.abs(obj.getScaledWidth?.() ?? (obj.width * obj.scaleX));
            const scaledHeight = Math.abs(obj.getScaledHeight?.() ?? (obj.height * obj.scaleY));
            const maxRadius = Math.min(scaledWidth / 2, scaledHeight / 2);

            // Limita o radius para não exceder metade da menor dimensão
            if (obj.rx > maxRadius) {
                obj.set({ rx: maxRadius, ry: maxRadius });
            }
        }

        // 2b. Group Rect Border-Radius Preservation (Realtime)
        // Para grupos com retângulos internos (smart objects, cards, etc.)
        if (obj && obj.type === 'group' && obj.getObjects) {
            const objects = obj.getObjects();
            if (Array.isArray(objects)) {
                objects.forEach((child: any) => {
                    if (child.type === 'rect' && (child.rx || child.ry)) {
                        const childScaledWidth = Math.abs(child.getScaledWidth?.() ?? (child.width * child.scaleX));
                        const childScaledHeight = Math.abs(child.getScaledHeight?.() ?? (child.height * child.scaleY));
                        const maxChildRadius = Math.min(childScaledWidth / 2, childScaledHeight / 2);

                        if (child.rx > maxChildRadius) {
                            child.set({ rx: maxChildRadius, ry: maxChildRadius });
                        }
                    }
                });
            }
        }

        // 3. Zone Auto-Layout (Realtime Resize)
        if (obj && isLikelyProductZone(obj)) {
            // CRITICAL: Cache children BEFORE updating zone dimensions
            // This prevents losing cards that may fall outside new bounds during resize
            const cachedChildren = getZoneChildren(obj);

            ensureZoneSanity(obj);
            obj.setCoords();
            obj._zoneWidth = Math.abs(obj.getScaledWidth?.() ?? obj._zoneWidth ?? 0);
            obj._zoneHeight = Math.abs(obj.getScaledHeight?.() ?? obj._zoneHeight ?? 0);

            // Use cached children to ensure they stay bound to zone during resize
            recalculateZoneLayout(obj, cachedChildren, { save: false });
        }

        // 🔒 Apply containment after scaling.
        // During active scale of product images, avoid hard clamping each frame because
        // Fabric may use temporary side origins; clamping runs on `object:modified`.
        const isCardImageScaling = !!(
            obj &&
            String(obj.type || '').toLowerCase() === 'image' &&
            isProductCardImage(obj)
        );
        sanitizeProductCardImageTransform(obj, { clampWithinCard: !isCardImageScaling });
        if (!isCardImageScaling && shouldApplyContainmentConstraints(obj)) {
            applyContainmentConstraints(obj);
        }

        // Force live redraw while resizing. In some Fabric/browser combinations the
        // visual of simple shapes (ex: rect) can lag until the next interaction.
        if (obj) {
            obj.set?.('dirty', true);
            obj.setCoords?.();
        }
        safeRequestRenderAll();
    });

    canvas.value.on('object:rotating', () => {
        lastTransformMutationAt = Date.now();
    });
    
    // 🔒 Apply containment after modification (drag end)
    canvas.value.on('object:modified', (e: any) => {
        const obj = e.target;
        if (obj) {
            // Product card zone-lock should be finalized here to avoid per-frame work.
            if (!isLikelyProductZone(obj) && !obj.isFrame) {
                const isCardLike = !!(
                    obj.isSmartObject ||
                    obj.isProductCard ||
                    String(obj.name || '').startsWith('product-card') ||
                    isLikelyProductCard(obj) ||
                    String((obj as any).parentZoneId || '').trim().length
                );
                if (isCardLike) {
                    ensureCardZoneBinding(obj, { allowNearest: true });
                }
            }

            if (shouldApplyContainmentConstraints(obj)) {
                applyContainmentConstraints(obj);
            }

            // Re-center textboxes inside product cards after resize
            if (obj.type === 'textbox' && obj.originX === 'center' && obj.group && (obj.group.isSmartObject || obj.group.isProductCard || isLikelyProductCard(obj.group))) {
                obj.set({ left: 0 });
                obj.setCoords();
                canvas.value.requestRenderAll();
            }
        }
        flushObjectMoveViewportCull();
    });
    canvas.value.on('mouse:up', flushObjectMoveViewportCull);

    const syncTextSelectionSnapshot = (e: any) => {
        if (!canvas.value) return;
        const activeObj = canvas.value.getActiveObject?.();
        const target = e?.target;
        if (!isTextStyleObject(activeObj) && !isTextStyleObject(target)) return;
        refreshSelectedRef();
    };

    const isTextTargetObject = (obj: any) => {
        const t = String(obj?.type || '').toLowerCase();
        return t === 'text' || t === 'i-text' || t === 'textbox';
    };

    // Keep `_productData.name` aligned with the visible title text so manual line breaks survive
    // all persistence/rebuild paths (reload, re-import review modal, relayout side-effects).
    const syncCardProductDataNameFromTitleTarget = (target: any): boolean => {
        if (!target || !isTextTargetObject(target)) return false;

        const card = findProductCardParentGroup(target);
        if (!card || !isProductCardContainer(card)) return false;

        const titleObj = getCardTitleText(card);
        if (!titleObj || titleObj !== target) return false;

        const nextName = String((titleObj as any).text ?? '').replace(/\r\n?/g, '\n');
        (titleObj as any).__rawText = nextName;

        const currentName = String((card as any)?._productData?.name ?? '');
        if (currentName === nextName) return false;

        const baseProductData = ((card as any)?._productData && typeof (card as any)._productData === 'object')
            ? (card as any)._productData
            : {};
        (card as any)._productData = {
            ...baseProductData,
            name: nextName
        };
        return true;
    };

    const handleTextChanged = (e: any) => {
        syncTextSelectionSnapshot(e);
        const target = e?.target;
        const didSyncCardName = syncCardProductDataNameFromTitleTarget(target);
        if (didSyncCardName || isTextTargetObject(target)) {
            queueTextEditSave('text-edit');
        }
    };

    const handleTextEditingExited = (e: any) => {
        syncTextSelectionSnapshot(e);
        const target = e?.target;
        const didSyncCardName = syncCardProductDataNameFromTitleTarget(target);
        if (didSyncCardName || isTextTargetObject(target)) {
            flushTextEditSave('text-edit-exit');
        }
    };

    canvas.value.on('text:selection:changed', syncTextSelectionSnapshot);
    canvas.value.on('text:editing:entered', syncTextSelectionSnapshot);
    canvas.value.on('text:editing:exited', handleTextEditingExited);
    canvas.value.on('text:changed', handleTextChanged);
    
    // 'selection:created', 'selection:updated', 'selection:cleared'
    canvas.value.on('selection:created', () => {
        if (normalizeActiveSelectionForProductCards()) {
            refreshShiftSelectionBaseline();
            updateSelection();
            return;
        }
        refreshShiftSelectionBaseline();
        updateSelection();
    });
    canvas.value.on('selection:updated', () => {
        if (normalizeActiveSelectionForProductCards()) {
            refreshShiftSelectionBaseline();
            updateSelection();
            return;
        }
        refreshShiftSelectionBaseline();
        updateSelection();
    });
    canvas.value.on('selection:cleared', (e: any) => {
        shiftSelectionBaselineMembers = [];
        updateSelection();
        // Exit Deep Select Mode on clear
        resetDeepSelection();
    });

    // === DEEP SELECT (Figma-style) ===
    // Product cards always have subTargetCheck=true (single-click deep select).
    // resetDeepSelection is now a no-op for product cards.
    const resetDeepSelection = () => {
        // No-op: product cards stay interactive at all times.
        // Only non-product groups would be reset here if needed.
    }

    // 2. Enable deep select on Double Click
    canvas.value.on('mouse:dblclick', (opt: any) => {
        if (showProductReviewModal.value) return;

        const c: any = canvas.value as any;
        const evt = opt.e || opt.originalEvent;
        let rawTarget = opt.target;

        if (import.meta.dev) {
            console.log('[DeepSelect] dblclick', {
                hasTarget: !!rawTarget,
                rawType: rawTarget?.type,
                rawName: rawTarget?.name,
                rawLayerName: rawTarget?.layerName,
                rawId: rawTarget?._customId,
                hasEvt: !!evt
            });
        }

        const isProductCardGroup = (o: any) => {
            return !!(o && o.type === 'group' && (o.isSmartObject || o.isProductCard || String(o.name || '').startsWith('product-card') || isLikelyProductCard(o)) && String(o.name || '') !== 'priceGroup');
        };

        const getCandidatePointsFromEvent = (): any[] => {
            if (!evt || !canvas.value) return [];
            const pts: any[] = [];
            try {
                if (typeof c.getScenePoint === 'function') {
                    const p0 = c.getScenePoint(evt);
                    if (p0 && typeof p0.x === 'number' && typeof p0.y === 'number') pts.push(p0);
                }
            } catch (e) {
                // ignore
            }
            try {
                if (typeof canvas.value.getPointer === 'function') {
                    const p1 = canvas.value.getPointer(evt);
                    if (p1 && typeof p1.x === 'number' && typeof p1.y === 'number') pts.push(p1);
                    const vpt = canvas.value.viewportTransform;
                    if (p1 && Array.isArray(vpt) && vpt.length >= 6 && (fabric as any)?.util?.invertTransform) {
                        const inv = (fabric as any).util.invertTransform(vpt);
                        const p2 = (fabric as any).util.transformPoint(p1, inv);
                        if (p2 && typeof p2.x === 'number' && typeof p2.y === 'number') pts.push(p2);
                    }
                }
            } catch (e) {
                // ignore
            }
            return pts;
        };

        const findTopCardAtPointer = (): any | null => {
            if (!evt || !canvas.value) return null;
            const pts = getCandidatePointsFromEvent();
            if (!pts.length) return null;

            const objs = canvas.value.getObjects().slice().reverse();
            for (const o of objs) {
                if (!isProductCardGroup(o)) continue;
                try {
                    for (const p of pts) {
                        if (typeof o.containsPoint === 'function' && o.containsPoint(p, undefined, true)) return o;
                    }
                } catch (e) {
                    // ignore
                }
                try {
                    const br = o.getBoundingRect?.(true) ?? null;
                    if (br) {
                        for (const p of pts) {
                            if (p.x >= br.left && p.x <= (br.left + br.width) && p.y >= br.top && p.y <= (br.top + br.height)) return o;
                        }
                    }
                } catch (e) {
                    // ignore
                }
            }
            return null;
        };

        // Fabric nem sempre fornece opt.target no dblclick após loadFromJSON.
        // Tenta resolver via findTarget/hit-test manual.
        if (!rawTarget && evt && typeof c.findTarget === 'function') {
            try { rawTarget = c.findTarget(evt); } catch (e) { /* ignore */ }
        }
        if (!rawTarget) {
            rawTarget = findTopCardAtPointer();
        }
        if (!rawTarget) {
            if (import.meta.dev) console.warn('[DeepSelect] dblclick sem target e sem card no ponteiro');
            return;
        }

        // If user double-clicks an inner element of a product card, use its parent group as the target.
        // This makes deep-select work even when a legacy card was loaded with subTargetCheck=true.
        // Se o dblclick caiu na zone/overlay, tenta forçar o card que está embaixo do ponteiro.
        let target = (rawTarget as any)?.group && isProductCardGroup((rawTarget as any).group)
            ? (rawTarget as any).group
            : rawTarget;
        if (!isProductCardGroup(target)) {
            const cardUnderPointer = findTopCardAtPointer();
            if (cardUnderPointer) target = cardUnderPointer;
        }

        if (import.meta.dev) {
            console.log('[DeepSelect] alvo resolvido', {
                type: target?.type,
                name: target?.name,
                id: target?._customId,
                isCard: isProductCardGroup(target),
                parentZoneId: (target as any)?.parentZoneId
            });
        }

        if (tryOpenProductReviewFromDblClickTarget(target)) {
            return;
        }
        
		        // Nested label editing: double click the priceGroup to edit its inner parts.
		        if (target.type === 'group' && target.name === 'priceGroup') {
	             target.set({ subTargetCheck: true, interactive: true });
	             if (typeof target.getObjects === 'function') {
	                 target.getObjects().forEach((child: any) => {
	                     const isBgImage = child?.name === 'price_bg_image' || child?.name === 'splash_image';
	                     child.set({
	                         selectable: !isBgImage,
	                         evented: !isBgImage,
	                         hasControls: !isBgImage,
	                         hasBorders: !isBgImage,
	                         lockMovementX: false,
	                         lockMovementY: false,
	                         lockScalingX: false,
	                         lockScalingY: false,
	                         lockRotation: false
	                     });
	                     child.setCoords?.();
	                 });
	             }
	             target.setCoords?.();
	             canvas.value.requestRenderAll();
	             return;
	        }

            // Product cards already have subTargetCheck=true for single-click deep select.
            // Double-click on card/zone now prioritizes opening Product Review import/edit modal.
    });

    // 3. Product cards always stay interactive (single-click deep select).
    // No need to reset other cards when selecting a new object.
    
    // Initial fetch
    updateObjects();
}

// Properties Updates
const updatePageSettings = (prop: string, value: any) => {
    if (prop === 'backgroundColor') {
        pageSettings.value.backgroundColor = value;
        if (canvas.value) {
            // Convert rgba to hex if needed for canvas background
            let bgColor = value;
            if (value.startsWith('rgba')) {
                // Extract RGB values (ignore alpha for canvas background)
                const rgba = value.match(/rgba?\(([^)]+)\)/);
                if (rgba) {
                    const parts = rgba[1].split(',').map((s: string) => s.trim());
                    const r = parseInt(parts[0]);
                    const g = parseInt(parts[1]);
                    const b = parseInt(parts[2]);
                    bgColor = `rgb(${r}, ${g}, ${b})`;
                }
            }
            canvas.value.backgroundColor = bgColor;
            canvas.value.requestRenderAll();
            saveCurrentState();
        }
        // Also update activePage background
        if (activePage.value) {
            (activePage.value as any).backgroundColor = value;
            const currentCanvasData = project.pages?.[project.activePageIndex]?.canvasData;
            if (currentCanvasData && typeof currentCanvasData === 'object') {
                updatePageData(project.activePageIndex, { ...currentCanvasData, backgroundColor: value });
            }
        }
    }
}

const getViewportBounds = () => {
    if (!canvas.value || !fabric?.util) return null;
    const vpt = canvas.value.viewportTransform;
    if (!vpt) return null;
    const inv = fabric.util.invertTransform(vpt);
    const tl = fabric.util.transformPoint({ x: 0, y: 0 }, inv);
    const br = fabric.util.transformPoint({ x: canvas.value.getWidth(), y: canvas.value.getHeight() }, inv);
    const left = Math.min(tl.x, br.x);
    const top = Math.min(tl.y, br.y);
    const right = Math.max(tl.x, br.x);
    const bottom = Math.max(tl.y, br.y);
    return {
        left,
        top,
        right,
        bottom,
        width: right - left,
        height: bottom - top,
        centerX: left + ((right - left) / 2),
        centerY: top + ((bottom - top) / 2)
    };
};

const alignSelectionHorizontally = (mode: 'left' | 'center' | 'right') => {
    if (!canvas.value || !fabric?.Point) return;
    const active = canvas.value.getActiveObject();
    if (!active) return;

    const alignOne = (obj: any, ref: { left: number; right: number; centerX: number }) => {
        if (obj?.lockMovementX || obj?.lockMovementY) return;
        const br = obj.getBoundingRect(true);
        const currentCenter = obj.getCenterPoint ? obj.getCenterPoint() : { x: obj.left, y: obj.top };
        let nextCenterX = currentCenter.x;
        if (mode === 'left') nextCenterX = ref.left + (br.width / 2);
        if (mode === 'center') nextCenterX = ref.centerX;
        if (mode === 'right') nextCenterX = ref.right - (br.width / 2);

        obj.setPositionByOrigin(new fabric.Point(nextCenterX, currentCenter.y), 'center', 'center');
        obj.setCoords();
    };

    if (active.type === 'activeSelection' && typeof active.getObjects === 'function') {
        const sel = active.getBoundingRect(true);
        const ref = { left: sel.left, right: sel.left + sel.width, centerX: sel.left + (sel.width / 2) };
        active.getObjects().forEach((obj: any) => alignOne(obj, ref));
        safeAddWithUpdate(active);
        active.setCoords();
    } else {
        // Single object: align to parent frame if any, else align to page (0..W/H).
        const parentFrameId = String((active as any)?.parentFrameId || '').trim();
        const frame = parentFrameId ? getFrameById(parentFrameId) : null;
        const fb = frame ? getFrameBounds(frame) : null;
        const pageW = activePage.value?.width ?? 1080;
        const ref = fb
            ? { left: fb.left, right: fb.left + fb.width, centerX: fb.left + (fb.width / 2) }
            : { left: 0, right: pageW, centerX: pageW / 2 };
        alignOne(active, ref);
    }

    canvas.value.requestRenderAll();
    saveCurrentState();
    triggerRef(selectedObjectRef);
};

const alignSelectionVertically = (mode: 'top' | 'middle' | 'bottom') => {
    if (!canvas.value || !fabric?.Point) return;
    const active = canvas.value.getActiveObject();
    if (!active) return;

    const alignOne = (obj: any, ref: { top: number; bottom: number; centerY: number }) => {
        if (obj?.lockMovementX || obj?.lockMovementY) return;
        const br = obj.getBoundingRect(true);
        const currentCenter = obj.getCenterPoint ? obj.getCenterPoint() : { x: obj.left, y: obj.top };
        let nextCenterY = currentCenter.y;
        if (mode === 'top') nextCenterY = ref.top + (br.height / 2);
        if (mode === 'middle') nextCenterY = ref.centerY;
        if (mode === 'bottom') nextCenterY = ref.bottom - (br.height / 2);

        obj.setPositionByOrigin(new fabric.Point(currentCenter.x, nextCenterY), 'center', 'center');
        obj.setCoords();
    };

    if (active.type === 'activeSelection' && typeof active.getObjects === 'function') {
        const sel = active.getBoundingRect(true);
        const ref = { top: sel.top, bottom: sel.top + sel.height, centerY: sel.top + (sel.height / 2) };
        active.getObjects().forEach((obj: any) => alignOne(obj, ref));
        safeAddWithUpdate(active);
        active.setCoords();
    } else {
        const parentFrameId = String((active as any)?.parentFrameId || '').trim();
        const frame = parentFrameId ? getFrameById(parentFrameId) : null;
        const fb = frame ? getFrameBounds(frame) : null;
        const pageH = activePage.value?.height ?? 1920;
        const ref = fb
            ? { top: fb.top, bottom: fb.top + fb.height, centerY: fb.top + (fb.height / 2) }
            : { top: 0, bottom: pageH, centerY: pageH / 2 };
        alignOne(active, ref);
    }

    canvas.value.requestRenderAll();
    saveCurrentState();
    triggerRef(selectedObjectRef);
};

const centerSelectionInContainer = (mode: 'h' | 'v' | 'both') => {
    if (!canvas.value || !fabric?.Point) return;
    const active = canvas.value.getActiveObject();
    if (!active) return;

    const getContainer = (obj: any) => {
        const parentFrameId = String((obj as any)?.parentFrameId || '').trim();
        const frame = parentFrameId ? getFrameById(parentFrameId) : null;
        const fb = frame ? getFrameBounds(frame) : null;
        const pageW = activePage.value?.width ?? 1080;
        const pageH = activePage.value?.height ?? 1920;
        return fb
            ? { left: fb.left, top: fb.top, right: fb.left + fb.width, bottom: fb.top + fb.height, centerX: fb.left + (fb.width / 2), centerY: fb.top + (fb.height / 2) }
            : { left: 0, top: 0, right: pageW, bottom: pageH, centerX: pageW / 2, centerY: pageH / 2 };
    };

    const applyTo = (obj: any, container: any) => {
        if (obj?.lockMovementX || obj?.lockMovementY) return;
        const center = obj.getCenterPoint ? obj.getCenterPoint() : { x: obj.left, y: obj.top };
        const nextX = mode === 'v' ? center.x : container.centerX;
        const nextY = mode === 'h' ? center.y : container.centerY;
        obj.setPositionByOrigin(new fabric.Point(nextX, nextY), 'center', 'center');
        obj.setCoords();
    };

    if (active.type === 'activeSelection' && typeof active.getObjects === 'function') {
        // Multi-selection: center relative to selection bounds.
        const sel = active.getBoundingRect(true);
        const container = { centerX: sel.left + (sel.width / 2), centerY: sel.top + (sel.height / 2) };
        active.getObjects().forEach((obj: any) => applyTo(obj, container));
        safeAddWithUpdate(active);
        active.setCoords();
    } else {
        const container = getContainer(active);
        applyTo(active, container);
    }

    canvas.value.requestRenderAll();
    saveCurrentState();
    triggerRef(selectedObjectRef);
};

const updateObjectProperty = (prop: string, value: any) => {
    // Special: Canvas Preset Change
    if (prop === 'canvas-preset') {
        resizePage(project.activePageIndex, value.w, value.h);
        if(canvas.value) {
            canvas.value.setDimensions({ width: value.w, height: value.h });
            setTimeout(() => { zoomToFit(); saveCurrentState(); }, 50);
        }
        return;
    }

    // --- HANDLE BRUSH SETTINGS ---
    if (isDrawing.value && selectedObjectRef.value?.type === 'brush-proxy') {
        if (!canvas.value.freeDrawingBrush) return;
        
        const brush = canvas.value.freeDrawingBrush as any;

        if (prop === 'stroke' || prop === 'fill') {
            brush.color = value;
            selectedObjectRef.value.stroke = value; 
            selectedObjectRef.value.fill = value;
        }
        else if (prop === 'strokeWidth') {
            const val = parseInt(value);
            brush.width = val;
            selectedObjectRef.value.strokeWidth = val;
        }
        else if (prop === 'strokeLineCap') {
            brush.strokeLineCap = value;
            selectedObjectRef.value.strokeLineCap = value;
        }
        else if (prop === 'strokeLineJoin') {
            brush.strokeLineJoin = value;
            selectedObjectRef.value.strokeLineJoin = value;
        }
        else if (prop === 'strokeDashArray') {
            brush.strokeDashArray = value;
            selectedObjectRef.value.strokeDashArray = value;
        }
        
        refreshSelectedRef();
        return;
    }

    if (!canvas.value) return; 
    let active = canvas.value.getActiveObject();
    
    if (active) {
        // If locked, ignore position/size/rotate changes from the inspector.
        // Lock should only block transformations, not styling/effects.
        if (active.type !== 'activeSelection') {
            if ((prop === 'left' || prop === 'top') && (active.lockMovementX || active.lockMovementY)) return;
            if ((prop === 'width' || prop === 'height' || prop === 'scaleX' || prop === 'scaleY') && (active.lockScalingX || active.lockScalingY)) return;
            if (prop === 'angle' && active.lockRotation) return;
        }

        // Keep text-style edits bound to the object shown in the inspector snapshot.
        // This avoids styling the card background when Fabric activeObject drifts to the parent group.
        if (TEXT_OBJECT_STYLE_PROPS.has(prop)) {
            const snapshot = selectedObjectRef.value as any;
            const snapshotId = String(snapshot?._customId || '').trim();
            const snapshotType = String(snapshot?.type || '').toLowerCase();
            const snapshotIsText = snapshotType === 'i-text' || snapshotType === 'textbox' || snapshotType === 'text';
            const activeId = String((active as any)?._customId || '').trim();

            if (snapshotIsText && snapshotId && activeId !== snapshotId) {
                const found = findObjectByCustomId(snapshotId)?.obj;
                if (found && isTextStyleObject(found)) {
                    active = found;
                }
            } else if (snapshotIsText && !snapshotId && String((active as any)?.type || '').toLowerCase() === 'group' && typeof (active as any)?.getObjects === 'function') {
                const snapName = String(snapshot?.name || '').trim();
                const snapText = String(snapshot?.text ?? '');
                const walkForText = (node: any): any => {
                    if (!node) return null;
                    if (isTextStyleObject(node)) {
                        const sameName = snapName && String(node?.name || '').trim() === snapName;
                        const sameText = snapText && String(node?.text ?? '') === snapText;
                        if (sameName || sameText) return node;
                    }
                    const t = String(node?.type || '').toLowerCase();
                    if ((t === 'group' || t === 'activeselection') && typeof node.getObjects === 'function') {
                        const children = node.getObjects() || [];
                        for (const child of children) {
                            const nested = walkForText(child);
                            if (nested) return nested;
                        }
                    }
                    return null;
                };
                const fallbackText = walkForText(active);
                if (fallbackText) active = fallbackText;
            } else if (!isTextStyleObject(active)) {
                const deepActive = (active as any)?._activeObject;
                if (deepActive && isTextStyleObject(deepActive)) {
                    active = deepActive;
                }
            }
        }

        // Rich text: apply style to selected text range when available.
        if (TEXT_SELECTION_STYLE_PROPS.has(prop) && active.type !== 'activeSelection' && isTextStyleObject(active)) {
            if (String(active.type || '').toLowerCase() === 'text') {
                active = convertStaticTextToIText({
                    canvas: canvas.value,
                    fabric,
                    obj: active,
                    canvasCustomProps: [...CANVAS_CUSTOM_PROPS],
                    safeAddWithUpdate,
                    syncObjectFrameClip,
                    refreshCanvasObjects: () => refreshCanvasObjects()
                });
            }
            if (applySelectionTextStyle({
                obj: active,
                prop,
                value,
                getTextSelectionRange,
                safeAddWithUpdate
            })) {
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }
        }

        // Resolve "style target" for groups/zones (Fabric groups don't have fill/stroke/radius).
        const resolveStyleTarget = (obj: any) => {
            if (!obj) return obj;
            if (isLikelyProductZone(obj)) return getZoneRect(obj) || obj;
            if (obj.type === 'group' && (obj.isSmartObject || obj.isProductCard) && typeof obj.getObjects === 'function') {
                return obj.getObjects().find((o: any) => o.name === 'offerBackground') || obj;
            }
            return obj;
        };
        const styleTarget = resolveStyleTarget(active);
        const applyToActiveOrSelection = (fn: (o: any) => void) => {
            if (active.type === 'activeSelection' && typeof active.getObjects === 'function') {
                active.getObjects().forEach((o: any) => fn(resolveStyleTarget(o)));
                safeAddWithUpdate(active);
                active.setCoords?.();
                return;
            }
            fn(styleTarget);
        };

        // --- Lock (Cadeado) ---
        // Blocks movement/scale/rotate but keeps the object selectable so the user can unlock.
        if (prop === 'lockMovement') {
            const locked = !!value;
            const applyLock = (o: any) => {
                if (!o || typeof o.set !== 'function') return;
                o.set({
                    lockMovementX: locked,
                    lockMovementY: locked,
                    lockScalingX: locked,
                    lockScalingY: locked,
                    lockRotation: locked
                });
                o.setCoords?.();
            };

            if (active.type === 'activeSelection' && typeof (active as any).getObjects === 'function') {
                (active as any).getObjects().forEach((o: any) => applyLock(o));
                safeAddWithUpdate(active);
                active.setCoords?.();
            } else {
                applyLock(active);
            }

            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef();
            return;
        }

        // --- Align (Inspector) ---
        if (prop === 'alignment') {
            if (value === 'left' || value === 'center' || value === 'right') {
                alignSelectionHorizontally(value);
            }
            return;
        }

        // --- Shape controls (Fill/Stroke/Corner radii) ---
        if (prop === 'fillEnabled') {
            applyToActiveOrSelection((o) => toggleFill(o, !!value));
            (active as any).__fillEnabled = !!value;
            if (active.isFrame) getOrCreateFrameClipRect(active);
            if (active.isFrame) syncFrameClips(active);
            safeAddWithUpdate(active);
            active.setCoords?.();
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef({ __fillEnabled: !!value });
            return;
        }
        if (prop === 'strokeEnabled') {
            applyToActiveOrSelection((o) => toggleStroke(o, !!value));
            (active as any).__strokeEnabled = !!value;
            if (active.isFrame) getOrCreateFrameClipRect(active);
            if (active.isFrame) syncFrameClips(active);
            safeAddWithUpdate(active);
            active.setCoords?.();
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef({ __strokeEnabled: !!value });
            return;
        }

        // --- Sticker Outline (alpha-based contour) ---
	        if (prop === 'stickerOutlineEnabled') {
	            const isImage = String(active.type || '').toLowerCase() === 'image';
	            if (!isImage) return;
	            const el = active._element || active.getElement?.();
	            (active as any).__stickerOutlineEnabled = !!value;
	            // Set defaults if first time enabling
	            if (value) {
	                if ((active as any).__stickerOutlineWidth == null) (active as any).__stickerOutlineWidth = 4;
	                if ((active as any).__stickerOutlineColor == null) (active as any).__stickerOutlineColor = '#FFFFFF';
	                if ((active as any).__stickerOutlineOpacity == null) (active as any).__stickerOutlineOpacity = 1;
	                if (!(active as any).__stickerOutlineMode) (active as any).__stickerOutlineMode = 'outside';
	            }
            // Detect transparency
            if (value && el) {
                const hasTrans = imageHasTransparency(el);
                (active as any).__stickerNoTransparency = !hasTrans;
            }
            applyStickerOutlinePatch(active);
            active.setCoords?.();
            active.dirty = true;
            canvas.value.renderAll();
            // Second render to guarantee visibility after patch
            setTimeout(() => { canvas.value?.renderAll?.(); }, 60);
            debouncedSaveCurrentState();
	            refreshSelectedRef({
	                __stickerOutlineEnabled: !!(active as any).__stickerOutlineEnabled,
	                __stickerOutlineMode: (active as any).__stickerOutlineMode || 'outside',
	                __stickerOutlineWidth: (active as any).__stickerOutlineWidth ?? 4,
	                __stickerOutlineColor: (active as any).__stickerOutlineColor ?? '#FFFFFF',
	                __stickerOutlineOpacity: (active as any).__stickerOutlineOpacity ?? 1,
	                __stickerNoTransparency: !!(active as any).__stickerNoTransparency
	            });
	            return;
	        }
	        if (prop === 'stickerOutlineMode') {
	            const isImage = String(active.type || '').toLowerCase() === 'image';
	            if (!isImage) return;
	            const next: 'outside' | 'inside' = value === 'inside' ? 'inside' : 'outside';
	            (active as any).__stickerOutlineMode = next;
	            invalidateStickerOutlineCache(active);
	            applyStickerOutlinePatch(active);
	            active.setCoords?.();
	            active.dirty = true;
	            canvas.value.renderAll();
	            setTimeout(() => { canvas.value?.renderAll?.(); }, 60);
	            debouncedSaveCurrentState();
	            refreshSelectedRef({
	                __stickerOutlineEnabled: !!(active as any).__stickerOutlineEnabled,
	                __stickerOutlineMode: (active as any).__stickerOutlineMode || 'outside',
	                __stickerOutlineWidth: (active as any).__stickerOutlineWidth,
	                __stickerOutlineColor: (active as any).__stickerOutlineColor,
	                __stickerOutlineOpacity: (active as any).__stickerOutlineOpacity,
	                __stickerNoTransparency: !!(active as any).__stickerNoTransparency
	            });
	            return;
	        }
	        if (prop === 'stickerOutlineWidth' || prop === 'stickerOutlineColor' || prop === 'stickerOutlineOpacity') {
	            const propMap = {
	                stickerOutlineWidth: '__stickerOutlineWidth',
	                stickerOutlineColor: '__stickerOutlineColor',
                stickerOutlineOpacity: '__stickerOutlineOpacity'
            } as const;
            const key: string = propMap[prop as keyof typeof propMap];
            (active as any)[key] = value;
            invalidateStickerOutlineCache(active);
            applyStickerOutlinePatch(active);
            active.setCoords?.();
            active.dirty = true;
            canvas.value.renderAll();
            setTimeout(() => { canvas.value?.renderAll?.(); }, 60);
            debouncedSaveCurrentState();
	            refreshSelectedRef({
	                __stickerOutlineEnabled: !!(active as any).__stickerOutlineEnabled,
	                __stickerOutlineMode: (active as any).__stickerOutlineMode || 'outside',
	                __stickerOutlineWidth: (active as any).__stickerOutlineWidth,
	                __stickerOutlineColor: (active as any).__stickerOutlineColor,
	                __stickerOutlineOpacity: (active as any).__stickerOutlineOpacity,
	                __stickerNoTransparency: !!(active as any).__stickerNoTransparency
	            });
	            return;
	        }

        if (prop === 'cornerRadius') {
            const r = Math.max(0, Number(value || 0));
            applyToActiveOrSelection((o) => {
                if (o && (o as any).cornerRadii) delete (o as any).cornerRadii;
                // Remove any custom render patch to ensure Fabric.js native rendering is used
                if ((o as any).__origRender) {
                    o._render = (o as any).__origRender;
                    delete (o as any).__origRender;
                }
                // Set rx, ry with additional properties to ensure proper rendering
                o?.set?.({
                    rx: r,
                    ry: r,
                    strokeUniform: true,  // Ensures stroke scales properly
                    objectCaching: false, // Disable caching for rounded corners
                    dirty: true
                });
                // Force clear any clipPath that might interfere with native rx/ry rendering
                if (o && !o.isFrame) {
                    o.set('clipPath', undefined);
                }
                applyRectCornerRadiiPatch(o);
            });
            if (active.isFrame) {
                getOrCreateFrameClipRect(active);
                syncFrameClips(active);
            }
            safeAddWithUpdate(active);
            active.setCoords?.();
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef();
            return;
        }
        if (prop === 'cornerRadii') {
            applyToActiveOrSelection((o) => {
                if (!o) return;
                if (!value) {
                    if ((o as any).cornerRadii) delete (o as any).cornerRadii;
                    applyRectCornerRadiiPatch(o);
                    return;
                }
                const w = Number(o?.width || 0);
                const h = Number(o?.height || 0);
                (o as any).cornerRadii = clampCornerRadii(value, w || 1, h || 1);
                applyRectCornerRadiiPatch(o);
            });
            if (active.isFrame) {
                getOrCreateFrameClipRect(active);
                syncFrameClips(active);
            }
            safeAddWithUpdate(active);
            active.setCoords?.();
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef();
            return;
        }

        // Frames (Figma-like): moving the frame moves its descendants; clip toggle updates children.
        if (active.isFrame) {
            if (prop === 'left' || prop === 'top') {
                const prevLeft = active.left;
                const prevTop = active.top;
                active.set(prop, value);
                active.setCoords();

                const dx = active.left - prevLeft;
                const dy = active.top - prevTop;
                moveFrameDescendants(active, dx, dy);
                getOrCreateFrameClipRect(active);
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }

            if (prop === 'width' || prop === 'height') {
                if (prop === 'width') active.set({ width: Number(value), scaleX: 1 });
                if (prop === 'height') active.set({ height: Number(value), scaleY: 1 });
                active.setCoords();
                getOrCreateFrameClipRect(active);
                syncFrameClips(active);
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }

            if (prop === 'clipContent') {
                const newVal = !!value;
                active.set('clipContent', newVal);
                active.clipContent = newVal;
                refreshSelectedRef({ clipContent: newVal });

                syncFrameClips(active);
                canvas.value.requestRenderAll();

                setTimeout(() => {
                    if (canvas.value) canvas.value.requestRenderAll();
                }, 10);

                setTimeout(() => {
                    try { saveCurrentState(); } catch {} 
                }, 0);
                return;
            }
        }

        if (isLikelyProductZone(active)) {
            ensureZoneSanity(active);
            if (prop === 'left' || prop === 'top') {
                const prevLeft = active.left;
                const prevTop = active.top;
                active.set(prop, value);
                active.setCoords();
                
                const dx = active.left - prevLeft;
                const dy = active.top - prevTop;
                moveZoneChildren(active, dx, dy);
                maybeReparentToFrameOnDrop(active);
                syncZoneCardFrameBindings(active);
                
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }
            
            if (prop === 'width' || prop === 'height') {
                const zoneRect = getZoneRect(active);
                if (zoneRect) {
                    const nextWidth = prop === 'width' ? value : zoneRect.width;
                    const nextHeight = prop === 'height' ? value : zoneRect.height;
                    
                    zoneRect.set({
                        width: nextWidth,
                        height: nextHeight,
                        scaleX: 1,
                        scaleY: 1
                    });
                    
                    active.set({
                        scaleX: 1,
                        scaleY: 1
                    });
                    
                    safeAddWithUpdate(active);
                    active.setCoords();
                    active._zoneWidth = nextWidth;
                    active._zoneHeight = nextHeight;
                    
                    // Cache children before layout to avoid losing them
                    const cachedChildren = getZoneChildren(active);
                    recalculateZoneLayout(active, cachedChildren, { save: false });
                    canvas.value.requestRenderAll();
                    debouncedSaveCurrentState();
                    refreshSelectedRef();
                    return;
                }
            }
            
            if (prop === 'scaleX' || prop === 'scaleY') {
                // Cache children before layout
                const cachedChildren = getZoneChildren(active);
                active.set(prop, value);
                normalizeZoneScale(active);
                recalculateZoneLayout(active, cachedChildren, { save: false });
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }
        }

        // Map common styling props to the correct child object when the selection is a group.
        // Fabric groups don't support fill/stroke/radius directly.
        if (isLikelyProductZone(active)) {
            const zoneRect = getZoneRect(active);
            if (zoneRect && ['fill', 'stroke', 'strokeWidth', 'strokeDashArray', 'rx', 'ry'].includes(prop)) {
                if (prop === 'fill') zoneRect.set('fill', (value === null || value === undefined || value === '') ? 'transparent' : value);
                if (prop === 'stroke') zoneRect.set('stroke', value);
                if (prop === 'strokeWidth') zoneRect.set('strokeWidth', Number(value));
                if (prop === 'strokeDashArray') zoneRect.set('strokeDashArray', value);
                if (prop === 'rx') zoneRect.set({ rx: Number(value), ry: Number(value) });
                if (prop === 'ry') zoneRect.set('ry', Number(value));

                safeAddWithUpdate(active);
                active.setCoords();
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }
        }

        if (active.type === 'group' && (active.isSmartObject || active.isProductCard)) {
            const bg = typeof active.getObjects === 'function'
                ? active.getObjects().find((o: any) => o.name === 'offerBackground')
                : null;
            if (bg && ['fill', 'stroke', 'strokeWidth', 'strokeDashArray', 'rx', 'ry'].includes(prop)) {
                if (prop === 'fill') bg.set('fill', (value === null || value === undefined || value === '') ? 'transparent' : value);
                if (prop === 'stroke') bg.set('stroke', value);
                if (prop === 'strokeWidth') bg.set('strokeWidth', Number(value));
                if (prop === 'strokeDashArray') bg.set('strokeDashArray', value);
                if (prop === 'rx') bg.set({ rx: Number(value), ry: Number(value) });
                if (prop === 'ry') bg.set('ry', Number(value));

                safeAddWithUpdate(active);
                active.setCoords();
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
                return;
            }
        }
        
        // --- Shadow Logic ---
        if (prop === 'shadow') {
            if (value === null) {
                active.set('shadow', null);
            } else {
                // Fabric Shadow Object
                active.set('shadow', new fabric.Shadow({
                    color: value.color || 'rgba(0,0,0,0.5)',
                    blur: value.blur || 10,
                    offsetX: value.x || 0,
                    offsetY: value.y || 4
                }));
            }
        }
        // Shadow sub-properties
        else if (prop.startsWith('shadow-')) {
            const currentShadow = active.shadow || new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 10, offsetX: 0, offsetY: 0 });
            if (prop === 'shadow-x') currentShadow.offsetX = value;
            if (prop === 'shadow-y') currentShadow.offsetY = value;
            if (prop === 'shadow-blur') currentShadow.blur = value;
            if (prop === 'shadow-color') currentShadow.color = String(value || 'rgba(0,0,0,0.5)');
            if (prop === 'shadow-opacity') {
                const clamp01 = (n: any) => Math.min(1, Math.max(0, Number(n ?? 0)));
                const a = clamp01(value);
                const c = String(currentShadow.color || 'rgba(0,0,0,0.5)');
                const m = /rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+)\s*)?\)/i.exec(c);
                if (m) {
                    const r = Math.round(Number(m[1] || 0));
                    const g = Math.round(Number(m[2] || 0));
                    const b = Math.round(Number(m[3] || 0));
                    currentShadow.color = `rgba(${r},${g},${b},${a})`;
                } else if (c.startsWith('#') && (c.length === 7 || c.length === 4)) {
                    const hex = c.length === 4
                        ? `#${c[1]}${c[1]}${c[2]}${c[2]}${c[3]}${c[3]}`
                        : c;
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    currentShadow.color = `rgba(${r},${g},${b},${a})`;
                } else {
                    currentShadow.color = `rgba(0,0,0,${a})`;
                }
            }
            active.set('shadow', currentShadow);
        }
        // Reset all supported effects on the selected object.
        else if (prop === 'effects-reset') {
            active.set('shadow', null);
            if (active.type === 'image' && typeof active.applyFilters === 'function') {
                active.filters = [];
                active.applyFilters();
            }
            active.dirty = true;
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef();
            return;
        }
        // --- Blur Filter ---
        else if (prop === 'blur') {
            // Only images support filters in Fabric; avoid crashing when blur is used on groups/shapes.
            active.blur = value; // Store value for UI
            if (active.type === 'image' && typeof active.applyFilters === 'function') {
                active.filters = Array.isArray(active.filters) ? active.filters : [];
                if (value === null) {
                    active.filters = active.filters.filter((f: any) => f.type !== 'Blur');
                } else {
                    active.filters = active.filters.filter((f: any) => f.type !== 'Blur');
                    active.filters.push(new fabric.filters.Blur({
                        blur: Number(value) / 20 // Normalize radius
                    }));
                }
                active.applyFilters();
            }
        }
        // --- Image Filters (Brightness/Contrast/Saturation) ---
        else if (prop.startsWith('filter-')) {
            const type = prop.replace('filter-', '');
            let filterName = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize

            if (active.type === 'image' && typeof active.applyFilters === 'function') {
                active.filters = Array.isArray(active.filters) ? active.filters : [];
                // Remove existing filter of same type
                // Special cases:
                // - `hue` is HueRotation (rotation: -1..1)
                // - `blur` is Blur (blur: 0..1) but UI uses px-like 0..20
                // - `grayscale|sepia|invert` are boolean toggles
                let shouldAdd = value !== 0;
                let options: any = {};
                if (type === 'hue') {
                    filterName = 'HueRotation';
                    options = { rotation: Number(value) || 0 };
                    shouldAdd = Number(value) !== 0;
                } else if (type === 'blur') {
                    filterName = 'Blur';
                    const px = Math.max(0, Number(value) || 0);
                    const normalized = Math.min(1, px / 20);
                    options = { blur: normalized };
                    shouldAdd = normalized !== 0;
                } else if (type === 'grayscale' || type === 'sepia' || type === 'invert') {
                    shouldAdd = !!value;
                    options = {};
                } else {
                    options[type] = value;
                    shouldAdd = value !== 0;
                }

                active.filters = active.filters.filter((f: any) => f?.type !== filterName);

                // Add new filter if value is not 0 (or neutral)
                if (shouldAdd) {
                    // Fabric.js 7: filters are in fabric.filters, not fabric.Image.filters
                    active.filters.push(new (fabric.filters as any)[filterName](options));
                }

                active.applyFilters();
                active.dirty = true;
            }
        }
        else if (prop === 'filters-reset') {
            if (active.type === 'image' && typeof active.applyFilters === 'function') {
                active.filters = [];
                active.applyFilters();
                active.dirty = true;
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
            }
            return;
        }
        // --- Gradient Logic (Simple Linear) ---
        else if (prop === 'fill-gradient') {
             // Basic Gradient Mock
             const grad = new fabric.Gradient({
                type: 'linear',
                coords: { x1: 0, y1: 0, x2: active.width, y2: active.height },
                colorStops: [
                    { offset: 0, color: 'red' },
                    { offset: 1, color: '#8b5cf6' }
                ]
             });
             active.set('fill', grad);
        }
        // --- Text Advanced ---
        else if (prop === 'lineHeight' || prop === 'charSpacing') {
             active.set(prop, value);
             // Fabric requires initDimensions for text layout changes sometimes
             if(active.initDimensions) active.initDimensions();
        }
        // --- Stroke Properties (for regular objects, not just brush) ---
        else if (prop === 'strokeLineCap' || prop === 'strokeLineJoin') {
            applyToActiveOrSelection((o) => {
                o?.set?.(prop, value);
            });
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef();
            return;
        }
        else if (prop === 'strokePosition' || prop === 'strokeMiterLimit') {
            // Vector path specific properties
            if (active.isVectorPath) {
                active.set(prop, value);
                canvas.value.requestRenderAll();
                debouncedSaveCurrentState();
                refreshSelectedRef();
            }
            return;
        }
        // --- Opacity & Blend Mode ---
        else if (prop === 'opacity' || prop === 'globalCompositeOperation') {
            applyToActiveOrSelection((o) => {
                o?.set?.(prop, value);
            });
            canvas.value.requestRenderAll();
            debouncedSaveCurrentState();
            refreshSelectedRef();
            return;
        }
        // --- Standard Props ---
        else {
             // If switching back to uniform rx/ry, clear per-corner state.
             if ((prop === 'rx' || prop === 'ry') && styleTarget && (styleTarget as any).cornerRadii) {
                 delete (styleTarget as any).cornerRadii;
                 applyRectCornerRadiiPatch(styleTarget);
                 if (active.isFrame) {
                    getOrCreateFrameClipRect(active);
                    syncFrameClips(active);
                 }
             }
             active.set(prop, value);
             if (isTextStyleObject(active) && typeof active.initDimensions === 'function') {
                active.initDimensions();
                active.dirty = true;
             }
             if (
                prop === 'width' &&
                String(active.type || '').toLowerCase() === 'textbox' &&
                active.group &&
                (active.group.isSmartObject || active.group.isProductCard || isLikelyProductCard(active.group))
             ) {
                const cardGroup = active.group;
                const cardW = Number((cardGroup as any)?._cardWidth ?? cardGroup?.width ?? cardGroup?.getScaledWidth?.() ?? 0);
                const cardH = Number((cardGroup as any)?._cardHeight ?? cardGroup?.height ?? cardGroup?.getScaledHeight?.() ?? 0);
                const maxCardW = Number.isFinite(cardW) && cardW > 0 ? Math.max(20, cardW) : Number.POSITIVE_INFINITY;
                const safeW = Math.min(maxCardW, Math.max(20, Number(active.width || value) || 0));
                active.set({ width: safeW, scaleX: 1 });
                (active as any).__manualTransform = true;
                (active as any).__manualTextWidth = safeW;
                if (Number.isFinite(cardW) && cardW > 0) {
                    (active as any).__manualTextWidthRatio = Math.min(1, Math.max(0.1, safeW / cardW));
                    (active as any).__manualTransformCardW = cardW;
                }
                if (Number.isFinite(cardH) && cardH > 0) {
                    (active as any).__manualTransformCardH = cardH;
                }
             }
             if (
                String(active.type || '').toLowerCase() === 'image' &&
                active.group &&
                (active.group.isSmartObject || active.group.isProductCard || isLikelyProductCard(active.group)) &&
                (prop === 'scaleX' || prop === 'scaleY' || prop === 'flipX' || prop === 'flipY')
             ) {
                active.set({
                    scaleX: Math.abs(Number(active.scaleX ?? 1)) || 1,
                    scaleY: Math.abs(Number(active.scaleY ?? 1)) || 1,
                    flipX: false,
                    flipY: false,
                    lockScalingFlip: true,
                    lockSkewingX: true,
                    lockSkewingY: true
                });
                applyContainmentConstraints(active);
             }
        }
        
        // If it's a group, we might want to dirty it
        if (active.group) safeAddWithUpdate(active.group);
        
        // REALTIME: Render immediately for instant visual feedback
        active.setCoords?.();
        canvas.value.requestRenderAll();
        
        // PERSIST: Debounced save to avoid lag during rapid input
        debouncedSaveCurrentState();
        
        // Force update ref for UI sync — create fresh snapshot so Vue detects prop change
        selectedObjectRef.value = snapshotForPropertiesPanel(active, { [prop]: value });
    }
}

const applySmartStyle = (group: any, key: string, value: any) => {
    // Traverse group to find specific sub-elements
    const objects = group.getObjects();
    
    // 1. Price Components
    if (key.startsWith('price')) {
         const priceGroup = objects.find((o: any) => o.name === 'priceGroup');
         if (priceGroup) {
             const priceParts = priceGroup.getObjects();
             priceParts.forEach((p: any) => {
                 if (key === 'priceFill') p.set('fill', value);
                 if (key === 'priceFont') p.set('fontFamily', value);
             });
         }
    }
    
    // 2. Splash/Background
    if (key === 'splashFill') {
        const bg = objects.find((o: any) => o.name === 'offerBackground');
        if (bg && !(value === null || value === undefined || value === '')) bg.set('fill', value);
    }
    
    safeAddWithUpdate(group);
}

const updateSmartGroup = (keyOrUpdates: any, value?: any) => {
    if (!canvas.value) return; 

    // Handle Global Sync (Object payload)
    if (typeof keyOrUpdates === 'object' && keyOrUpdates.targetType) {
        const { targetType, property, value } = keyOrUpdates;
        
        // Find all groups in the same zone (if applicable, or all smart groups)
        // For now, let's target ALL smartGroups on canvas for maximum effect as requested ("Alterar um, alterar todos")
        const allSmartGroups = canvas.value.getObjects().filter((o: any) => o.subTargetCheck && o.data?.isProductCard);
        
        allSmartGroups.forEach((group: any) => {
             const objects = group.getObjects();
             
             // Recursively find matching child
             const findAndUpdate = (objs: any[]) => {
                 objs.forEach(obj => {
                     if (obj.data?.smartType === targetType) {
                         obj.set(property, value);
                         // Special case for font, might need re-positioning? 
                         // Fabric usually handles it, but group might need recalc
                     }
                     
                     if (obj.type === 'group') {
                         findAndUpdate(obj.getObjects());
                     }
                 })
             }
             
             findAndUpdate(objects);
             safeAddWithUpdate(group); 
        });
        
        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }

    // Existing Logic (Price Mode etc)
    let updates: any = {};
    if (typeof keyOrUpdates === 'string') {
        updates[keyOrUpdates] = value;
    } else {
        updates = keyOrUpdates;
    }

    // Filter Smart Objects - Prefer ones in the currently selected Grid if any
    const active = canvas.value.getActiveObject();
    let targetGridId: string | null = null;
    
    if (active) {
        if ((active as any).smartGridId) targetGridId = (active as any).smartGridId;
        else if (active.group && (active.group as any).smartGridId) targetGridId = (active.group as any).smartGridId;
    }

    const groups = canvas.value.getObjects().filter((o: any) => (o as any).isSmartObject && (!targetGridId || (o as any).smartGridId === targetGridId));

    groups.forEach((group: any) => {
        // Find Helper
        const findChild = (parent: any, name: string): any => {
            if (!parent.getObjects) return null;
            const children = parent.getObjects();
            for (const child of children) {
                if (child.name === name) return child;
                if (child.type === 'group') {
                    const found = findChild(child, name);
                    if (found) return found;
                }
            }
            return null;
        }

        // --- Style Updates ---
        if (updates.priceColor) {
             const intTxt = findChild(group, 'priceInteger');
             if (intTxt) intTxt.set('fill', updates.priceColor);
             const decTxt = findChild(group, 'priceDecimal');
             if (decTxt) decTxt.set('fill', updates.priceColor);
             const symTxt = findChild(group, 'priceSymbol');
             if (symTxt) symTxt.set('fill', updates.priceColor);
        }
        
        if (updates.priceFont) {
             const intTxt = findChild(group, 'priceInteger');
             if (intTxt) intTxt.set('fontFamily', updates.priceFont);
             const decTxt = findChild(group, 'priceDecimal');
             if (decTxt) decTxt.set('fontFamily', updates.priceFont);
             const symTxt = findChild(group, 'priceSymbol');
             if (symTxt) symTxt.set('fontFamily', updates.priceFont);
        }

        if(updates.bgColor) {
             const bg = findChild(group, 'offerBackground');
             if (bg) bg.set('fill', updates.bgColor);
        }

        // --- Structural Updates (Price Mode Engine) ---
        if (updates.priceMode !== undefined || updates.priceFrom !== undefined || updates.priceClub !== undefined) {
             // 1. Update Metadata on Group
             if (updates.priceMode) group.priceMode = updates.priceMode;
             if (updates.priceFrom !== undefined) group.priceFrom = updates.priceFrom;
             if (updates.priceClub !== undefined) group.priceClub = updates.priceClub;
             // Atacarejo Fields
             if (updates.priceWholesale !== undefined) group.priceWholesale = updates.priceWholesale;
             if (updates.wholesaleTrigger !== undefined) group.wholesaleTrigger = updates.wholesaleTrigger;
             if (updates.wholesaleTriggerUnit !== undefined) group.wholesaleTriggerUnit = updates.wholesaleTriggerUnit;
             if (updates.packQuantity !== undefined) group.packQuantity = updates.packQuantity;
             if (updates.packUnit !== undefined) group.packUnit = updates.packUnit;
             
             // 2. Extract Data to reconstruct Component
             const intTxt = findChild(group, 'priceInteger');
             const decTxt = findChild(group, 'priceDecimal');
             const currentPrice = (intTxt && decTxt) 
                ? (intTxt.text + decTxt.text).replace(',', '.') 
                : "0.00";
             
             const unitObj = findChild(group, 'priceUnit');
             
             const mockProduct = {
                 price: currentPrice,
                 priceMode: group.priceMode, // Use updated mode
                 priceFrom: group.priceFrom,
                 priceClub: group.priceClub,
                 priceColor: intTxt ? intTxt.fill : 'red', // Preserve color
                 unit: unitObj ? unitObj.text : 'UN',
                 // Atacarejo props
                 priceWholesale: group.priceWholesale,
                 wholesaleTrigger: group.wholesaleTrigger,
                 wholesaleTriggerUnit: group.wholesaleTriggerUnit,
                 packQuantity: group.packQuantity,
                 packUnit: group.packUnit
             };

             // 3. Locate old Price Group Container
             const objects = group.getObjects();
             const oldPg = objects.find((o: any) => o.name === 'priceGroup');
             const bg = objects.find((o: any) => o.name === 'offerBackground');
             const internalWidth = bg ? bg.width : 200;

             if (oldPg) {
                 const oldTop = oldPg.top;
                 
                 // 4. Generate New Layout
                 const newPriceGroup = createPriceLayout(mockProduct, internalWidth, oldTop);
                 
                 // 5. Swap
                 group.remove(oldPg);
                 group.add(newPriceGroup);
             }
        }

        safeAddWithUpdate(group);
    });

    canvas.value.requestRenderAll();
    saveCurrentState();
}

const buildRemoveBgRequest = async (imageUrl: string) => {
    if (imageUrl.startsWith('blob:') || imageUrl.startsWith('data:')) {
        const blob = await (await fetch(imageUrl)).blob();
        const formData = new FormData();
        const mime = String(blob.type || '').toLowerCase();
        const ext = mime.includes('jpeg') || mime.includes('jpg')
            ? 'jpg'
            : mime.includes('png')
                ? 'png'
                : mime.includes('webp')
                    ? 'webp'
                    : 'png';
        formData.append('file', blob, `image.${ext}`);
        formData.append('overwrite', '1');
        return { body: formData as any };
    }

    // Garantir URL absoluta para o backend (Node fetch não aceita URL relativa).
    let normalizedUrl = imageUrl;
    if (imageUrl.startsWith('/')) {
        normalizedUrl = new URL(imageUrl, window.location.origin).toString();
    }

    let sourceKey: string | null = null;
    try {
        const parsed = new URL(normalizedUrl);
        if (/\/api\/storage\/(?:proxy|p)\/?$/i.test(String(parsed.pathname || ''))) {
            sourceKey = parsed.searchParams.get('key');
        }
    } catch {
        // ignore
    }

    return {
        body: {
            imageUrl: normalizedUrl,
            sourceKey: sourceKey || undefined,
            overwrite: true
        } as any
    };
};

const resolveActiveTextObjectForInspectorAction = (active: any) => {
    if (isTextStyleObject(active)) return active;

    const deepActive = (active as any)?._activeObject;
    if (isTextStyleObject(deepActive)) return deepActive;

    const snapshot = selectedObjectRef.value as any;
    const snapshotId = String(snapshot?._customId || '').trim();
    if (snapshotId) {
        const found = findObjectByCustomId(snapshotId)?.obj;
        if (found && isTextStyleObject(found)) return found;
    }

    const snapName = String(snapshot?.name || '').trim();
    const snapText = String(snapshot?.text ?? '');
    const walkForText = (node: any): any => {
        if (!node) return null;
        if (isTextStyleObject(node)) {
            const sameName = snapName && String(node?.name || '').trim() === snapName;
            const sameText = snapText && String(node?.text ?? '') === snapText;
            if (sameName || sameText) return node;
        }
        const t = String(node?.type || '').toLowerCase();
        if ((t === 'group' || t === 'activeselection') && typeof node.getObjects === 'function') {
            const children = node.getObjects() || [];
            for (const child of children) {
                const nested = walkForText(child);
                if (nested) return nested;
            }
        }
        return null;
    };

    const fromActive = walkForText(active);
    if (fromActive) return fromActive;
    if (canvas.value) {
        for (const obj of canvas.value.getObjects()) {
            const nested = walkForText(obj);
            if (nested) return nested;
        }
    }
    return null;
};

const buildLinearGradientFill = (
    target: any,
    colorStops: ReadonlyArray<{ offset: number; color: string }>,
    angleDeg: number = 90
) => {
    const width = Math.max(1, Number(target?.width || target?.getScaledWidth?.() || 1));
    const height = Math.max(1, Number(target?.height || target?.getScaledHeight?.() || 1));
    const halfW = width / 2;
    const halfH = height / 2;
    const radius = Math.max(width, height) / 2;
    const rad = (Number(angleDeg || 0) * Math.PI) / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    return new fabric.Gradient({
        type: 'linear',
        coords: {
            x1: halfW - cos * radius,
            y1: halfH - sin * radius,
            x2: halfW + cos * radius,
            y2: halfH + sin * radius
        },
        colorStops
    });
};

const applyTextGradientPreset = (textObj: any, preset: 'gold' | 'sunset' = 'gold') => {
    const presets = {
        gold: {
            angle: 90,
            stops: [
                { offset: 0, color: '#7A1B00' },
                { offset: 0.2, color: '#C63A00' },
                { offset: 0.48, color: '#FFD45D' },
                { offset: 0.62, color: '#FFF5BD' },
                { offset: 0.82, color: '#FFB33D' },
                { offset: 1, color: '#9B2600' }
            ]
        },
        sunset: {
            angle: 72,
            stops: [
                { offset: 0, color: '#7F1D1D' },
                { offset: 0.36, color: '#FB923C' },
                { offset: 0.68, color: '#FDE047' },
                { offset: 1, color: '#B91C1C' }
            ]
        }
    } as const;

    const selected = presets[preset] || presets.gold;
    textObj.set('fill', buildLinearGradientFill(textObj, selected.stops, selected.angle));
    textObj.dirty = true;
};

const snapshotTextShadow = (shadow: any) => {
    if (!shadow) return null;
    return {
        color: String(shadow.color || 'rgba(0,0,0,0.5)'),
        blur: Number(shadow.blur || 0),
        offsetX: Number(shadow.offsetX || 0),
        offsetY: Number(shadow.offsetY || 0)
    };
};

const applyText3DGoldPreset = (textObj: any) => {
    if (!(textObj as any).__text3dBackup) {
        (textObj as any).__text3dBackup = {
            fill: (textObj as any).fill ?? '#000000',
            stroke: (textObj as any).stroke ?? null,
            strokeWidth: Number((textObj as any).strokeWidth || 0),
            paintFirst: (textObj as any).paintFirst || 'fill',
            shadow: snapshotTextShadow((textObj as any).shadow)
        };
    }

    const baseFontSize = Math.max(12, Number((textObj as any).fontSize || 20));
    applyTextGradientPreset(textObj, 'gold');
    textObj.set({
        stroke: '#7A1B00',
        strokeWidth: Math.max(1.4, Number((baseFontSize * 0.08).toFixed(2))),
        strokeLineJoin: 'round',
        paintFirst: 'stroke',
        shadow: new fabric.Shadow({
            color: 'rgba(80,20,0,0.65)',
            blur: Math.max(2, Math.round(baseFontSize * 0.2)),
            offsetX: Math.max(1, Math.round(baseFontSize * 0.06)),
            offsetY: Math.max(2, Math.round(baseFontSize * 0.11))
        })
    });
    (textObj as any).__text3dEnabled = true;
    textObj.dirty = true;
};

const clearText3DEffect = (textObj: any) => {
    const backup = (textObj as any).__text3dBackup;
    if (backup && typeof backup === 'object') {
        textObj.set({
            fill: backup.fill ?? '#000000',
            stroke: backup.stroke ?? null,
            strokeWidth: Number(backup.strokeWidth || 0),
            paintFirst: backup.paintFirst || 'fill'
        });
        if (backup.shadow) {
            textObj.set('shadow', new fabric.Shadow({
                color: backup.shadow.color,
                blur: backup.shadow.blur,
                offsetX: backup.shadow.offsetX,
                offsetY: backup.shadow.offsetY
            }));
        } else {
            textObj.set('shadow', null);
        }
    } else {
        textObj.set({
            stroke: null,
            strokeWidth: 0,
            paintFirst: 'fill',
            shadow: null
        });
    }
    (textObj as any).__text3dEnabled = false;
    delete (textObj as any).__text3dBackup;
    textObj.dirty = true;
};

const OBJECT_MASK_MIN_SELECTION = 2;

const isObjectMaskCandidate = (obj: any): boolean => {
    if (!obj || typeof obj !== 'object') return false;
    if (obj.id === 'artboard-bg') return false;
    if (isTransientCanvasObject(obj)) return false;
    if (obj.isFrame || isFrameLikeObject(obj)) return false;
    if (isLikelyProductZone(obj)) return false;
    if (isProductCardContainer(obj)) return false;
    const parentGroup = (obj as any).group;
    if (parentGroup && String(parentGroup?.type || '').toLowerCase() !== 'activeselection') return false;
    return true;
};

const hasObjectMaskApplied = (obj: any): boolean => {
    if (!obj || typeof obj !== 'object') return false;
    if (!obj.clipPath) return false;
    if (obj._frameClipOwner) return false;
    return !!obj.objectMaskEnabled;
};

const stripPersistentIdsRecursive = (node: any) => {
    if (!node || typeof node !== 'object') return;
    try { delete node._customId; } catch {}
    try { delete node.id; } catch {}

    const children = typeof node.getObjects === 'function'
        ? (node.getObjects() || [])
        : (Array.isArray(node._objects) ? node._objects : []);
    children.forEach((child: any) => stripPersistentIdsRecursive(child));

    const nestedClip = (node as any).clipPath;
    if (nestedClip && typeof nestedClip === 'object') {
        stripPersistentIdsRecursive(nestedClip);
    }
};

const createObjectMaskClipForTarget = async (maskSource: any, target: any): Promise<any | null> => {
    if (!fabric?.util || !canvas.value) return null;
    if (!maskSource || !target) return null;

    let clipClone: any = null;
    try {
        clipClone = await maskSource.clone(DUPLICATE_CLONE_PROPS);
    } catch (err) {
        console.warn('[mask] Falha ao clonar máscara', err);
        return null;
    }
    if (!clipClone) return null;

    // Clip object must not carry persistent IDs to avoid collisions.
    stripPersistentIdsRecursive(clipClone);
    try { clipClone.set?.('clipPath', null); } catch { clipClone.clipPath = null; }
    try { delete (clipClone as any)._frameClipOwner; } catch {}
    try { delete (clipClone as any).parentFrameId; } catch {}
    try { delete (clipClone as any).parentZoneId; } catch {}
    try { delete (clipClone as any).objectMaskEnabled; } catch {}
    try { delete (clipClone as any).objectMaskSourceId; } catch {}

    const util = fabric.util as any;
    if (
        typeof util?.invertTransform !== 'function' ||
        typeof util?.multiplyTransformMatrices !== 'function' ||
        typeof util?.qrDecompose !== 'function' ||
        typeof maskSource?.calcTransformMatrix !== 'function' ||
        typeof target?.calcTransformMatrix !== 'function'
    ) {
        return null;
    }

    const sourceMatrix = maskSource.calcTransformMatrix();
    const targetMatrix = target.calcTransformMatrix();
    const invTarget = util.invertTransform(targetMatrix);
    const relative = util.multiplyTransformMatrices(invTarget, sourceMatrix);
    const decomp = util.qrDecompose(relative);

    clipClone.set({
        originX: 'center',
        originY: 'center',
        left: Number(decomp?.translateX) || 0,
        top: Number(decomp?.translateY) || 0,
        angle: Number(decomp?.angle) || 0,
        scaleX: Number.isFinite(Number(decomp?.scaleX)) ? Number(decomp.scaleX) : 1,
        scaleY: Number.isFinite(Number(decomp?.scaleY)) ? Number(decomp.scaleY) : 1,
        skewX: Number.isFinite(Number(decomp?.skewX)) ? Number(decomp.skewX) : 0,
        skewY: Number.isFinite(Number(decomp?.skewY)) ? Number(decomp.skewY) : 0,
        absolutePositioned: false,
        selectable: false,
        evented: false
    });

    clipClone.setCoords?.();
    clipClone.dirty = true;
    return clipClone;
};

const clearObjectMaskFromObject = (obj: any): boolean => {
    if (!hasObjectMaskApplied(obj)) return false;
    try { obj.set?.('clipPath', null); } catch { obj.clipPath = null; }
    try { delete (obj as any).objectMaskEnabled; } catch { obj.objectMaskEnabled = false; }
    try { delete (obj as any).objectMaskSourceId; } catch { obj.objectMaskSourceId = undefined; }
    try { delete (obj as any)._frameClipOwner; } catch {}
    if (obj?.parentFrameId) {
        syncObjectFrameClip(obj);
    }
    obj.setCoords?.();
    obj.dirty = true;
    return true;
};

const applyObjectMaskFromSelection = async (selection: any): Promise<number> => {
    if (!canvas.value || !selection || String(selection.type || '').toLowerCase() !== 'activeselection') return 0;

    const members = (typeof selection.getObjects === 'function' ? selection.getObjects() : [])
        .filter((o: any) => isObjectMaskCandidate(o));
    if (members.length < OBJECT_MASK_MIN_SELECTION) return 0;

    const frameMembership = new Set(
        members.map((o: any) => String(o?.parentFrameId || '').trim())
    );
    if (frameMembership.size > 1) return 0;

    const stack = canvas.value.getObjects();
    const stackIndex = (obj: any) => stack.indexOf(obj);
    const sorted = members
        .slice()
        .sort((a: any, b: any) => stackIndex(a) - stackIndex(b));

    // Requested behavior:
    // the bottom object is the mask shape, clipping objects above it.
    const maskSource = sorted[0];
    const targets = sorted.slice(1);
    if (!maskSource || !targets.length) return 0;
    const maskSourceId = String((maskSource as any)?._customId || '').trim();

    canvas.value.discardActiveObject();

    const appliedTargets: any[] = [];
    for (const target of targets) {
        const clip = await createObjectMaskClipForTarget(maskSource, target);
        if (!clip) continue;
        target.set?.('clipPath', clip);
        target.objectMaskEnabled = true;
        if (maskSourceId) target.objectMaskSourceId = maskSourceId;
        else delete (target as any).objectMaskSourceId;
        delete (target as any)._frameClipOwner;
        if (target?.parentFrameId) {
            syncObjectFrameClip(target);
        }
        target.setCoords?.();
        target.dirty = true;
        appliedTargets.push(target);
    }

    if (!appliedTargets.length) return 0;

    const nextMembers = [maskSource, ...appliedTargets].filter(Boolean);
    if (nextMembers.length === 1) {
        canvas.value.setActiveObject(nextMembers[0]);
    } else if (fabric?.ActiveSelection) {
        const nextSelection = new fabric.ActiveSelection(nextMembers, { canvas: canvas.value });
        canvas.value.setActiveObject(nextSelection);
    }

    return appliedTargets.length;
};

const findNearestMaskSourceBelowTarget = (target: any): any | null => {
    if (!canvas.value || !target) return null;
    const objects = canvas.value.getObjects();
    const targetIndex = objects.indexOf(target);
    if (targetIndex <= 0) return null;

    const targetFrameId = String((target as any)?.parentFrameId || '').trim();

    for (let i = targetIndex - 1; i >= 0; i--) {
        const candidate = objects[i];
        if (!candidate || candidate === target) continue;

        const candidateFrameId = String((candidate as any)?.parentFrameId || '').trim();
        if (candidateFrameId !== targetFrameId) continue;
        if (!isObjectMaskCandidate(candidate)) continue;
        return candidate;
    }

    return null;
};

const applyObjectMaskFromSingleTarget = async (target: any): Promise<boolean> => {
    if (!canvas.value || !target) return false;
    if (!isObjectMaskCandidate(target)) return false;

    const maskSource = findNearestMaskSourceBelowTarget(target);
    if (!maskSource) return false;
    const maskSourceId = String((maskSource as any)?._customId || '').trim();

    const clip = await createObjectMaskClipForTarget(maskSource, target);
    if (!clip) return false;

    canvas.value.discardActiveObject();

    target.set?.('clipPath', clip);
    target.objectMaskEnabled = true;
    if (maskSourceId) target.objectMaskSourceId = maskSourceId;
    else delete (target as any).objectMaskSourceId;
    delete (target as any)._frameClipOwner;
    if (target?.parentFrameId) {
        syncObjectFrameClip(target);
    }
    target.setCoords?.();
    target.dirty = true;

    if (fabric?.ActiveSelection) {
        const nextSelection = new fabric.ActiveSelection([maskSource, target], { canvas: canvas.value });
        canvas.value.setActiveObject(nextSelection);
    } else {
        canvas.value.setActiveObject(target);
    }
    return true;
};

const handleAction = async (action: string) => {
    if (!canvas.value) return;
    const active = canvas.value.getActiveObject();

    // Delete (button/menu, important for touch/tablet where keyboard delete is unavailable)
    if (action === 'delete') {
        deleteActiveSelectionFromCanvas();
        return;
    }

    // Duplicate (button/menu)
    if (action === 'duplicate') {
        if (!active) return;
        const activeLayerName = String((active as any)?.layerName || '').trim().toUpperCase();
        const activeName = String((active as any)?.name || '').trim();
        const looksLikeFrame = !!(active as any)?.isFrame ||
            activeLayerName === 'FRAMER' ||
            activeLayerName === 'FRAME' ||
            /^FRAME(?:\s+\d+)?$/i.test(activeName) ||
            /^FRAMER(?:\s+\d+)?$/i.test(activeName);
        if (looksLikeFrame) {
            const duplicatedFrame = await duplicateFrameWithContents(active);
            if (duplicatedFrame) return;
        }
        try {
            const clones = await duplicateActiveObjectWithContext(active, { offsetX: DUPLICATE_OFFSET, offsetY: DUPLICATE_OFFSET });
            if (!clones.length) return;
            finalizeDuplicatedObjects(clones);
            saveCurrentState({ reason: 'duplicate-action' });
        } catch (err) {
            console.warn('[duplicate] Falha ao duplicar (action)', err);
        }
        return;
    }

    // AI edit current image (mask workflow) - replaces the selected image in the design.
    if (action === 'ai-edit-image') {
        const found = findImageTargetInSelection(active);
        if (!found?.img) {
            notifyEditorError('Selecione uma imagem primeiro');
            return;
        }
        const img = found.img;
        const imageUrl = (img as any).src || (img as any)._element?.src || (typeof (img as any).getSrc === 'function' ? (img as any).getSrc() : null);
        if (!imageUrl) {
            notifyEditorError('Não foi possível obter a URL da imagem. Tente usar uma imagem do storage.');
            return;
        }
        if (!(img as any)._customId) (img as any)._customId = Math.random().toString(36).substr(2, 9);

        aiStudio.openStudio({
            initial: {
                mode: 'edit',
                baseImageUrl: String(imageUrl),
                size: guessAiSizeFromObject(img),
                filenameBase: 'ai-edit',
                transparent: false,
                removeBg: false
            },
            applyMode: 'replace',
            replaceTargetId: String((img as any)._customId)
        });
        return;
    }

    // Product card image flows:
    // - replace from local file
    // - replace from uploads
    // - add local file without replacing current image
    // - add from uploads without replacing current image
    if (
        action === 'replace-product-image' ||
        action === 'replace-product-image-upload' ||
        action === 'add-product-image-local' ||
        action === 'add-product-image-upload'
    ) {
        const ctx = resolveSelectedProductCardContext(active);
        const card = ctx.card;
        const image = ctx.image;

        if (!card) {
            notifyEditorError('Selecione um card de produto primeiro.');
            return;
        }
        if (!(card as any)._customId) (card as any)._customId = makeCanvasObjectId();

        if (action === 'replace-product-image') {
            if (image && !(image as any)._customId) (image as any)._customId = makeCanvasObjectId();
            if (image?._customId) {
                openLocalProductImagePicker('replace', { imageId: String(image._customId) });
            } else {
                openLocalProductImagePicker('add', { cardId: String((card as any)._customId) });
            }
            return;
        }

        if (action === 'replace-product-image-upload') {
            if (image && !(image as any)._customId) (image as any)._customId = makeCanvasObjectId();
            if (image?._customId) {
                await openProductImageUploadPickerModal('replace', { imageId: String(image._customId) });
            } else {
                await openProductImageUploadPickerModal('add', { cardId: String((card as any)._customId) });
            }
            return;
        }

        if (action === 'add-product-image-local') {
            openLocalProductImagePicker('add', { cardId: String((card as any)._customId) });
            return;
        }

        if (action === 'add-product-image-upload') {
            await openProductImageUploadPickerModal('add', { cardId: String((card as any)._customId) });
            return;
        }
    }

    // Remove Image Background
    if (action === 'remove-image-bg') {
        if (!active) {
            console.warn('⚠️ [Remove BG] Nenhum objeto selecionado');
            notifyEditorError('Selecione uma imagem primeiro');
            return;
        }

        // Check if it's an image (direct) or a group/selection containing an image
        let targetImage = active;
        let imageUrl = null;

        if (active.type === 'image') {
            imageUrl = active.src || (active as any)._element?.src || (active as any).getSrc();
        } else if (active.type === 'group' || active.type === 'activeSelection') {
            const objects = typeof active.getObjects === 'function' ? active.getObjects() : [];
            const foundImage = objects.find((o: any) => o.type === 'image');
            if (foundImage) {
                targetImage = foundImage;
                imageUrl = foundImage.src || (foundImage as any)._element?.src || foundImage.getSrc();
            }
        } else {
            console.warn('⚠️ [Remove BG] Tipo de objeto não suportado:', active.type);
            notifyEditorError('Selecione uma imagem válida');
            return;
        }

        if (!imageUrl) {
            console.warn('⚠️ [Remove BG] Imagem não tem URL');
            notifyEditorError('Não foi possível obter a URL da imagem. Tente usar uma imagem do storage.');
            return;
        }

        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'fixed top-4 right-4 bg-zinc-900 text-white px-4 py-2 rounded-lg shadow-lg z-50 flex items-center gap-2 border border-white/10';
        loadingIndicator.innerHTML = '<span class="animate-spin mr-2">⟳</span> Removendo fundo...';
        document.body.appendChild(loadingIndicator);

        try {
            const request = await buildRemoveBgRequest(imageUrl);
            const headers = await getApiAuthHeaders();
            const result = await $fetch('/api/remove-image-bg', {
                method: 'POST',
                headers,
                ...(request as any)
            }) as any;

            if (result?.url) {
                const proxiedBgUrl = toWasabiProxyUrl(result.url) || result.url;
                const cacheBustedBgUrl = (() => {
                    try {
                        const u = new URL(proxiedBgUrl, window.location.origin);
                        if (!u.searchParams.get('v')) u.searchParams.set('v', String(Date.now()));
                        return u.toString();
                    } catch {
                        const sep = proxiedBgUrl.includes('?') ? '&' : '?';
                        return `${proxiedBgUrl}${sep}v=${Date.now()}`;
                    }
                })();

                const newImg: any = await fabric.Image.fromURL(cacheBustedBgUrl, { crossOrigin: 'anonymous' });
                if (!newImg || !canvas.value) {
                    throw new Error('Falha ao carregar imagem processada');
                }

                const oldDisplayWidth = (targetImage.width || 1) * (targetImage.scaleX || 1);
                const oldDisplayHeight = (targetImage.height || 1) * (targetImage.scaleY || 1);
                const newWidth = newImg.width || 1;
                const newHeight = newImg.height || 1;
                const newScaleX = oldDisplayWidth / newWidth;
                const newScaleY = oldDisplayHeight / newHeight;

                // For groups/selections, replace the image inside
                if (active.type === 'group' || active.type === 'activeSelection') {
                    const objects = typeof active.getObjects === 'function' ? active.getObjects() : [];
                    const imgIndex = objects.findIndex((o: any) => o.type === 'image');
                    if (imgIndex >= 0) {
                        const oldImg = objects[imgIndex];
                        active.remove(oldImg);
                        (newImg as any).src = cacheBustedBgUrl;
                        newImg.set({
                            left: oldImg.left,
                            top: oldImg.top,
                            scaleX: newScaleX,
                            scaleY: newScaleY,
                            angle: oldImg.angle || 0,
                            originX: oldImg.originX || 'center',
                            originY: oldImg.originY || 'center',
                            name: (oldImg as any).name,
                            _customId: (oldImg as any)._customId,
                            opacity: (oldImg as any).opacity,
                            flipX: (oldImg as any).flipX,
                            flipY: (oldImg as any).flipY,
                            clipPath: (oldImg as any).clipPath,
                            filters: (oldImg as any).filters
                        });
                        if (typeof (active as any).insertAt === 'function') {
                            (active as any).insertAt(imgIndex, newImg);
                        } else {
                            active.add(newImg);
                        }
                        safeAddWithUpdate(active);
                        active.setCoords();
                    }
                } else {
                    // Preserve ALL properties from current image
                    const propsToPreserve = {
                        left: active.left,
                        top: active.top,
                        scaleX: newScaleX,
                        scaleY: newScaleY,
                        angle: active.angle,
                        originX: active.originX,
                        originY: active.originY,
                        selectable: active.selectable,
                        evented: active.evented,
                        hasControls: active.hasControls,
                        hasBorders: active.hasBorders,
                        _customId: (active as any)._customId,
                        name: (active as any).name,
                        opacity: (active as any).opacity,
                        flipX: (active as any).flipX,
                        flipY: (active as any).flipY,
                        clipPath: (active as any).clipPath,
                        filters: (active as any).filters,
                        src: cacheBustedBgUrl
                    };

                    newImg.set(propsToPreserve);
                    (newImg as any).src = cacheBustedBgUrl;

                    // Remove old image and add new one
                    const oldIndex = canvas.value.getObjects().indexOf(active);
                    canvas.value.remove(active);
                    if (oldIndex >= 0 && typeof (canvas.value as any).insertAt === 'function') {
                        (canvas.value as any).insertAt(oldIndex, newImg);
                    } else {
                        canvas.value.add(newImg);
                    }
                }

                canvas.value.setActiveObject(active.type === 'group' ? active : newImg);
                canvas.value.requestRenderAll();
                saveCurrentState();
            } else {
                throw new Error('API não retornou URL válida');
            }
        } catch (err: any) {
            console.error('❌ [Remove BG] Erro ao remover fundo:', err);
            const serverMessage = String(
                err?.data?.statusMessage ||
                err?.data?.message ||
                err?.statusMessage ||
                err?.message ||
                'Erro desconhecido'
            );
            notifyEditorError('Erro ao remover fundo: ' + serverMessage);
        } finally {
            loadingIndicator?.remove();
        }
        return;
    }

    // Export actions
    if (action === 'export-selected' || action === 'export-png' || action === 'export-svg' || action === 'export-jpg') {
        if (!active) {
            notifyEditorInfo('Selecione um objeto para exportar.');
        } else {
            await exportSelectedObject(action.replace('export-', '') as 'png' | 'svg' | 'jpg', active)
        }
        return
    }
    
    // Group / Ungroup
    if (action === 'group') {
        if (!active || active.type !== 'activeSelection') return;

        // CRITICAL: Check if all objects are in the same frame
        const objects = active.getObjects();
        const parentFrames = new Set(objects.map((o: any) => o.parentFrameId).filter(Boolean));

        if (parentFrames.size > 1) {
            // Objects are in different frames - prevent grouping
            notifyEditorError('Não é possível agrupar objetos de frames diferentes. Mova os objetos para o mesmo frame primeiro.');
            return;
        }

        active.toGroup();
        canvas.value.requestRenderAll();
        saveCurrentState();

        // Update selection to the new group and preserve parentFrameId
	        const newGroup = canvas.value.getActiveObject();
	        if (newGroup) {
	            if (!newGroup._customId) newGroup._customId = Math.random().toString(36).substr(2, 9);
	            // Preserve parentFrameId from the objects (they all have the same one at this point)
	            if (parentFrames.size === 1) {
	                newGroup.parentFrameId = [...parentFrames][0];
	            }
	            selectedObjectRef.value = snapshotForPropertiesPanel(newGroup);
	        }
	        return;
	    }
    if (action === 'ungroup') {
        if (!active || active.type !== 'group') return;

        // Preserve parentFrameId before ungrouping
        const parentFrameId = (active as any).parentFrameId;
        const objects = active.getObjects();
        const customIds = objects.map((o: any) => o._customId);

        active.toActiveSelection();
        canvas.value.requestRenderAll();
        saveCurrentState();

        // Restore parentFrameId to all children after ungrouping
        const newSelection = canvas.value.getActiveObject();
        if (newSelection && parentFrameId) {
            newSelection.getObjects().forEach((o: any) => {
                o.parentFrameId = parentFrameId;
            });
	        }

	        // Update selection
	        selectedObjectRef.value = snapshotForPropertiesPanel(canvas.value.getActiveObject());
	        return;
	    }

    // Flip
    if (action === 'flip-h') {
        if (!active) return;
        if (
            String(active.type || '').toLowerCase() === 'image' &&
            active.group &&
            (active.group.isSmartObject || active.group.isProductCard || isLikelyProductCard(active.group))
        ) {
            active.set({ flipX: false, flipY: false, lockScalingFlip: true });
            canvas.value.requestRenderAll();
            saveCurrentState();
            return;
        }
        active.set('flipX', !active.flipX);
        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }
    if (action === 'flip-v') {
        if (!active) return;
        if (
            String(active.type || '').toLowerCase() === 'image' &&
            active.group &&
            (active.group.isSmartObject || active.group.isProductCard || isLikelyProductCard(active.group))
        ) {
            active.set({ flipX: false, flipY: false, lockScalingFlip: true });
            canvas.value.requestRenderAll();
            saveCurrentState();
            return;
        }
        active.set('flipY', !active.flipY);
        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }

    // Masking (Framer/Figma-like)
    if (action === 'toggle-mask') {
        if (!active) return;
        const checkpointMaskUndo = async () => {
            if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
            await Promise.resolve(saveCurrentState({ reason: 'mask-checkpoint', skipCoalesce: true }));
        };

        if (String(active.type || '').toLowerCase() === 'activeselection') {
            const members = typeof active.getObjects === 'function' ? (active.getObjects() || []) : [];
            const clearable = members.filter((obj: any) => hasObjectMaskApplied(obj));

            if (clearable.length > 0 && clearable.length === members.length) {
                await checkpointMaskUndo();
                clearable.forEach((obj: any) => clearObjectMaskFromObject(obj));
                canvas.value.requestRenderAll();
                refreshCanvasObjects();
                updateSelection();
                if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
                await Promise.resolve(saveCurrentState({ reason: 'remove-object-mask-selection', skipCoalesce: true }));
                return;
            }

            await checkpointMaskUndo();
            const appliedCount = await applyObjectMaskFromSelection(active);
            if (appliedCount <= 0) {
                notifyEditorInfo('Selecione ao menos 2 objetos no mesmo frame (ou fora). O de baixo vira a máscara.');
                return;
            }

            canvas.value.requestRenderAll();
            refreshCanvasObjects();
            updateSelection();
            if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
            await Promise.resolve(saveCurrentState({ reason: 'apply-object-mask', skipCoalesce: true }));
            return;
        }

        if (hasObjectMaskApplied(active)) {
            await checkpointMaskUndo();
            clearObjectMaskFromObject(active);
            canvas.value.requestRenderAll();
            refreshCanvasObjects();
            updateSelection();
            if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
            await Promise.resolve(saveCurrentState({ reason: 'remove-object-mask', skipCoalesce: true }));
            return;
        }

        await checkpointMaskUndo();
        const appliedSingle = await applyObjectMaskFromSingleTarget(active);
        if (appliedSingle) {
            canvas.value.requestRenderAll();
            refreshCanvasObjects();
            updateSelection();
            if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
            await Promise.resolve(saveCurrentState({ reason: 'apply-object-mask-single', skipCoalesce: true }));
            return;
        }

        notifyEditorInfo('Selecione um objeto com outro logo abaixo na pilha para usar como máscara.');
        return;
    }

    // === Figma-style Crop ===
    if (action === 'activate-crop') {
        if (!active) return;
        figmaCrop.activateCrop(active);
        return;
    }

    if (action === 'apply-crop') {
        if (!figmaCrop.cropTargetObject.value) return;
        figmaCrop.applyCrop(figmaCrop.cropFrameRect.value);
        canvas.value?.requestRenderAll();
        saveCurrentState();
        return;
    }

    if (action === 'cancel-crop') {
        figmaCrop.cancelCrop();
        canvas.value?.requestRenderAll();
        return;
    }

    // --- Align / Center (Inspector actions) ---
    if (action === 'align-top') { alignSelectionVertically('top'); return; }
    if (action === 'align-middle') { alignSelectionVertically('middle'); return; }
    if (action === 'align-bottom') { alignSelectionVertically('bottom'); return; }
    if (action === 'center-h') { centerSelectionInContainer('h'); return; }
    if (action === 'center-v') { centerSelectionInContainer('v'); return; }
    if (action === 'center-both') { centerSelectionInContainer('both'); return; }

    // Gap / Spacing Update
    if (action.startsWith('update-gap:') || action.startsWith('update-padding-')) {
        const isGap = action.startsWith('update-gap:');
        const isPadX = action.startsWith('update-padding-x:');
        const isPadY = action.startsWith('update-padding-y:');
        const val = parseInt(action.split(':')[1] || '0') || 0;

        if (!active || (active.type !== 'activeSelection' && active.type !== 'group')) return;
        
        if (isGap) active.gap = val;
        if (isPadX) active.paddingX = val;
        if (isPadY) active.paddingY = val;

        const gap = active.gap || 0;
        const padX = active.paddingX || 0;
        const padY = active.paddingY || 0;

        const objects = active.getObjects();
        if (objects.length < 1) return;

        // Sort by left (assuming horizontal auto-layout for now)
        objects.sort((a: any, b: any) => a.left - b.left);
        
        // Calculate new positions based on gap
        let currentPos = objects[0].left; // Start at first object's original left? 
        // Better: Start at group left + padX if it's a group
        if (active.type === 'group') {
             // Fabric group coords are relative to group center usually, but here lets simplify
             // We'll re-layout items relative to each other
             let totalWidth = 0;
             objects.forEach((obj: any, i: number) => {
                 obj.set('left', totalWidth); // Local coord inside group?
                 totalWidth += (obj.width * obj.scaleX) + gap;
             });
             // Remove last gap
             totalWidth -= gap;
             
             // Update Group Width (Hug Contents Logic)
             active.set('width', totalWidth + (padX * 2));
             active.set('height', active.height + (padY * 2)); // Simplistic height hug
             
             // Center items
             const startX = -active.width / 2 + padX;
             const startY = -active.height / 2 + padY;
             
             let x = startX;
             objects.forEach((obj: any) => {
                 obj.set('left', x + (obj.width * obj.scaleX) / 2); // Origin center correction
                 obj.set('top', startY + (obj.height * obj.scaleY) / 2);
                 x += (obj.width * obj.scaleX) + gap;
             });
             
             safeAddWithUpdate(active);
        } else {
            // Active Selection (Temporary layout)
            let currentX = objects[0].left;
            objects.forEach((obj: any, i: number) => {
                if (i > 0) {
                    const prevObj = objects[i-1];
                    currentX = prevObj.left + (prevObj.width * prevObj.scaleX) + gap;
                    obj.set('left', currentX);
                }
            });
            safeAddWithUpdate(active);
        }

        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }
    
    // Layout Modes
    if (action === 'layout-hug') {
        if (!active || active.type !== 'group') return;
        // Hug Logic: Resize group to fit children + padding
        // Already handled in gap update mostly, but let's force a re-calc
        const objects = active.getObjects();
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        objects.forEach((obj: any) => {
            if(obj.left < minX) minX = obj.left;
            if(obj.top < minY) minY = obj.top;
            if(obj.left + obj.width * obj.scaleX > maxX) maxX = obj.left + obj.width * obj.scaleX;
            if(obj.top + obj.height * obj.scaleY > maxY) maxY = obj.top + obj.height * obj.scaleY;
        });
        
        const padX = active.paddingX || 0;
        const padY = active.paddingY || 0;
        
        active.set({
            width: (maxX - minX) + (padX * 2),
            height: (maxY - minY) + (padY * 2)
        });
        safeAddWithUpdate(active);
        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }

    if (action === 'layout-fill') {
        if (!active || active.type !== 'group') return;
        // Fill Logic: Resize children to fill group width
        const padX = active.paddingX || 0;
        const availableWidth = active.width - (padX * 2);
        const objects = active.getObjects();
        
        objects.forEach((obj: any) => {
            // Simple Fill: Stretch all items to match container width
            // This is "Vertical Auto Layout" behavior usually
            const scaleX = availableWidth / obj.width;
            obj.set('scaleX', scaleX);
        });
        safeAddWithUpdate(active);
        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }

    // Components (Make Component)
    if (action === 'create-component') {
        if (!active) return;
        
        // Convert to group if selection
        let target = active;
        if (active.type === 'activeSelection') {
            active.toGroup();
            target = canvas.value.getActiveObject();
        }
        
        if (target) {
            target.isComponent = true;
            // Visual indicator: Purple Border
            target.set({
                borderColor: '#8b5cf6', // Violet-500
                cornerColor: '#8b5cf6',
                cornerStrokeColor: '#fff',
                borderDashArray: [0, 0], // Solid
                padding: 5
            });
            
            // Add label? Fabric doesn't support easy labels outside, 
            // but we could group with text or just use properties panel.
            
            canvas.value.requestRenderAll();
            saveCurrentState();
            // Force Update UI
            selectedObjectRef.value = snapshotForPropertiesPanel(target);
        }
        return;
    }

    // Path Operations (Vector Paths)
    if (action === 'close-path') {
        closePath();
        return;
    }
    
    if (action === 'simplify-path') {
        simplifyPath();
        return;
    }
    
    if (action === 'split-path') {
        splitPath();
        return;
    }
    
    if (action === 'add-path-point') {
        // Add point to path at midpoint of selected segment
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (!isNodeEditing.value) {
            enterPathNodeEditing(active);
        }
        // Note: Point will be added on click on segment (handled in mouse:down)
        return;
    }
    
    if (action === 'delete-path-point') {
        // Delete selected point from path
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (selectedPathNodeIndex.value !== null) {
            removePathPoint(active, selectedPathNodeIndex.value);
        }
        return;
    }
    
    if (action === 'toggle-handles') {
        // Toggle bezier handles visibility/editing
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (isNodeEditing.value) {
            exitNodeEditing();
        } else {
            enterPathNodeEditing(active);
        }
        return;
    }
    
    // Curve conversion functions
    if (action === 'convert-to-smooth') {
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (selectedPathNodeIndex.value !== null) {
            convertPointToSmooth(active, selectedPathNodeIndex.value);
        }
        return;
    }
    
    if (action === 'convert-to-corner') {
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (selectedPathNodeIndex.value !== null) {
            convertPointToCorner(active, selectedPathNodeIndex.value);
        }
        return;
    }
    
    if (action === 'mirror-handles') {
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (selectedPathNodeIndex.value !== null) {
            mirrorHandles(active, selectedPathNodeIndex.value);
        }
        return;
    }
    
    if (action === 'reset-handles') {
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (selectedPathNodeIndex.value !== null) {
            resetHandles(active, selectedPathNodeIndex.value);
        }
        return;
    }
    
    if (action === 'smooth-handles') {
        const active = canvas.value.getActiveObject();
        if (!active || !active.isVectorPath) return;
        if (selectedPathNodeIndex.value !== null) {
            smoothHandles(active, selectedPathNodeIndex.value);
        }
        return;
    }

    // Boolean Operations (Simplified via globalCompositeOperation or Grouping)
    if (action === 'union' || action === 'subtract') {
        if (!active || active.type !== 'activeSelection') return;
        
        // In Figma, Boolean Ops are live groups. 
        // Here we'll simulate it by creating a special group or flattening.
        // For 'subtract', the top objects will cut the bottom one.
        const objects = active.getObjects();
        const topObj = objects[objects.length - 1];
        const bottomObj = objects[0];

        if (action === 'subtract') {
            // Fabric can use clipPath for this
            bottomObj.set('clipPath', topObj);
            // topObj.visible = false; // Usually the cutter is hidden or used as mask
            // This is a simplified mock of Boolean.
        }
        
        active.toGroup();
        canvas.value.requestRenderAll();
        saveCurrentState();
        return;
    }

    if (action === 'text-3d-gold' || action === 'text-gradient-gold' || action === 'text-gradient-sunset' || action === 'text-3d-clear') {
        const textTarget = resolveActiveTextObjectForInspectorAction(active);
        if (!textTarget) {
            notifyEditorInfo('Selecione um texto para aplicar o efeito.');
            return;
        }

        if (action === 'text-3d-gold') {
            applyText3DGoldPreset(textTarget);
        } else if (action === 'text-gradient-gold') {
            applyTextGradientPreset(textTarget, 'gold');
        } else if (action === 'text-gradient-sunset') {
            applyTextGradientPreset(textTarget, 'sunset');
        } else {
            clearText3DEffect(textTarget);
        }

        if (textTarget.group) safeAddWithUpdate(textTarget.group);
        textTarget.setCoords?.();
        selectedObjectRef.value = snapshotForPropertiesPanel(textTarget);
        canvas.value.requestRenderAll();
        saveCurrentState({ reason: action });
        return;
    }

    // Text Case
    if (action === 'text-upper') {
        if (active && (active.type === 'i-text' || active.type === 'text' || active.type === 'textbox')) {
            active.set('text', active.text.toUpperCase());
            canvas.value.requestRenderAll();
            saveCurrentState();
        }
        return;
    }
    if (action === 'text-lower') {
        if (active && (active.type === 'i-text' || active.type === 'text' || active.type === 'textbox')) {
            active.set('text', active.text.toLowerCase());
            canvas.value.requestRenderAll();
            saveCurrentState();
        }
        return;
    }

    // Distribute (Requires Active Selection)
    if (action.startsWith('distribute-') && active && active.type === 'activeSelection') {
        if (!fabric?.Point) return;
        const objects = (typeof active.getObjects === 'function') ? (active.getObjects() || []) : [];
        if (objects.length < 3) return; // Need 3+ for meaningful distribution

        if (action === 'distribute-h') {
            const items = objects.map((obj: any) => {
                const br = obj.getBoundingRect?.(true) || { left: obj.left || 0, top: obj.top || 0, width: 0, height: 0 };
                return {
                    obj,
                    left: Number(br.left || 0),
                    right: Number(br.left || 0) + Number(br.width || 0),
                    width: Number(br.width || 0)
                };
            }).sort((a: any, b: any) => a.left - b.left);

            const minLeft = items[0].left;
            const maxRight = items[items.length - 1].right;
            const totalWidth = items.reduce((sum: number, it: any) => sum + it.width, 0);
            const gap = Math.max(0, (maxRight - minLeft - totalWidth) / (items.length - 1));

            let cursor = minLeft;
            for (const it of items) {
                const center = it.obj.getCenterPoint ? it.obj.getCenterPoint() : { x: it.obj.left, y: it.obj.top };
                const nextCx = cursor + (it.width / 2);
                it.obj.setPositionByOrigin(new fabric.Point(nextCx, center.y), 'center', 'center');
                it.obj.setCoords?.();
                cursor += it.width + gap;
            }
        }

        if (action === 'distribute-v') {
            const items = objects.map((obj: any) => {
                const br = obj.getBoundingRect?.(true) || { left: obj.left || 0, top: obj.top || 0, width: 0, height: 0 };
                return {
                    obj,
                    top: Number(br.top || 0),
                    bottom: Number(br.top || 0) + Number(br.height || 0),
                    height: Number(br.height || 0)
                };
            }).sort((a: any, b: any) => a.top - b.top);

            const minTop = items[0].top;
            const maxBottom = items[items.length - 1].bottom;
            const totalHeight = items.reduce((sum: number, it: any) => sum + it.height, 0);
            const gap = Math.max(0, (maxBottom - minTop - totalHeight) / (items.length - 1));

            let cursor = minTop;
            for (const it of items) {
                const center = it.obj.getCenterPoint ? it.obj.getCenterPoint() : { x: it.obj.left, y: it.obj.top };
                const nextCy = cursor + (it.height / 2);
                it.obj.setPositionByOrigin(new fabric.Point(center.x, nextCy), 'center', 'center');
                it.obj.setCoords?.();
                cursor += it.height + gap;
            }
        }

        // Re-layout selection box
        safeAddWithUpdate(active);
        canvas.value.requestRenderAll();
        saveCurrentState({ reason: action });
        return;
    }
}



// Layers Panel Actions
type LayerSelectPayload = string | { id: string; additive?: boolean; toggle?: boolean; range?: boolean };
type LayerReorderPayload = { sourceId: string; targetId: string; place: 'before' | 'after' };
type LayerContextMenuPayload = { id: string; x: number; y: number };

const selectObject = (payload: LayerSelectPayload) => {
    if (!canvas.value) return;

    const id = typeof payload === 'string' ? payload : String(payload?.id || '');
    if (!id) return;
    const additive = typeof payload === 'object' ? !!payload.additive : false;
    const toggle = typeof payload === 'object' ? !!payload.toggle : false;
    const range = typeof payload === 'object' ? !!payload.range : false;

    const obj = canvas.value.getObjects().find((o: any) => o._customId === id);
    if (!obj) return;

    if (!additive && !range) {
        canvas.value.setActiveObject(obj);
        canvas.value.requestRenderAll();
        updateSelection();
        return;
    }

    const active = canvas.value.getActiveObject?.();
    const current = typeof canvas.value.getActiveObjects === 'function'
        ? (canvas.value.getActiveObjects() || [])
        : (active ? [active] : []);
    const existing = current.filter((o: any) => !!o);

    let nextSelection = existing.slice();
    const idx = nextSelection.findIndex((o: any) => o === obj || String(o?._customId || '') === id);

    if (idx >= 0 && toggle) {
        nextSelection.splice(idx, 1);
    } else if (idx < 0) {
        nextSelection.push(obj);
    }

    if (nextSelection.length <= 0) {
        canvas.value.discardActiveObject();
    } else if (nextSelection.length === 1) {
        canvas.value.setActiveObject(nextSelection[0]);
    } else if (fabric?.ActiveSelection) {
        const selection = new fabric.ActiveSelection(nextSelection, { canvas: canvas.value });
        canvas.value.setActiveObject(selection);
    } else {
        canvas.value.setActiveObject(nextSelection[nextSelection.length - 1]);
    }

    canvas.value.requestRenderAll();
    updateSelection();
}

const isLayerIdInSelection = (id: string) => {
    const normalized = String(id || '').trim();
    if (!normalized) return false;
    if (String(selectedObjectId.value || '').trim() === normalized) return true;
    return Array.isArray(selectedObjectIds.value)
        ? selectedObjectIds.value.some((entry) => String(entry || '').trim() === normalized)
        : false;
};

const handleLayersContextMenu = (payload: LayerContextMenuPayload) => {
    if (!canvas.value) return;
    const id = String(payload?.id || '').trim();
    if (!id) return;

    if (!isLayerIdInSelection(id)) {
        selectObject(id);
    }

    canvasContextMenu.value.show = false;
    layersContextMenu.value = {
        show: true,
        x: Number(payload?.x || 0),
        y: Number(payload?.y || 0)
    };
};

const reorderLayerByDrag = (payload: LayerReorderPayload) => {
    if (!canvas.value || !payload) return;
    const sourceId = String(payload.sourceId || '').trim();
    const targetId = String(payload.targetId || '').trim();
    const place = payload.place === 'before' ? 'before' : 'after';
    if (!sourceId || !targetId || sourceId === targetId) return;

    const objects = canvas.value.getObjects();
    const sourceObj = objects.find((o: any) => String(o?._customId || '').trim() === sourceId);
    const targetObj = objects.find((o: any) => String(o?._customId || '').trim() === targetId);
    if (!sourceObj || !targetObj) return;

    const sourceParentFrame = String((sourceObj as any)?.parentFrameId || '').trim();
    const targetParentFrame = String((targetObj as any)?.parentFrameId || '').trim();
    if (sourceParentFrame !== targetParentFrame) {
        notifyEditorInfo('Arraste camadas apenas dentro do mesmo nível/frame.');
        return;
    }

    const sourceIndex = objects.indexOf(sourceObj);
    const targetIndex = objects.indexOf(targetObj);
    if (sourceIndex < 0 || targetIndex < 0) return;

    const ids = objects.map((o: any) => String(o?._customId || '').trim());
    const compact = ids.filter((id: string) => !!id && id !== sourceId);
    const targetIndexAfterRemoval = compact.indexOf(targetId);
    if (targetIndexAfterRemoval < 0) return;

    const insertIndexAfterRemoval = place === 'before'
        ? targetIndexAfterRemoval + 1
        : targetIndexAfterRemoval;
    const finalIndex = Math.max(0, Math.min(insertIndexAfterRemoval, compact.length));

    const canvasApi: any = canvas.value as any;
    if (typeof canvasApi.moveTo === 'function') {
        canvasApi.moveTo(sourceObj, finalIndex);
    } else {
        // Fallback antigo
        canvas.value.remove(sourceObj);
        if (typeof canvas.value.insertAt === 'function') {
            canvas.value.insertAt(finalIndex, sourceObj);
        } else {
            canvas.value.add(sourceObj);
        }
    }

    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    updateSelection();
    if (cancelPendingCoalescedSave) cancelPendingCoalescedSave();
    saveCurrentState({ reason: 'layers-drag-reorder', skipCoalesce: true });
}

const toggleVisible = (id: string) => {
    if (!canvas.value) return; 
    const obj = canvas.value.getObjects().find((o: any) => o._customId === id);
    if (obj) {
        const next = !(obj.visible !== false);
        const isFrameTarget = !!obj.isFrame || !!isFrameLikeObject(obj);
        let targets: any[] = [obj];

        if (isFrameTarget) {
            if (!obj.isFrame) obj.isFrame = true;
            // Ensure frame membership is up to date before toggling visibility.
            try { syncFrameClips(obj); } catch (_) {}
            targets = collectFrameVisibilityTargets(obj);
        }

        targets.forEach((entry: any) => {
            applyObjectVisibility(entry, next);
        });

        // If hiding, clear selection when active object (or selection member) is hidden.
        if (!next) {
            const active = canvas.value.getActiveObject?.();
            const hiddenSet = new Set(targets);
            let shouldClear = !!active && hiddenSet.has(active);
            if (!shouldClear && active && typeof active.getObjects === 'function') {
                const members = active.getObjects() || [];
                shouldClear = members.some((m: any) => hiddenSet.has(m));
            }
            if (shouldClear) canvas.value.discardActiveObject();
        }
        canvas.value.requestRenderAll();
        // Trigger update to refresh UI icons
        // (Fabric doesn't emit 'modified' on property set via code usually, need to force or rely on array ref update might not catch deep prop)
        // Since canvasObjects is shallow array, deep prop change might not trigger watcher if we had one. 
        // But our LayersPanel reads directly from the object prop. We might need to force update the array reference to trigger re-render of panel items.
        refreshCanvasObjects();
        updateSelection();
        saveCurrentState({ reason: 'layers-toggle-visible' });
    }
}

const toggleLock = (id: string) => {
    if (!canvas.value) return; 
    const obj = canvas.value.getObjects().find((o: any) => o._customId === id);
    if (obj) {
        // Lock movement and scaling
        const isLocked = !obj.lockMovementX;
        obj.set({
            lockMovementX: isLocked,
            lockMovementY: isLocked,
            lockScalingX: isLocked,
            lockScalingY: isLocked,
            lockRotation: isLocked
        });
        canvas.value.requestRenderAll();
        refreshCanvasObjects();
        // Persist lock so reload keeps it
        saveCurrentState();
        if (selectedObjectId.value === id) refreshSelectedRef();
    }
}

const deleteObject = (id: string) => {
    if (!canvas.value) return; 
    const obj = canvas.value.getObjects().find((o: any) => o._customId === id);
    if (obj) {
        const isFrameTarget = !!obj.isFrame || !!isFrameLikeObject(obj);
        if (isFrameTarget && typeof window !== 'undefined') {
            const ok = window.confirm(
                'Excluir Frame no painel de camadas? Isso remove tambem todo o conteudo dentro dele.'
            );
            if (!ok) return;
        }

        const active = canvas.value.getActiveObject?.();
        if (active && active === obj) canvas.value.discardActiveObject();
        if (isFrameTarget) {
            const targets = collectFrameVisibilityTargets(obj);
            targets.forEach((entry: any) => {
                if (!entry) return;
                if (isControlLikeObject(entry) || isTransientCanvasObject(entry)) return;
                if (String(entry.id || '') === 'artboard-bg') return;
                try { canvas.value!.remove(entry); } catch {}
            });
        } else {
            canvas.value.remove(obj);
        }
        canvas.value.requestRenderAll();
        refreshCanvasObjects();
        updateSelection();
        saveCurrentState({ reason: 'layers-delete' });
    }
}

const moveLayer = (id: string, dir: 'up' | 'down') => {
    if (!canvas.value) return;
    const obj = canvas.value.getObjects().find((o: any) => o._customId === id);
    if (obj) {
        // Verificar se o método existe antes de chamar
        if (dir === 'up') {
            if (typeof obj.bringForward === 'function') {
                obj.bringForward();
            } else if (typeof obj.bringToFront === 'function') {
                obj.bringToFront();
            } else {
                // Alternativa: mover objeto manualmente no array
                const objects = canvas.value.getObjects();
                const index = objects.indexOf(obj);
                if (index >= 0 && index < objects.length - 1) {
                    canvas.value.remove(obj);
                    canvas.value.insertAt(index + 2, obj);
                }
            }
        } else {
            if (typeof obj.sendBackwards === 'function') {
                obj.sendBackwards();
            } else if (typeof obj.sendToBack === 'function') {
                obj.sendToBack();
            } else {
                // Alternativa: mover objeto manualmente no array
                const objects = canvas.value.getObjects();
                const index = objects.indexOf(obj);
                if (index > 1) {
                    canvas.value.remove(obj);
                    canvas.value.insertAt(index - 1, obj);
                }
            }
        }

        canvas.value.requestRenderAll();
        // Update list order
        refreshCanvasObjects();
        saveCurrentState({ reason: dir === 'up' ? 'layers-move-up' : 'layers-move-down' });
    }
}

const renameLayer = (id: string, newName: string) => {
    if (!canvas.value) return; 
    const obj = canvas.value.getObjects().find((o: any) => o._customId === id);
    if (obj) {
        obj.layerName = newName; // Custom property for our UI
        // Also update fabric name if standard
        // obj.name = newName; 
        
        refreshCanvasObjects(); // Trigger reactivity
        saveCurrentState();
    }
}

// --- Export Feature ---
const exportDesign = () => {
    if (exportSettings.value.format !== 'png' && exportSettings.value.format !== 'jpeg') {
        exportSettings.value.format = 'png';
    }
    exportSettings.value.scale = HIGH_RES_EXPORT_SCALE;
    exportSettings.value.quality = HIGH_RES_EXPORT_QUALITY;
    if (hasExportableSelectedObject.value) {
        exportSettings.value.exportScope = 'selected-object';
    } else if (availableFramesForExport.value.length > 0) {
        exportSettings.value.exportScope = 'selected-frame';
        if (!exportSettings.value.selectedFrameId) {
            exportSettings.value.selectedFrameId = String(availableFramesForExport.value[0]?.id || '');
        }
    } else {
        exportSettings.value.exportScope = 'selected-object';
    }
    showExportModal.value = true;
}

const isBlockedObjectForScopedExport = (obj: any): boolean => {
    if (!obj) return true;
    if ((obj as any).excludeFromExport) return true;
    if ((obj as any).isFrame) return true;
    if (isLikelyProductZone(obj)) return true;
    return false;
};

const isExportableSelectionObject = (obj: any): boolean => {
    if (!obj) return false;
    if (isBlockedObjectForScopedExport(obj)) return false;

    if (obj?.type === 'activeSelection' && typeof obj?.getObjects === 'function') {
        const children = (obj.getObjects() || []).filter(Boolean);
        if (!children.length) return false;
        if (children.some((child: any) => isBlockedObjectForScopedExport(child))) return false;
    }

    return true;
};

const resolveExportableSelectedObject = (preferred?: any): any | null => {
    const candidates: any[] = [];
    if (preferred) candidates.push(preferred);
    if (canvas.value?.getActiveObject) candidates.push(canvas.value.getActiveObject());

    if (selectedObjectId.value && canvas.value) {
        const byId = canvas.value.getObjects().find((o: any) => String(o?._customId || '') === String(selectedObjectId.value));
        if (byId) candidates.push(byId);
    }

    for (const candidate of candidates) {
        if (isExportableSelectionObject(candidate)) return candidate;
    }

    return null;
};

const getSelectedObjectExportFileBaseName = (obj: any): string => {
    const baseName = String((obj as any)?.layerName || obj?.name || obj?.type || 'objeto')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    return baseName || 'objeto';
};

const hasExportableSelectedObject = computed(() => !!resolveExportableSelectedObject());

const exportSelectedObject = async (
    format: 'png' | 'svg' | 'jpg' = 'png',
    targetObject?: any,
    options: { download?: boolean } = {}
): Promise<{ dataURL: string; fileName: string; format: 'png' | 'jpg' } | null> => {
    if (!canvas.value) return null;
    const active = resolveExportableSelectedObject(targetObject);
    if (!active) {
        notifyEditorInfo('Selecione um objeto válido para exportar.');
        return null;
    }

    const fileName = `objeto-${getSelectedObjectExportFileBaseName(active)}-${Date.now()}`;
    const shouldDownload = options.download !== false;

    if (format === 'svg') {
        const svgContent = active.toSVG();
        const blob = new Blob([svgContent], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        if (shouldDownload) downloadFile(url, `${fileName}.svg`);
        return null;
    }

    if (active.clipPath && !isValidClipPath(active.clipPath)) {
        console.warn('[Export Selected] Limpando clipPath inválido do objeto selecionado');
        active.set('clipPath', null);
    }

    let dataURL = '';
    try {
        dataURL = await runWithNeutralViewport(async () => (
            active.toDataURL({
                format,
                quality: 1,
                multiplier: HIGH_RES_EXPORT_SCALE
            })
        ));
    } catch (exportErr) {
        console.error('[Export Selected] Erro ao exportar objeto:', exportErr);
        try {
            active.set('clipPath', null);
            dataURL = await runWithNeutralViewport(async () => (
                active.toDataURL({
                    format,
                    quality: 1,
                    multiplier: HIGH_RES_EXPORT_SCALE
                })
            ));
        } catch (fallbackErr) {
            console.error('[Export Selected] Falha definitiva:', fallbackErr);
            notifyEditorError('Erro ao exportar objeto. Tente novamente.');
            return null;
        }
    }

    dataURL = await makeExportColorsVivid(
        dataURL,
        format === 'jpg' ? 'jpg' : 'png',
        HIGH_RES_EXPORT_QUALITY
    );

    if (shouldDownload) {
        downloadFile(dataURL, `${fileName}.${format}`);
    }

    return { dataURL, fileName, format };
}

const makeExportColorsVivid = async (
    dataUrl: string,
    format: 'png' | 'jpg' | 'jpeg',
    quality = HIGH_RES_EXPORT_QUALITY
): Promise<string> => {
    if (!dataUrl || typeof window === 'undefined') return dataUrl;

    return await new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            try {
                const width = Math.max(1, Number(img.naturalWidth || img.width || 1));
                const height = Math.max(1, Number(img.naturalHeight || img.height || 1));
                const out = document.createElement('canvas');
                out.width = width;
                out.height = height;
                const ctx = out.getContext('2d');
                if (!ctx) {
                    resolve(dataUrl);
                    return;
                }

                ctx.imageSmoothingEnabled = true;
                (ctx as any).imageSmoothingQuality = 'high';
                ctx.filter = `saturate(${EXPORT_COLOR_SATURATION}) contrast(${EXPORT_COLOR_CONTRAST}) brightness(${EXPORT_COLOR_BRIGHTNESS})`;
                ctx.drawImage(img, 0, 0, width, height);
                ctx.filter = 'none';

                const normalizedFormat = format === 'jpg' ? 'jpeg' : format;
                const mime = normalizedFormat === 'jpeg' ? 'image/jpeg' : 'image/png';
                const normalizedQuality = Math.max(0.9, Math.min(1, Number(quality) || 1));
                resolve(out.toDataURL(mime, normalizedQuality));
            } catch {
                resolve(dataUrl);
            }
        };
        img.onerror = () => resolve(dataUrl);
        img.src = dataUrl;
    });
};

const runWithNeutralViewport = async <T>(action: () => Promise<T> | T): Promise<T> => {
    if (!canvas.value) return await action();

    const c: any = canvas.value;
    const prevVpt = Array.isArray(c.viewportTransform) ? [...c.viewportTransform] : [1, 0, 0, 1, 0, 0];
    const prevRenderOnAddRemove = c.renderOnAddRemove;
    const prevSkipOffscreen = c.skipOffscreen;
    const cacheSnapshot = (c.getObjects?.() || []).map((obj: any) => ({
        obj,
        objectCaching: obj?.objectCaching,
        noScaleCache: obj?.noScaleCache,
        statefullCache: obj?.statefullCache
    }));

    try {
        c.renderOnAddRemove = false;
        c.skipOffscreen = false;
        cacheSnapshot.forEach((state: any) => {
            const obj = state?.obj;
            if (!obj) return;
            obj.objectCaching = false;
            obj.noScaleCache = false;
            obj.statefullCache = false;
            obj.dirty = true;
            obj.setCoords?.();
        });
        c.setViewportTransform([1, 0, 0, 1, 0, 0]);
        c.calcOffset?.();
        c.requestRenderAll?.();
        await new Promise(resolve => setTimeout(resolve, 0));
        return await action();
    } finally {
        c.setViewportTransform(prevVpt);
        c.renderOnAddRemove = prevRenderOnAddRemove;
        c.skipOffscreen = prevSkipOffscreen;
        cacheSnapshot.forEach((state: any) => {
            const obj = state?.obj;
            if (!obj) return;
            obj.objectCaching = state.objectCaching;
            obj.noScaleCache = state.noScaleCache;
            obj.statefullCache = state.statefullCache;
            obj.dirty = true;
            obj.setCoords?.();
        });
        c.calcOffset?.();
        c.requestRenderAll?.();
    }
};

const withProductZonesHiddenForOutput = async <T>(action: () => Promise<T> | T): Promise<T> => {
    if (!canvas.value) return await action();

    const zones = (canvas.value.getObjects() || []).filter((o: any) => isLikelyProductZone(o));
    if (!zones.length) return await action();

    const prevVisibility = zones.map((zone: any) => ({
        obj: zone,
        visible: zone?.visible !== false
    }));

    // IMPORTANT: call Fabric methods through the instance (`obj.set(...)`), never detached.
    // Detached method refs lose `this` and crash on internal `_set`.
    zones.forEach((zone: any) => {
        zone?.set?.('visible', false);
        zone?.setCoords?.();
    });
    canvas.value.requestRenderAll?.();
    await new Promise(resolve => setTimeout(resolve, 0));

    try {
        return await action();
    } finally {
        prevVisibility.forEach(({ obj, visible }: any) => {
            obj?.set?.('visible', visible);
            obj?.setCoords?.();
        });
        canvas.value.requestRenderAll?.();
        await new Promise(resolve => setTimeout(resolve, 0));
    }
};

// --- Frame Export Functions ---

// Export a single frame as an image
const exportSingleFrame = async (frame: any, format: 'png' | 'jpg' = 'png', scale: number = 1, quality: number = 0.9) => {
    if (!canvas.value || !frame) return null;

    const frameName = getFrameDisplayNameForExport(frame, 0).replace(/[^a-z0-9]/gi, '-').toLowerCase() || 'frame';
    const fileName = `frame-${frameName}-${Date.now()}`;

    const bounds = getFrameBounds(frame);
    if (!bounds) return null;

    // Create a data URL for the frame area
    let dataURL = '';
    try {
        dataURL = await withProductZonesHiddenForOutput(async () => (
            await runWithNeutralViewport(async () => {
                sanitizeAllClipPaths();
                const options: any = {
                    format: format,
                    quality: quality,
                    multiplier: Math.max(1, Number(scale) || 1),
                    left: bounds.left,
                    top: bounds.top,
                    width: Math.max(1, bounds.width),
                    height: Math.max(1, bounds.height),
                    ...(format === 'jpg' ? { backgroundColor: '#ffffff' } : {})
                };
                return canvas.value.toDataURL(options);
            })
        ));
    } catch (err) {
        console.warn('[Export Frame] Primeira tentativa falhou, tentando fallback:', err);
        try {
            dataURL = await withProductZonesHiddenForOutput(async () => (
                await runWithNeutralViewport(async () => {
                    return canvas.value.toDataURL({
                        format: format,
                        quality: quality,
                        multiplier: Math.max(1, Number(scale) || 1),
                        left: bounds.left,
                        top: bounds.top,
                        width: Math.max(1, bounds.width),
                        height: Math.max(1, bounds.height),
                        ...(format === 'jpg' ? { backgroundColor: '#ffffff' } : {})
                    });
                })
            ));
        } catch (fallbackErr) {
            console.error('[Export Frame] Error:', fallbackErr);
            return null;
        }
    }

    dataURL = await makeExportColorsVivid(dataURL, format, quality);

    return { dataURL, fileName };
}

// Export all frames as separate files
const exportAllFrames = async (format: 'png' | 'jpg' = 'png', scale: number = 1, quality: number = 0.9) => {
    const frames = getAllFrames();
    if (!frames.length) {
        notifyEditorInfo('Nenhum frame encontrado para exportar.');
        return [];
    }

    const exports: { dataURL: string; fileName: string }[] = [];

    for (const frame of frames) {
        const result = await exportSingleFrame(frame, format, scale, quality);
        if (result) {
            exports.push(result);
        }
    }

    return exports;
}

// Updated performExport with frame selection and sharing
const performExport = async () => {
    if (!canvas.value) return;
    const feedbackToken = startExportDownloadFeedback('Baixando arquivo...')
    showExportModal.value = false;

    try {
        const activeBeforeExport = canvas.value.getActiveObject?.();
        // Deselect for clean export
        canvas.value.discardActiveObject();
        canvas.value.requestRenderAll();

        const { format, exportScope, selectedFrameId } = exportSettings.value;
        const scale = HIGH_RES_EXPORT_SCALE;
        const quality = HIGH_RES_EXPORT_QUALITY;
        const imgFormat: 'png' | 'jpg' = (format === 'jpeg' || format === 'jpg') ? 'jpg' : 'png';
        const frameFormat: 'png' | 'jpg' = imgFormat === 'jpg' ? 'jpg' : 'png';

        if (exportScope === 'selected-object') {
            const objectResult = await exportSelectedObject(frameFormat, activeBeforeExport, { download: true });
            if (!objectResult) {
                notifyEditorInfo('Selecione um objeto válido para exportar.');
            }
        }
        else if (exportScope === 'selected-frame') {
            if (!selectedFrameId) {
                notifyEditorInfo('Selecione um frame para exportar.');
                return;
            }
            const frame = getFrameById(selectedFrameId);
            if (!frame) {
                notifyEditorInfo('Frame selecionado não encontrado no canvas.');
                return;
            }
            const result = await exportSingleFrame(frame, frameFormat, scale, quality);
            if (result) {
                downloadFile(result.dataURL, `${result.fileName}.${frameFormat}`);
            }
        }
        else if (exportScope === 'all-frames') {
            const frames = getAllFrames();
            if (frames.length > 0) {
                const frameExports = await exportAllFrames(frameFormat, scale, quality);
                const filesToDownload = frameExports.map(e => ({
                    dataURL: e.dataURL,
                    fileName: e.fileName,
                    format: frameFormat
                }));
                await downloadMultipleFiles(filesToDownload);
            } else {
                notifyEditorInfo('Nenhum frame encontrado no canvas.');
            }
        }
        else {
            notifyEditorInfo('Selecione: objeto, frame ou todos os frames para exportar.');
        }
    } finally {
        await stopExportDownloadFeedback(feedbackToken)
    }
}

// --- Share Modal Functions ---

const shareDesign = () => {
    if (shareSettings.value.format !== 'png' && shareSettings.value.format !== 'jpeg') {
        shareSettings.value.format = 'png';
    }
    shareSettings.value.scale = HIGH_RES_EXPORT_SCALE;
    shareSettings.value.quality = HIGH_RES_EXPORT_QUALITY;
    if (hasExportableSelectedObject.value) {
        shareSettings.value.shareScope = 'selected-object';
    } else {
        const firstFrameId = String(availableFramesForExport.value[0]?.id || '');
        shareSettings.value.shareScope = 'selected-frame';
        if (firstFrameId && shareSettings.value.selectedFrameIds.length === 0) {
            shareSettings.value.selectedFrameIds = [firstFrameId];
        }
        shareSettings.value.selectedFrameId = shareSettings.value.selectedFrameIds[0] || firstFrameId;
    }
    showShareModal.value = true;
}

const shareSettings = ref({
    format: 'png',
    scale: HIGH_RES_EXPORT_SCALE,
    quality: HIGH_RES_EXPORT_QUALITY,
    shareScope: 'selected-frame', // 'selected-object' | 'selected-frame' | 'all-frames'
    selectedFrameId: '',
    selectedFrameIds: [] as string[],
    shareAsFiles: true // Share as files or use link sharing
})

watch(availableFramesForExport, (frames) => {
    const ids = new Set(frames.map((f: any) => String(f.id || '').trim()).filter(Boolean));
    const firstId = frames[0]?.id || '';

    // Export modal selection
    if (exportSettings.value.selectedFrameId && !ids.has(String(exportSettings.value.selectedFrameId))) {
        exportSettings.value.selectedFrameId = '';
    }
    if (exportSettings.value.exportScope === 'selected-frame' && !exportSettings.value.selectedFrameId) {
        exportSettings.value.selectedFrameId = firstId;
    }

    // Share modal selections
    const filteredShareIds = (shareSettings.value.selectedFrameIds || []).filter((id: string) => ids.has(String(id || '').trim()));
    if (filteredShareIds.length !== shareSettings.value.selectedFrameIds.length) {
        shareSettings.value.selectedFrameIds = filteredShareIds;
    }
    if (shareSettings.value.selectedFrameId && !ids.has(String(shareSettings.value.selectedFrameId))) {
        shareSettings.value.selectedFrameId = '';
    }
    if (shareSettings.value.shareScope === 'selected-frame') {
        if (shareSettings.value.selectedFrameIds.length === 0 && firstId) {
            shareSettings.value.selectedFrameIds = [firstId];
        }
        if (!shareSettings.value.selectedFrameId) {
            shareSettings.value.selectedFrameId = shareSettings.value.selectedFrameIds[0] || firstId || '';
        }
    }
}, { immediate: true });

const toggleFrameSelection = (frameId: string) => {
    const idx = shareSettings.value.selectedFrameIds.indexOf(frameId)
    if (idx >= 0) {
        shareSettings.value.selectedFrameIds.splice(idx, 1)
    } else {
        shareSettings.value.selectedFrameIds.push(frameId)
    }
    // Keep legacy field in sync (first selected)
    shareSettings.value.selectedFrameId = shareSettings.value.selectedFrameIds[0] || ''
}

const selectAllFrames = () => {
    const all = availableFramesForExport.value.map((f: any) => f.id)
    if (shareSettings.value.selectedFrameIds.length === all.length) {
        shareSettings.value.selectedFrameIds = []
        shareSettings.value.selectedFrameId = ''
    } else {
        shareSettings.value.selectedFrameIds = [...all]
        shareSettings.value.selectedFrameId = all[0] || ''
    }
}

const performShare = async () => {
    if (!canvas.value) return;
    const feedbackToken = startExportDownloadFeedback('Baixando arquivo...')
    showShareModal.value = false;

    try {
        const activeBeforeShare = canvas.value.getActiveObject?.();
        // Deselect for clean export
        canvas.value.discardActiveObject();
        canvas.value.requestRenderAll();

        const { format, shareScope } = shareSettings.value;
        const scale = HIGH_RES_EXPORT_SCALE;
        const quality = HIGH_RES_EXPORT_QUALITY;
        const imgFormat: 'png' | 'jpg' = (format === 'jpeg' || format === 'jpg') ? 'jpg' : 'png';
        const frameFormat: 'png' | 'jpg' = imgFormat === 'jpg' ? 'jpg' : 'png';

        if (shareScope === 'selected-object') {
            const objectResult = await exportSelectedObject(frameFormat, activeBeforeShare, { download: false });
            if (!objectResult) {
                notifyEditorInfo('Selecione um objeto válido para exportar.');
                return;
            }
            const extension = objectResult.format === 'jpg' ? 'jpg' : 'png';
            const finalName = `${objectResult.fileName}.${extension}`;
            const shared = await shareFileFromDataUrl(objectResult.dataURL, finalName, 'Objeto selecionado');
            if (!shared) {
                downloadFile(objectResult.dataURL, finalName);
            }
        }
        else if (shareScope === 'selected-frame') {
            const frameIds = shareSettings.value.selectedFrameIds;
            if (!frameIds.length) {
                notifyEditorInfo('Selecione ao menos um frame para compartilhar.');
                return;
            }
            if (frameIds.length === 1) {
                const frame = getFrameById(frameIds[0] as string);
                if (!frame) {
                    notifyEditorInfo('Frame selecionado não encontrado no canvas.');
                    return;
                }
                const result = await exportSingleFrame(frame, frameFormat, scale, quality);
                if (result) {
                    const shared = await shareFileFromDataUrl(result.dataURL, `${result.fileName}.${frameFormat}`, (frame.layerName || frame.name || 'Frame'));
                    if (!shared) {
                        downloadFile(result.dataURL, `${result.fileName}.${frameFormat}`);
                    }
                }
            } else {
                // Multiple frames selected - download all
                const results = [];
                for (const fid of frameIds) {
                    const frame = getFrameById(fid);
                    if (frame) {
                        const result = await exportSingleFrame(frame, frameFormat, scale, quality);
                        if (result) results.push({ dataURL: result.dataURL, fileName: result.fileName, format: frameFormat });
                    }
                }
                if (results.length > 0) {
                    await downloadMultipleFiles(results);
                } else {
                    notifyEditorInfo('Nenhum frame selecionado foi encontrado no canvas.');
                }
            }
        }
        else if (shareScope === 'all-frames') {
            const frames = getAllFrames();
            if (frames.length > 0) {
                if (frames.length === 1) {
                    const result = await exportSingleFrame(frames[0], frameFormat, scale, quality);
                    if (result) {
                        const shared = await shareFileFromDataUrl(result.dataURL, `${result.fileName}.${frameFormat}`, 'All Frames');
                        if (!shared) {
                            downloadFile(result.dataURL, `${result.fileName}.${frameFormat}`);
                        }
                    }
                } else {
                    // For multiple files, we need to download them (Web Share API only supports single file)
                    notifyEditorInfo('Compartilhamento nativo suporta apenas um arquivo por vez. Os arquivos serão baixados.');
                    const frameExports = await exportAllFrames(frameFormat, scale, quality);
                    const filesToDownload = frameExports.map(e => ({
                        dataURL: e.dataURL,
                        fileName: e.fileName,
                        format: frameFormat
                    }));
                    await downloadMultipleFiles(filesToDownload);
                }
            } else {
                notifyEditorInfo('Nenhum frame encontrado no canvas.');
            }
        }
        else {
            notifyEditorInfo('Selecione: objeto, frame ou todos os frames para exportar.');
        }
    } finally {
        await stopExportDownloadFeedback(feedbackToken)
    }
}

// --- Project Manager Helpers ---
const saveProject = async () => {
    if (!canvas.value) return;
    const json = canvas.value.toJSON([...CANVAS_CUSTOM_PROPS, 'data']);
    (json as any)[LABEL_TEMPLATES_JSON_KEY] = serializeLabelTemplatesForProject();
    updatePageData(project.activePageIndex, json);
    
    // Persist to DB
    await saveProjectDB();
    
    showSaveModal.value = false;
    console.log('Project saved to database');
}

const loadCanvasData = async (data: any) => {
    if (!canvas.value) return;

    // Novo fluxo: carregamento de projeto completo deve acontecer pelo pipeline
    // principal (route + useProject.loadProjectDB). Isso evita corrida com o watch(activePage).
    if (data?.id && data?.canvas_data) {
        const incomingId = String(data.id || '').trim()
        if (incomingId && incomingId !== String(project.id || '').trim()) {
            await navigateTo(`/editor/${incomingId}`)
        }
        return
    }
    
    // Handle full project object (from DB) or just JSON (dnd/legacy)
    let json = data;

    if (!json) return;
    
    // CRITICAL: Ensure canvas is fully initialized before loading
    if (!canvas.value || !canvas.value.getContext) {
        console.warn('⚠️ Canvas não inicializado em loadCanvasData, aguardando...');
        await new Promise(resolve => setTimeout(resolve, 100));
        if (!canvas.value || !canvas.value.getContext) {
            console.error('❌ Canvas não está inicializado com contexto');
            return;
        }
    }
    
    // Normalize image URLs to same-origin proxy (Wasabi/Contabo) before load.
    json = prepareCanvasDataForLoad(json);

    isHistoryProcessing.value = true;
    hydrateLabelTemplatesFromProjectJson(json);
    
    try {
        await loadFromJsonSafe(json);
    } catch (loadErr) {
        console.error('❌ Erro ao carregar JSON no canvas:', loadErr);
        // Fallback rápido: substitui remotas por placeholder para preservar layout e evitar retries caros.
        try {
            const safeJson = replaceContaboImagesWithPlaceholder(json);
            await loadFromJsonSafe(safeJson);
            console.log('✅ loadFromJSON concluído com placeholders (fallback legacy-import)');
        } catch (finalErr) {
            console.error('❌ Erro final ao carregar:', finalErr);
            isHistoryProcessing.value = false;
            throw finalErr;
        }
    }
    
    // Remove old frame label text objects (if any were saved)
    // IMPORTANT: Preserve order by removing from end
    const objects = canvas.value.getObjects();
    const labelsToRemove: any[] = [];
    // Iterate in reverse to mark for removal from end
    for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj.isFrameLabel || (obj.type === 'text' && obj.text && obj.text.includes('@') && obj.text.includes('dpi'))) {
            labelsToRemove.push(obj);
        }
    }
    // Remove from end to preserve order
    labelsToRemove.forEach((obj: any) => {
        try {
            canvas.value.remove(obj);
        } catch (e) {
            // Ignore errors
        }
    });
    
    // CRITICAL: Remove any duplicate objects BEFORE rehydration
    const allObjsBefore = canvas.value.getObjects();
    const seenIds = new Set<string>();
    const duplicates: any[] = [];
    allObjsBefore.forEach((obj: any) => {
        const id = obj._customId || obj.id;
        if (id && seenIds.has(id)) {
            duplicates.push(obj);
        } else if (id) {
            seenIds.add(id);
        }
    });
    if (duplicates.length > 0) {
        console.warn(`⚠️ Removendo ${duplicates.length} objeto(s) duplicado(s) após loadFromJSON`);
        duplicates.forEach(dup => canvas.value.remove(dup));
    }
    
    // NOTE: Removed problematic code that was deleting frames with blue stroke
    // before rehydrateCanvasZones could restore their isFrame flag.
    // This was causing frames to be removed and re-added at the end, changing layer order.
    
    rehydrateCanvasZones();
    
    // CRITICAL: Remove any artboard-bg that might have been incorrectly created from a Frame
    const artboard = canvas.value.getObjects().find((o: any) => o.id === 'artboard-bg');
    if (artboard && (artboard.isFrame || artboard.clipContent || artboard.selectable)) {
        console.warn('⚠️ Removendo artboard-bg incorreto (era um Frame)');
        canvas.value.remove(artboard);
    }
    
    // NOTE: Legacy repair for product cards is handled inside `rehydrateCanvasZones()`.
    // Do not disable child interactivity here, otherwise deep-select (dblclick) stops working.
    
    canvas.value.requestRenderAll();
    // Update CanvasObjects
    const objs = canvas.value.getObjects();
    refreshCanvasObjects({ source: objs, immediate: true }); 
    isHistoryProcessing.value = false;
    historyStack.value = [];
    historyIndex.value = -1;
    saveCurrentState({ reason: 'legacy-import-load', source: 'system', skipIfUnchanged: true });
}

const generateFlyerWithAI = async (payload: {
    mode: 'replace' | 'newPage'
    pageType: 'RETAIL_OFFER' | 'FREE_DESIGN'
    pageWidth: number
    pageHeight: number
    referenceImageDataUrl?: string | null
    cloneStrength?: number
}) => {
    const prompt = String(aiPrompt.value || '').trim()
    const referenceImageDataUrl = String(
        payload?.referenceImageDataUrl || aiReferenceImageDataUrl.value || ''
    ).trim()
    if (!prompt && !referenceImageDataUrl) {
        pushAiToast('error', 'Informe o tema/estilo ou envie uma imagem para clonar.')
        return
    }

    const width = Math.max(64, Math.round(Number(payload?.pageWidth || aiPageWidth.value || 1080)))
    const height = Math.max(64, Math.round(Number(payload?.pageHeight || aiPageHeight.value || 1920)))
    const mode = payload?.mode || aiApplyMode.value
    const pageType = payload?.pageType || aiPageType.value

    isProcessing.value = true
    try {
        const result = await applyAiToPage({
            projectId: String(project.id || ''),
            pageId: mode === 'replace' ? String(activePage.value?.id || '') : null,
            mode,
            prompt,
            options: {
                pageType,
                size: { width, height },
                referenceImageDataUrl: referenceImageDataUrl || null,
                cloneStrength: referenceImageDataUrl ? Math.max(0, Math.min(100, Number(payload?.cloneStrength ?? 100))) : undefined
            }
        })

        // Force reload when replacing the current page object reference.
        pageReloadToken.value++
        showAIModal.value = false
        aiReferenceImageDataUrl.value = null
        pushAiToast('success', mode === 'newPage' ? 'Página com IA criada com sucesso.' : 'Página atual atualizada com IA.')
        console.log('[ai] Página gerada:', result)
    } catch (err: any) {
        console.error('[ai] Falha ao gerar página:', err)
        const message = String(err?.data?.statusMessage || err?.statusMessage || err?.message || 'Erro ao gerar página com IA.')
        pushAiToast('error', message)
    } finally {
        isProcessing.value = false
    }
}

// Helper: Get Center of current Viewport
const getCenterOfView = () => {
    if (!canvas.value) return { x: 0, y: 0 };
    const vpt = canvas.value.viewportTransform;
    const zoom = canvas.value.getZoom?.() || 1;
    const width = canvas.value.getWidth?.() || 0;
    const height = canvas.value.getHeight?.() || 0;
    if (!vpt || !Array.isArray(vpt) || vpt.length < 6 || !width || !height) {
        // Fallback: treat origin as the center for empty/initial canvas.
        return { x: 0, y: 0 };
    }

    // Convert screen center to world (canvas) coordinates.
    // screen = world * zoom + translate  =>  world = (screen - translate) / zoom
    return {
        x: (width / 2 - vpt[4]) / zoom,
        y: (height / 2 - vpt[5]) / zoom
    };
}

const { uploadFile } = useUpload()

const insertAssetToCanvas = async (asset: any, opts?: { pos?: { x: number; y: number } }) => {
    if (!canvas.value || !fabric) return;
    if (!asset?.url) return;

    try {
        // Se houver um card de produto selecionado dentro da zona de produtos,
        // aplicar a imagem diretamente no card (em vez de inserir solta no canvas).
        // Mantemos o fluxo de canvas quando há posição explícita (import em lote/spread).
        const shouldAutoPlaceInSelectedCard = !opts?.pos;
        if (shouldAutoPlaceInSelectedCard) {
            const active = canvas.value.getActiveObject?.();
            const ctx = resolveSelectedProductCardContext(active);
            const card = ctx?.card;
            const image = ctx?.image;
            const cardInZone = !!(card && hasParentZoneBinding(card));

            if (card && cardInZone) {
                if (image && String((image as any).type || '').toLowerCase() === 'image') {
                    if (!(image as any)._customId) (image as any)._customId = makeCanvasObjectId();
                    const replaced = await replaceImageByCustomId(String((image as any)._customId), asset.url, {
                        save: true,
                        setActive: true
                    });
                    if (replaced) return;
                }

                const added = await addImageToProductCardByUrl(card, asset.url, {
                    save: true,
                    setActive: true
                });
                if (added) return;
            }
        }

        const center = opts?.pos ?? getCenterOfView();
        const proxiedUrl = toWasabiProxyUrl(asset.url, { version: asset?.lastModified || asset?.updatedAt || null }) || asset.url;
        const img: any = await fabric.Image.fromURL(proxiedUrl, { crossOrigin: 'anonymous' });

        const pageW = activePage.value?.width || 1080;
        const pageH = activePage.value?.height || 1920;
        const maxW = pageW * 0.55;
        const maxH = pageH * 0.55;
        const iw = img.width || 1;
        const ih = img.height || 1;
        const scale = Math.min(maxW / iw, maxH / ih, 1);

        img.set({
            left: center.x,
            top: center.y,
            originX: 'center',
            originY: 'center',
            scaleX: scale,
            scaleY: scale,
            name: (asset.name || 'Imagem').toString(),
            selectable: true,
            evented: true
        });
        (img as any)._customId = Math.random().toString(36).substr(2, 9);

        canvas.value.add(img);
        // Keep the new asset visible above the page/frame.
        const c: any = canvas.value as any;
        if (typeof c.bringObjectToFront === 'function') c.bringObjectToFront(img);
        else if (typeof c.bringToFront === 'function') c.bringToFront(img);

        canvas.value.setActiveObject(img);
        canvas.value.requestRenderAll();
        saveCurrentState();
    } catch (e) {
        console.warn('[assets] Failed to insert asset to canvas', e);
    }
};

// ─── Insert Element from ElementsPanel ────────────────────────────────────
const insertElementToCanvas = (element: { type: string; data: any }) => {
    if (!canvas.value || !fabric) return;
    const { type, data } = element;

    if (type === 'shape') {
        // Reutiliza addShape existente, passando options customizadas
        addShape(data.shape, data.options || {});
    } else if (type === 'path') {
        // Cria fabric.Path a partir de pathData SVG
        try {
            const center = getCenterOfView();
            const pathObj: any = new fabric.Path(data.path, {
                fill: data.fill ?? '#cccccc',
                stroke: data.stroke ?? '#cccccc',
                strokeWidth: data.strokeWidth ?? 0,
                strokeUniform: true,
                strokeLineCap: data.strokeLineCap || 'butt',
                strokeLineJoin: data.strokeLineJoin || 'miter',
                fillRule: data.fillRule || 'nonzero',
                objectCaching: false,
                noScaleCache: true,
                statefullCache: false,
            });
            // Escalar para ~100px de largura mantendo proporção
            const bw = pathObj.width || 100;
            const bh = pathObj.height || 100;
            const targetSize = 120;
            const scale = targetSize / Math.max(bw, bh);
            pathObj.set({
                scaleX: scale,
                scaleY: scale,
                left: center.x,
                top: center.y,
                originX: 'center',
                originY: 'center',
            });
            pathObj._customId = Math.random().toString(36).substr(2, 9);
            canvas.value.add(pathObj);
            canvas.value.setActiveObject(pathObj);
            canvas.value.requestRenderAll();
            saveCurrentState();
        } catch (err) {
            console.warn('[elements] Failed to create path element', err);
        }
    } else if (type === 'frame') {
        // Cria frame com dimensões customizadas
        addFrame();
    } else if (type === 'grid') {
        // Cria grade de frames estilo Canva (cada célula é um Frame com clipPath)
        const cols = data.columns || 2;
        const rows = data.rows || 2;
        const gap = data.gap ?? 8;
        addGridFrames(cols, rows, gap);
    }
};

const findObjectByCustomId = (id: string): { obj: any; parent: any | null } | null => {
    if (!canvas.value || !id) return null;
    const walk = (node: any, parent: any | null): { obj: any; parent: any | null } | null => {
        if (!node) return null;
        if ((node as any)._customId === id) return { obj: node, parent };
        const t = String(node.type || '').toLowerCase();
        if (t === 'group' || t === 'activeselection') {
            const list = typeof node.getObjects === 'function' ? node.getObjects() : [];
            for (const child of (list || [])) {
                const found = walk(child, node);
                if (found) return found;
            }
        }
        return null;
    };
    for (const top of canvas.value.getObjects()) {
        const found = walk(top, null);
        if (found) return found;
    }
    return null;
};

const findProductCardByCustomId = (id: string): any | null => {
    const found = findObjectByCustomId(id);
    if (!found) return null;
    if (isProductCardContainer(found.obj) || isLikelyProductCard(found.obj)) return found.obj;
    if (found.parent && (isProductCardContainer(found.parent) || isLikelyProductCard(found.parent))) return found.parent;
    return null;
};

const addImageToProductCardByUrl = async (
    card: any,
    newUrl: string,
    opts: { save?: boolean; setActive?: boolean } = {}
) => {
    if (!canvas.value || !fabric || !card || !newUrl) return false;
    if (!isProductCardContainer(card) && !isLikelyProductCard(card)) return false;
    const shouldSave = opts.save !== false;
    const shouldSetActive = opts.setActive !== false;

    try {
        const proxiedUrl = toWasabiProxyUrl(newUrl) || newUrl;
        const newImg: any = await fabric.Image.fromURL(proxiedUrl, { crossOrigin: 'anonymous' });
        if (!newImg) return false;

        if ((newImg.width || 0) > 500) {
            newImg.scaleToWidth(500);
        }

        const existingProductImage = getPreferredProductImageFromGroup(card);
        const targetLeft = existingProductImage ? ((Number(existingProductImage.left) || 0) + 10) : 0;
        const targetTop = existingProductImage ? ((Number(existingProductImage.top) || 0) + 10) : 0;
        const targetCanvas = groupLocalToCanvasPoint(card, targetLeft, targetTop);
        const imageName = existingProductImage ? `extra_image_${Date.now()}` : 'smart_image';

        newImg.set({
            left: targetCanvas.x,
            top: targetCanvas.y,
            originX: 'center',
            originY: 'center',
            selectable: true,
            evented: true,
            hasControls: true,
            hasBorders: true,
            name: imageName,
            _customId: makeCanvasObjectId()
        });
        (newImg as any).src = newUrl;

        safeAddWithUpdate(card, newImg);
        card.set({ subTargetCheck: true, interactive: true });
        card.setCoords?.();
        card.dirty = true;

        if (!existingProductImage) {
            (card as any).imageUrl = newUrl;
            if ((card as any)._productData && typeof (card as any)._productData === 'object') {
                (card as any)._productData = {
                    ...(card as any)._productData,
                    imageUrl: newUrl,
                    image: newUrl
                };
            }
        }

        if (shouldSetActive) {
            canvas.value.setActiveObject(newImg);
        }
        canvas.value.requestRenderAll();
        refreshCanvasObjects();
        if (shouldSave) {
            saveCurrentState();
        }
        return true;
    } catch (e) {
        console.warn('[product-image] Falha ao adicionar imagem ao card:', e);
        return false;
    }
};

const replaceImageByCustomId = async (
    targetId: string,
    newUrl: string,
    opts: { save?: boolean; setActive?: boolean } = {}
): Promise<boolean> => {
    if (!canvas.value || !fabric || !targetId || !newUrl) return false;
    const shouldSave = opts.save !== false;
    const shouldSetActive = opts.setActive !== false;

    const found = findObjectByCustomId(targetId);
    if (!found) return false;

    const target = found.obj;
    if (String(target?.type || '').toLowerCase() !== 'image') return false;

    try {
        const oldDisplayW = Math.abs((target.width || 1) * (target.scaleX || 1));
        const oldDisplayH = Math.abs((target.height || 1) * (target.scaleY || 1));
        const proxiedNewUrl = toWasabiProxyUrl(newUrl) || newUrl;
        const newImg: any = await fabric.Image.fromURL(proxiedNewUrl, { crossOrigin: 'anonymous' });
        if (!newImg) return false;

        const newW = newImg.width || 1;
        const newH = newImg.height || 1;
        const newScaleX = oldDisplayW / newW;
        const newScaleY = oldDisplayH / newH;

        newImg.set({
            left: target.left,
            top: target.top,
            scaleX: newScaleX,
            scaleY: newScaleY,
            angle: target.angle || 0,
            originX: target.originX || 'center',
            originY: target.originY || 'center',
            name: (target as any).name,
            _customId: (target as any)._customId,
            opacity: (target as any).opacity,
            flipX: (target as any).flipX,
            flipY: (target as any).flipY,
            clipPath: (target as any).clipPath,
            filters: (target as any).filters
        });
        (newImg as any).src = newUrl;

        if (found.parent) {
            const parent = found.parent;
            const list = typeof parent.getObjects === 'function' ? parent.getObjects() : [];
            const idx = list.indexOf(target);
            parent.remove(target);
            if (typeof (parent as any).insertAt === 'function' && idx >= 0) (parent as any).insertAt(idx, newImg);
            else parent.add(newImg);
            safeAddWithUpdate(parent);
            parent.setCoords?.();

            if (isProductCardContainer(parent) || isLikelyProductCard(parent)) {
                (parent as any).imageUrl = newUrl;
                if ((parent as any)._productData && typeof (parent as any)._productData === 'object') {
                    (parent as any)._productData = {
                        ...(parent as any)._productData,
                        imageUrl: newUrl,
                        image: newUrl
                    };
                }
            }

            if (shouldSetActive) {
                canvas.value.setActiveObject(parent);
            }
        } else {
            const oldIndex = canvas.value.getObjects().indexOf(target);
            canvas.value.remove(target);
            if (oldIndex >= 0 && typeof (canvas.value as any).insertAt === 'function') {
                (canvas.value as any).insertAt(oldIndex, newImg);
            } else {
                canvas.value.add(newImg);
            }
            if (shouldSetActive) {
                canvas.value.setActiveObject(newImg);
            }
        }

        canvas.value.requestRenderAll();
        if (shouldSave) {
            saveCurrentState();
        }
        return true;
    } catch (e) {
        console.warn('[ai-studio] Falha ao substituir imagem:', e);
        return false;
    }
};

let missingProductImageRecoveryTimer: ReturnType<typeof setTimeout> | null = null;
let isRecoveringMissingProductImages = false;

const isLikelyPlaceholderImageSrc = (src: string): boolean => {
    const value = String(src || '').trim();
    if (!value) return true;
    return value === PLACEHOLDER_IMAGE_DATA_URL;
};

const getImageSourceFromObject = (img: any): string => {
    const direct = String((img as any)?.src || '').trim();
    if (direct) return direct;
    const fromGetter = typeof (img as any)?.getSrc === 'function' ? String((img as any).getSrc() || '').trim() : '';
    if (fromGetter) return fromGetter;
    const fromEl = String((img as any)?._element?.src || '').trim();
    return fromEl;
};

const normalizeRecoveryImageUrl = (src: string): string => {
    const value = String(src || '').trim();
    if (!value) return '';
    const proxied = toWasabiProxyUrl(value);
    if (proxied && proxied !== value) return proxied;
    if (value.includes('contabostorage.com')) {
        const { bucket, key } = extractContaboBucketAndKey(value);
        if (key) {
            if (bucket) {
                return `/api/storage/p?bucket=${encodeURIComponent(bucket)}&key=${encodeURIComponent(key)}`;
            }
            return `/api/storage/p?key=${encodeURIComponent(key)}`;
        }
    }
    return value;
};

const buildCardRecoverySearchPayload = (card: any): { term: string; brand?: string; flavor?: string; weight?: string } | null => {
    const pd = ((card as any)?._productData && typeof (card as any)._productData === 'object') ? (card as any)._productData : {};
    const titleObj = typeof getCardTitleText === 'function' ? getCardTitleText(card) : null;
    const titleText = String((titleObj as any)?.text || '').trim();
    const name = String(pd?.name || titleText || (card as any)?.layerName || '').trim();
    const brand = String(pd?.brand || '').trim();
    const flavor = String(pd?.flavor || '').trim();
    const weight = String(pd?.weight || '').trim();
    if (!name) return null;

    const parts = [name];
    if (brand && !name.toLowerCase().includes(brand.toLowerCase())) parts.push(brand);
    if (flavor && !name.toLowerCase().includes(flavor.toLowerCase())) parts.push(flavor);
    if (weight && !name.toLowerCase().includes(weight.toLowerCase())) parts.push(weight);

    const term = parts.join(' ').trim();
    if (!term) return null;
    return {
        term,
        ...(brand ? { brand } : {}),
        ...(flavor ? { flavor } : {}),
        ...(weight ? { weight } : {})
    };
};

type RecoveryLookupResult = {
    status: 'ok' | 'empty' | 'auth' | 'error';
    url: string | null;
};

const isAuthLookupError = (err: any): boolean => {
    const code = Number(err?.statusCode || err?.status || err?.response?.status || 0);
    if (code === 401 || code === 403) return true;
    const msg = String(err?.message || err || '').toLowerCase();
    if (!msg) return false;
    return msg.includes('sessão expirada') || msg.includes('session') || msg.includes('unauthorized') || msg.includes('forbidden');
};

const fetchRecoveryImageUrlForCard = async (card: any): Promise<RecoveryLookupResult> => {
    const payload = buildCardRecoverySearchPayload(card);
    if (!payload?.term) return { status: 'empty', url: null };

    try {
        const headers = await getApiAuthHeaders();
        const result = await $fetch<{ url?: string }>('/api/process-product-image', {
            method: 'POST',
            headers,
            // For product cards we want the API to return the cached bg-removed variant when possible.
            body: { ...payload, bgPolicy: 'always', strictMode: false }
        });
        const url = String(result?.url || '').trim();
        if (url) return { status: 'ok', url };
        return { status: 'empty', url: null };
    } catch (err) {
        if (isAuthLookupError(err)) {
            return { status: 'auth', url: null };
        }
        console.warn('[recover-missing-product-images] Falha ao buscar imagem por termo:', err);
        return { status: 'error', url: null };
    }
};

const fetchRecoveryImageUrlFromAssets = async (term: string): Promise<RecoveryLookupResult> => {
    const query = String(term || '').trim();
    if (!query) return { status: 'empty', url: null };
    try {
        const headers = await getApiAuthHeaders();
        const result = await $fetch<any>('/api/assets', {
            headers,
            query: {
                q: query,
                limit: 1
            }
        });
        if (Array.isArray(result) && result[0]?.url) {
            return { status: 'ok', url: String(result[0].url || '').trim() || null };
        }
        if (result && Array.isArray(result.items) && result.items[0]?.url) {
            return { status: 'ok', url: String(result.items[0].url || '').trim() || null };
        }
        return { status: 'empty', url: null };
    } catch (err) {
        console.warn('[recover-missing-product-images] Falha no fallback /api/assets:', err);
        return { status: 'error', url: null };
    }
};

const recoverMissingProductCardImages = async (): Promise<{ recoveredCount: number; pendingCount: number }> => {
    if (!canvas.value || isCanvasDestroyed.value || isRecoveringMissingProductImages) {
        return { recoveredCount: 0, pendingCount: 0 };
    }
    isRecoveringMissingProductImages = true;
    try {
        const cards = collectObjectsDeep(canvas.value)
            .filter((obj: any) => !!(obj?.type === 'group' && (obj?.isSmartObject || obj?.isProductCard || isLikelyProductCard(obj))));

        let recoveredCount = 0;
        let pendingCount = 0;
        let remoteLookupsLeft = 30;
        for (const card of cards) {
            const imageObj = getPreferredProductImageFromGroup(card);
            const hasImageObject = !!imageObj;

            let needsRecovery = !hasImageObject;
            if (imageObj) {
                const currentSrc = getImageSourceFromObject(imageObj);
                const hasBrokenSource = isLikelyPlaceholderImageSrc(currentSrc);
                const hasInvalidGeometry = !Number.isFinite(Number(imageObj.width)) || Number(imageObj.width) <= 0 || !Number.isFinite(Number(imageObj.height)) || Number(imageObj.height) <= 0;
                const imageEl: any = (imageObj as any)?._originalElement || (imageObj as any)?._element || null;
                const naturalW = Number(imageEl?.naturalWidth ?? imageEl?.width ?? 0);
                const naturalH = Number(imageEl?.naturalHeight ?? imageEl?.height ?? 0);
                const hasLikelyBrokenElement = Number.isFinite(naturalW) && Number.isFinite(naturalH) && naturalW <= 1 && naturalH <= 1;
                needsRecovery = hasBrokenSource || hasInvalidGeometry || hasLikelyBrokenElement;
            }
            if (!needsRecovery) continue;
            pendingCount += 1;

            const triedMap = (((card as any).__missingImageRecoveryTried && typeof (card as any).__missingImageRecoveryTried === 'object')
                ? (card as any).__missingImageRecoveryTried
                : {}) as Record<string, true>;
            (card as any).__missingImageRecoveryTried = triedMap;

            const rawCandidates = [
                String((card as any)?.imageUrl || '').trim(),
                String((card as any)?._productData?.imageUrl || '').trim(),
                String((card as any)?._productData?.image || '').trim(),
                String((imageObj as any)?.__originalSrc || '').trim(),
                String((imageObj as any)?.src || '').trim(),
                String((imageObj as any)?._element?.src || '').trim(),
                String((imageObj as any)?._originalElement?.src || '').trim(),
                String((imageObj as any)?._fallbackSrc || '').trim()
            ].filter(Boolean);
            const normalizedCandidates = Array.from(new Set(rawCandidates))
                .map((src) => normalizeRecoveryImageUrl(src))
                .filter((src) => !!src && !isLikelyPlaceholderImageSrc(src));

            const tryApplyImageUrl = async (url: string): Promise<boolean> => {
                if (!url) return false;
                if (triedMap[url]) return false;
                triedMap[url] = true;

                if (hasImageObject) {
                    if (!(imageObj as any)._customId) {
                        (imageObj as any)._customId = makeCanvasObjectId();
                    }
                    return await replaceImageByCustomId(String((imageObj as any)._customId), url, {
                        save: false,
                        setActive: false
                    });
                }
                return await addImageToProductCardByUrl(card, url, {
                    save: false,
                    setActive: false
                });
            };

            let restored = false;
            for (const candidate of normalizedCandidates) {
                restored = await tryApplyImageUrl(candidate);
                if (restored) break;
            }

            if (!restored && remoteLookupsLeft > 0 && !(card as any).__missingImageRemoteLookupDone) {
                remoteLookupsLeft -= 1;
                const fetchedResult = await fetchRecoveryImageUrlForCard(card);
                if (fetchedResult.url) {
                    const normalizedFetched = normalizeRecoveryImageUrl(fetchedResult.url);
                    restored = await tryApplyImageUrl(normalizedFetched);
                }
                const payload = buildCardRecoverySearchPayload(card);
                const assetsResult = !restored
                    ? await fetchRecoveryImageUrlFromAssets(String(payload?.term || ''))
                    : { status: 'empty', url: null as string | null };
                if (!restored) {
                    if (assetsResult.url) {
                        const normalizedAssetsUrl = normalizeRecoveryImageUrl(assetsResult.url);
                        restored = await tryApplyImageUrl(normalizedAssetsUrl);
                    }
                }

                // Só "congela" lookup remoto quando foi uma resposta determinística.
                // Em erro de auth/rede, mantém aberto para novo retry após sessão estabilizar.
                const retryableError =
                    fetchedResult.status === 'auth' ||
                    fetchedResult.status === 'error' ||
                    assetsResult.status === 'error';
                if (!retryableError) {
                    (card as any).__missingImageRemoteLookupDone = true;
                } else {
                    delete (card as any).__missingImageRemoteLookupDone;
                }
            }

            if (restored) {
                recoveredCount += 1;
                pendingCount = Math.max(0, pendingCount - 1);
            }
        }

        if (recoveredCount > 0 && canvas.value) {
            refreshCanvasObjects();
            safeRequestRenderAll();
            saveCurrentState({
                reason: 'recover-missing-product-images',
                source: 'system',
                skipIfUnchanged: true
            });
        }
        return { recoveredCount, pendingCount };
    } finally {
        isRecoveringMissingProductImages = false;
    }
};

const scheduleMissingProductImageRecovery = (delayMs = 140, retries = 6) => {
    if (isHistoryProcessing.value || isDesignLoading.value || isCanvasDestroyed.value) return;
    if (missingProductImageRecoveryTimer) {
        clearTimeout(missingProductImageRecoveryTimer);
    }
    missingProductImageRecoveryTimer = setTimeout(async () => {
        if (isHistoryProcessing.value || isDesignLoading.value || isCanvasDestroyed.value) {
            missingProductImageRecoveryTimer = null;
            return;
        }
        missingProductImageRecoveryTimer = null;
        const result = await recoverMissingProductCardImages();
        if (result && result.pendingCount > 0 && retries > 0) {
            scheduleMissingProductImageRecovery(900, retries - 1);
        }
    }, Math.max(0, Number(delayMs) || 0));
};

const handleAiStudioCreated = async (asset: { id: string; name: string; url: string }) => {
    if (!asset?.url) return;
    await refreshAiStudioUploads();

    const opts = aiStudio.options.value || {};
    if (opts.applyMode === 'replace' && opts.replaceTargetId) {
        await replaceImageByCustomId(String(opts.replaceTargetId), asset.url);
    } else {
        await insertAssetToCanvas(asset);
    }

    aiStudio.handleCreated(asset);
    aiStudio.open.value = false;
};

const clearPendingProductImageOperation = () => {
    pendingLocalImageActionMode.value = null;
    pendingImageReplaceTargetId.value = null;
    pendingImageAddCardId.value = null;
    productImagePickerTargetImageId.value = null;
    productImagePickerTargetCardId.value = null;
};

const openLocalProductImagePicker = (mode: 'replace' | 'add', opts: { imageId?: string | null; cardId?: string | null } = {}) => {
    pendingLocalImageActionMode.value = mode;
    pendingImageReplaceTargetId.value = mode === 'replace' ? (opts.imageId || null) : null;
    pendingImageAddCardId.value = mode === 'add' ? (opts.cardId || null) : null;
    if (fileInput.value) {
        fileInput.value.value = '';
        fileInput.value.click();
    }
};

const openProductImageUploadPickerModal = async (
    mode: 'replace' | 'add',
    opts: { imageId?: string | null; cardId?: string | null } = {}
) => {
    productImagePickerMode.value = mode;
    productImagePickerTargetImageId.value = mode === 'replace' ? (opts.imageId || null) : null;
    productImagePickerTargetCardId.value = mode === 'add' ? (opts.cardId || null) : null;
    productImagePickerSearch.value = '';
    showProductImageUploadPicker.value = true;
    await refreshAiStudioUploads();
};

const applyProductImageFromUploadPicker = async (asset: { id?: string; name?: string; url: string }) => {
    if (!asset?.url) return;

    try {
        if (productImagePickerMode.value === 'replace' && productImagePickerTargetImageId.value) {
            await replaceImageByCustomId(productImagePickerTargetImageId.value, asset.url);
        } else if (productImagePickerMode.value === 'add' && productImagePickerTargetCardId.value) {
            const targetCard = findProductCardByCustomId(productImagePickerTargetCardId.value);
            if (!targetCard) {
                notifyEditorError('Card de produto não encontrado.');
                return;
            }
            await addImageToProductCardByUrl(targetCard, asset.url);
        }
    } finally {
        showProductImageUploadPicker.value = false;
        clearPendingProductImageOperation();
    }
};

const handlePaste = async (e: ClipboardEvent) => {
    if (!e.clipboardData || !canvas.value) return;
    const items = e.clipboardData.items;

    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (!item) continue;
        
        if (item.type.indexOf('image') !== -1) {
            e.preventDefault(); 
            const file = item.getAsFile();
            if (file) {
                 try {
                     const result = await uploadFile(file);
                     if (result.success) {
                         const pasteProxyUrl = toWasabiProxyUrl(result.url) || result.url;
                         const img = await fabric.Image.fromURL(pasteProxyUrl, { crossOrigin: 'anonymous' });
                         if (img) {
                             // Scale down if huge
                             if (img.width > 500) {
                                 img.scaleToWidth(500);
                             }
                             
                             (img as any)._customId = Math.random().toString(36).substr(2, 9);
                             
                             // Check if there's a product card group selected to paste INTO
                             const activeObj = canvas.value.getActiveObject();
                             let targetProductCard = null;
                             
                             // Check if active object is a product card
                             if (activeObj && activeObj.type === 'group' && 
                                 (activeObj.isSmartObject || activeObj.isProductCard || isLikelyProductCard(activeObj))) {
                                 targetProductCard = activeObj;
                             }
                             // Check if active object is an image inside a product card
                             else if (activeObj && String(activeObj.type || '').toLowerCase() === 'image') {
                                 const allObjects = canvas.value.getObjects();
                                 for (const obj of allObjects) {
                                     if (obj.type === 'group' && (obj.isSmartObject || obj.isProductCard || isLikelyProductCard(obj))) {
                                         if (typeof obj.getObjects === 'function') {
                                             const children = obj.getObjects();
                                             const containsImage = children.some((child: any) => 
                                                 child === activeObj || child._customId === activeObj._customId
                                             );
                                             if (containsImage) {
                                                 targetProductCard = obj;
                                                 break;
                                             }
                                         }
                                     }
                                 }
                             }
                             // Check via .group property
                             else if (activeObj && (activeObj as any).group) {
                                 const parentGroup = (activeObj as any).group;
                                 if (parentGroup.isSmartObject || parentGroup.isProductCard || isLikelyProductCard(parentGroup)) {
                                     targetProductCard = parentGroup;
                                 }
                             }
                             
                             if (targetProductCard) {
                                 // Paste inside the product card
                                 console.log('📦 [handlePaste] Pasting image into product card:', targetProductCard._customId || targetProductCard.name);
                                 
                                 // Find existing product image to position relative to it
                                 const groupChildren = typeof targetProductCard.getObjects === 'function' 
                                     ? targetProductCard.getObjects() 
                                     : [];
                                 
                                 const existingProductImage = groupChildren.find((child: any) => 
                                     String(child.type || '').toLowerCase() === 'image' &&
                                     (child.name === 'smart_image' || child.name === 'product_image' || child.name === 'productImage')
                                 ) || groupChildren.find((child: any) => String(child.type || '').toLowerCase() === 'image');
                                 
                                 // Position at same place as existing image (with small offset)
                                 let targetLeft = existingProductImage ? (Number(existingProductImage.left) || 0) + 10 : 0;
                                 let targetTop = existingProductImage ? (Number(existingProductImage.top) || 0) + 10 : 0;
                                 
                                 const targetCanvas = groupLocalToCanvasPoint(targetProductCard, targetLeft, targetTop);
                                 img.set({
                                     left: targetCanvas.x,
                                     top: targetCanvas.y,
                                     originX: 'center',
                                     originY: 'center',
                                     selectable: true,
                                     evented: true,
                                     hasControls: true,
                                     hasBorders: true,
                                 });

                                 // CRITICAL: Add via safeAddWithUpdate so the image enters the group coordinate system.
                                 safeAddWithUpdate(targetProductCard, img);
                                 
                                 // Ensure deep-select mode is active
                                 targetProductCard.set({ subTargetCheck: true, interactive: true });
                                 targetProductCard.setCoords?.();
                                 targetProductCard.dirty = true;
                                 
                                 canvas.value.setActiveObject(img);
                                 canvas.value.requestRenderAll();
                                 refreshCanvasObjects();
                                 saveCurrentState();
                             } else {
                                 // Regular paste to canvas center
                                 const center = getCenterOfView();
                                 img.set({
                                     left: center.x,
                                     top: center.y,
                                     originX: 'center',
                                     originY: 'center'
                                 });
                                 
                                 canvas.value.add(img);
                                 canvas.value.setActiveObject(img);
                                 canvas.value.requestRenderAll();
                                 saveCurrentState();
                             }
                         }
                     }
                 } catch (err) {
                     console.error("Paste upload failed", err);
                 }
            }
        }
    }
}

onMounted(() => {
    window.addEventListener('paste', handlePaste);
})

onUnmounted(() => {
    window.removeEventListener('paste', handlePaste);
})

const addShape = (type: 'rect' | 'circle' | 'triangle' | 'star' | 'polygon' | 'line' | 'arrow' | 'ellipse', options: any = {}) => {
    if (!canvas.value) return;
    let shape;
    const center = getCenterOfView();
    const opts = { left: center.x - 50, top: center.y - 50, fill: '#cccccc', stroke: '#cccccc', strokeWidth: 2, objectCaching: false, noScaleCache: true, statefullCache: false, strokeUniform: true, ...options };

    if (type === 'rect') {
        shape = new fabric.Rect({ ...opts, width: 100, height: 100 });
    } else if (type === 'circle') {
        shape = new fabric.Circle({ ...opts, radius: 50 });
    } else if (type === 'ellipse') {
        shape = new fabric.Ellipse({ ...opts, rx: 75, ry: 50 });
    } else if (type === 'triangle') {
        shape = new fabric.Triangle({ ...opts, width: 100, height: 100 });
    } else if (type === 'polygon') {
        const points = opts.points || [
            { x: 50, y: 0 }, { x: 100, y: 38 }, { x: 82, y: 100 }, 
            { x: 18, y: 100 }, { x: 0, y: 38 }
        ];
        const { points: _pts, ...polygonOpts } = opts;
        shape = new fabric.Polygon(points, polygonOpts);
    } else if (type === 'star') {
        const points = opts.points || [
            {x: 50, y: 0}, {x: 61, y: 35}, {x: 98, y: 35}, {x: 68, y: 57}, 
            {x: 79, y: 91}, {x: 50, y: 70}, {x: 21, y: 91}, {x: 32, y: 57}, 
            {x: 2, y: 35}, {x: 39, y: 35}
        ];
        const { points: _pts, ...starOpts } = opts;
        shape = new fabric.Polygon(points, starOpts);
    } else if (type === 'line') {
        const coords = opts.coords || [0, 0, 200, 0];
        const { coords: _c, ...lineOpts } = opts;
        shape = new fabric.Line(coords, { ...lineOpts, left: center.x - 100, top: center.y });
    } else if (type === 'arrow') {
        // Simple arrow using Path
        const path = 'M 0 0 L 200 0 M 200 0 L 180 -10 M 200 0 L 180 10';
        shape = new fabric.Path(path, { ...opts, fill: 'transparent', stroke: '#cccccc', strokeWidth: 4, left: center.x - 100, top: center.y });
    }
    
    if (shape) {
        (shape as any)._customId = Math.random().toString(36).substr(2, 9);
        canvas.value.add(shape);
        canvas.value.setActiveObject(shape);
        canvas.value.requestRenderAll();
        saveCurrentState();
    }
}

const addHighlight = () => {
    if (!canvas.value) return; 
    const center = getCenterOfView();

    const circle = new fabric.Circle({
        radius: 40,
        fill: '#ff0000',
        stroke: '#ffffff',
        strokeWidth: 4,
        originX: 'center',
        originY: 'center',
    });

    const text = new fabric.IText('OFERTA', {
        fontSize: 14,
        fontWeight: 900,
        fill: '#ffffff',
        fontFamily: 'Inter',
        originX: 'center',
        originY: 'center',
    });

    const group = new fabric.Group([circle, text], {
        left: center.x - 40,
        top: center.y - 40,
        name: 'Selo de Oferta'
    });

    (group as any)._customId = Math.random().toString(36).substr(2, 9);
    canvas.value.add(group);
    canvas.value.setActiveObject(group);
    canvas.value.requestRenderAll();
    saveCurrentState();
}

const setPenWidth = (width: number) => {
    if (!canvas.value) return
    penStrokeWidth.value = width
    if (canvas.value.freeDrawingBrush) {
        canvas.value.freeDrawingBrush.width = width
    }
    if (isPenMode.value) {
        // Keep preview stroke in sync while drawing a vector path.
        if (currentPenPath.value) {
            currentPenPath.value.set({
                strokeWidth: getPenPreviewStrokeWidth()
            })
            currentPenPath.value.setCoords?.()
        }
        canvas.value.requestRenderAll()
    }
}

const addText = (variant: 'default' | 'heading' | 'body' = 'default') => {
    if (!canvas.value) return; 
    setTool('select'); // Ensure we exit drawing mode
    const center = getCenterOfView();
    
    const defaults = {
        default: { fontSize: 40, fontWeight: 'normal', text: 'Seu Texto' },
        heading: { fontSize: 60, fontWeight: 'bold', text: 'Heading' },
        body: { fontSize: 24, fontWeight: 'normal', text: 'Body text' }
    }

    const config = defaults[variant] || defaults.default
    
    const text = new fabric.IText(config.text, {
        left: center.x - 60, top: center.y - 20, // Approx centered text
        originX: 'center',
        originY: 'center',
        fontFamily: 'Arial',
        fill: '#333333',
        fontSize: config.fontSize,
        fontWeight: config.fontWeight,
        editable: true
    });
    
    (text as any)._customId = Math.random().toString(36).substr(2, 9);
    canvas.value.add(text);
    canvas.value.setActiveObject(text);
    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    saveCurrentState();
}

const clearCanvas = () => {
    if (!canvas.value) return;
    
    // Clear all objects but keep configuration
    canvas.value.clear();
    
    // ENSURE WORKSPACE IS DARK
    canvas.value.backgroundColor = '#1e1e1e';
    
    // Reset Data
    canvasObjects.value = [];
    selectedObjectId.value = null;
    selectedObjectIds.value = [];
    selectedObjectRef.value = null;
    
    // Restore Environment
    updateArtboard(); // Redraw white page
    setupSnapping();
    setupReactivity();
    
    saveCurrentState();
}

const extractLimitFromName = (rawName: any): { cleanedName: string; extractedLimit: string | null } => {
    const name = String(rawName ?? '').trim();
    if (!name) return { cleanedName: '', extractedLimit: null };

    const idx = name.toUpperCase().search(/\bLIMITE\b/);
    if (idx === -1) return { cleanedName: name, extractedLimit: null };

    const extractedLimit = name.slice(idx).trim();
    const cleanedName = name
        .slice(0, idx)
        .replace(/[-–—|:]+$/g, '')
        .trim();
    return { cleanedName: cleanedName || name, extractedLimit: extractedLimit || null };
};

const normalizeLimitText = (raw: any): string | null => {
    const s0 = String(raw ?? '').trim();
    if (!s0) return null;
    let s = s0.toUpperCase().replace(/\s+/g, ' ').trim();
    if (s === 'LIMITE') return null;
    if (!s.startsWith('LIMITE')) s = `LIMITE ${s}`.trim();
    // "3UN" -> "3 UN"
    s = s.replace(/(\d)(UN|KG)\b/g, '$1 $2');
    return s;
};

const stripAccents = (s: string) => s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');

const normalizeSpecialCondition = (raw: any): string | null => {
    const txt = String(raw ?? '').replace(/\s+/g, ' ').trim();
    if (!txt) return null;
    const cleaned = txt.replace(/^[\-:;,.\s]+/, '').replace(/[\-:;,.\s]+$/, '').trim();
    return cleaned || null;
};

const getSpecialConditionFromProduct = (product: any): string | null => {
    if (!product || typeof product !== 'object') return null;

    const directCandidates = [
        product.specialCondition,
        product.condition,
        product.observation,
        product.observations,
        product.observacao,
        product.observacoes,
        product.obs
    ];

    for (const c of directCandidates) {
        const normalized = normalizeSpecialCondition(c);
        if (normalized) return normalized;
    }

    for (const [k, v] of Object.entries(product)) {
        const nk = stripAccents(String(k || '').toUpperCase());
        if (!nk) continue;
        if (!nk.includes('OBSERV') && !nk.includes('CONDI') && nk !== 'OBS') continue;
        const normalized = normalizeSpecialCondition(v);
        if (normalized) return normalized;
    }

    return null;
};

/**
 * Converte valor de preço para string no formato brasileiro (vírgula decimal)
 */
const formatPriceValue = (value: any): string => {
    if (value === null || value === undefined) return '';
    if (typeof value === 'number') {
        // Converter número para formato brasileiro (20.99 -> "20,99")
        return value.toFixed(2).replace('.', ',');
    }
    const str = String(value).trim();
    if (!str) return '';
    // Se já tem vírgula como separador decimal, usar como está
    if (str.includes(',')) return str;
    // Se tem ponto como separador decimal, converter para vírgula
    if (str.includes('.')) {
        const parts = str.split('.');
        if (parts.length === 2 && parts[1] && parts[1].length <= 2) {
            return str.replace('.', ',');
        }
    }
    return str;
};

/**
 * Retorna TODOS os preços disponíveis para o produto, ordenados por prioridade de exibição.
 * Retorna um objeto com informações dinâmicas baseadas no que realmente existe.
 */
const getAvailablePrices = (product: any) => {
    const prices: Array<{ label: string; value: string; type: 'main' | 'special' | 'pack' }> = [];
    const condition = getSpecialConditionFromProduct(product);

    // Helper para verificar e formatar preço
    const addPrice = (value: any, label: string, type: 'main' | 'special' | 'pack') => {
        const formatted = formatPriceValue(value);
        if (formatted) {
            prices.push({ label, value: formatted, type });
            return true;
        }
        return false;
    };

    // PRIORIDADE: preços unitários são preferidos para exibição na etiqueta
    // O atacarejo geralmente mostra: preço unitário avulso (varejo) vs preço especial unitário (atacado)

    // Preço especial unitário (maior prioridade para atacado)
    const hasSpecialUnit = addPrice(product.priceSpecialUnit, '', 'special');

    // Preço especial de embalagem (só se não tem especial unitário)
    if (!hasSpecialUnit) {
        addPrice(product.priceSpecial, product.packageLabel || 'CX', 'special');
    }

    // Preço unitário avulso (preço principal varejo)
    // Se já tem um preço especial (atacado), o priceUnit é o preço de varejo (main).
    // Se NÃO tem preço especial, o priceUnit é o preço principal (main) — NUNCA classificar como 'special'
    // pois isso faria um produto simples aparecer com etiqueta atacarejo.
    const hasSpecial = prices.some(p => p.type === 'special');
    const hasUnitPrice = addPrice(product.priceUnit, '', 'main');

    // Preço de embalagem avulsa (só como complemento, não substitui unitário)
    if (!hasUnitPrice) {
        addPrice(product.pricePack, product.packageLabel || 'CX', hasSpecial ? 'main' : 'pack');
    } else {
        // Adicionar pricePack como info extra se diferente do priceUnit
        const packFormatted = formatPriceValue(product.pricePack);
        const unitFormatted = formatPriceValue(product.priceUnit);
        if (packFormatted && packFormatted !== unitFormatted) {
            addPrice(product.pricePack, product.packageLabel || 'CX', 'pack');
        }
    }

    // Fallback para preço legado
    if (prices.length === 0) {
        addPrice(product.price, '', 'main');
    }

    return {
        prices,
        condition,
        hasSpecial: prices.some(p => p.type === 'special'),
        mainPrice: prices[0]?.value || '0,00'
    };
};

// Smart Object Generator (Product Card)
const createSmartObject = async (
    product: any,
    x: number,
    y: number,
    width: number,
    height: number,
    gridId: string,
    labelTpl?: LabelTemplate,
    zoneStyles?: Partial<GlobalStyles>
) => {
    // Layout Constants
    const cardHeight = height || width * 1.4; // Aspect ratio 1:1.4 (fallback)
    const halfW = width / 2;
    const halfH = cardHeight / 2;
    const baseSize = Math.min(width, cardHeight);
    const effectiveStyles = normalizeGlobalStyles(zoneStyles);
    const initialCardBorderWidth = Math.max(0, Number(effectiveStyles.cardBorderWidth ?? 0));
    const initialCardBorderColor = initialCardBorderWidth > 0
        ? (effectiveStyles.cardBorderColor || '#000000')
        : undefined;
    const { cleanedName, extractedLimit } = extractLimitFromName(product?.name);
    const limitTextValue = normalizeLimitText(product?.limit ?? extractedLimit);
    
    // All coordinates are RELATIVE to group center (0,0 = center of card)
    
    // 1. Background (Card container)
    const bg = new fabric.Rect({
        width: width, 
        height: cardHeight, 
        fill: effectiveStyles.isProdBgTransparent ? 'transparent' : (effectiveStyles.cardColor || '#ffffff'),
        rx: typeof effectiveStyles.cardBorderRadius === 'number' ? effectiveStyles.cardBorderRadius : 8,
        ry: typeof effectiveStyles.cardBorderRadius === 'number' ? effectiveStyles.cardBorderRadius : 8,
        stroke: initialCardBorderColor,
        strokeWidth: initialCardBorderWidth,
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'offerBackground'
    });

    // 2. Title (Top) - positioned at top of card
    const titleY = -halfH + (cardHeight * 0.08); // Near top
    const title = new fabric.Textbox(String(cleanedName || ''), {
        fontSize: baseSize * 0.09,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#1a1a1a',
        textAlign: 'center',
        originX: 'center',
        originY: 'top',
        left: 0, // Centered horizontally
        top: titleY,
        width: width - 20,
        name: 'smart_title',
        shadow: new fabric.Shadow({ color: 'rgba(255,255,255,0.8)', blur: 2, offsetX: 1, offsetY: 1 }),
        // UX: Prevent font stretching/blurring, enforce reflow
        lockScalingY: true, 
        splitByGrapheme: false
    });
    if (typeof (title as any).initDimensions === 'function') (title as any).initDimensions();

    // 2.1 Limit (Below title)
    let limitObj: any = null;
    if (limitTextValue) {
        const titleH = (title.getScaledHeight?.() ?? title.height ?? 0);
        const gap = Math.max(4, baseSize * 0.02);
        limitObj = new fabric.Textbox(limitTextValue, {
            fontSize: baseSize * 0.045,
            fontFamily: 'Inter',
            fontWeight: '900',
            fill: '#d32f2f',
            textAlign: 'center',
            originX: 'center',
            originY: 'top',
            left: 0,
            top: titleY + titleH + gap,
            width: width - 20,
            name: 'smart_limit',
            data: { smartType: 'product-limit' },
            lockScalingY: true,
            splitByGrapheme: false
        });
        if (typeof (limitObj as any).initDimensions === 'function') (limitObj as any).initDimensions();
    }

    // 3. Product Image (Middle)
    let imgObj: any = null;
    const imgUrl = product.imageUrl || product.image || product.url;
    const imageY = 0; // Centered vertically
    
    if (imgUrl) {
        try {
            const proxiedImgUrl = toWasabiProxyUrl(imgUrl) || imgUrl;
            imgObj = await fabric.Image.fromURL(proxiedImgUrl, { crossOrigin: 'anonymous' });
            
            if (imgObj) {
                // Scale image to fit middle area
                const availW = width * 0.85;
                const availH = cardHeight * 0.5;
                const scale = Math.min(availW / imgObj.width, availH / imgObj.height);
                
                imgObj.set({
                    scaleX: scale,
                    scaleY: scale,
                    originX: 'center',
                    originY: 'center',
                    left: 0, // Centered
                    top: imageY, // Centered
                    name: 'smart_image',
                    lockScalingFlip: true,
                    lockSkewingX: true,
                    lockSkewingY: true
                });
            }
        } catch (e) {
            console.warn('Image load failed, using placeholder rect', e);
            imgObj = null;
        }
    }
    
    // Fallback rect if no image
    if (!imgObj) {
        imgObj = new fabric.Rect({
            width: width * 0.7,
            height: cardHeight * 0.35,
            fill: '#333',
            rx: 8, ry: 8,
            originX: 'center',
            originY: 'center',
            left: 0,
            top: imageY
        });
    }

    // 4. Price Tag (Bottom) - DINÂMICO: mostra apenas os preços que existem
    const marginBottom = cardHeight * 0.05;

    // Obter todos os preços disponíveis dinamicamente
    const availablePrices = getAvailablePrices(product);
    const priceStr = availablePrices.mainPrice
        .replace(/R\$\s*/gi, '')
        .replace(/\s+/g, '')
        .trim();

    // Unit label on the tag: ONLY "KG" or "UN" (gramatura stays in the product name).
    const unitText = inferUnitLabelFromProduct(product);

    if (!priceStr || priceStr === '0,00') {
        console.warn('[createSmartObject] PRECO VAZIO para produto:', product.name);
    }

    // Default tag (fallback)
    const buildDefaultPriceGroup = () => {
        // Use a neutral Y; we anchor it after layout so custom templates can have different heights.
        return buildDefaultPriceGroupForCard(priceStr, width, cardHeight, 0, unitText);
    };

    let priceTagGroup: any = null;
    const buildPriceGroupFromTemplate = async (tpl: LabelTemplate | undefined | null) => {
        if (!tpl) return null;
        const pg = await instantiatePriceGroupFromTemplate(tpl);
        pg.set({ left: 0, top: 0, name: 'priceGroup' });
        setPriceOnPriceGroup(pg, priceStr, unitText);
        const isRedBurst = isRedBurstPriceGroup(pg) || String(tpl?.id || '') === BUILTIN_RED_BURST_LABEL_TEMPLATE_ID;
        const headerParts = inferHeaderPartsFromProduct(product, 'OFERTA', {
            preferFullNameWithWeight: isRedBurst,
            splitUnitIntoDedicatedField: !isRedBurst
        });
        const headerTextObj = collectObjectsDeep(pg).find((o: any) => o?.name === 'price_header_text');
        if (headerTextObj && isTextLikeObject(headerTextObj)) {
            const defaultHeader = String(headerTextObj.text || '').trim() || 'OFERTA';
            headerTextObj.set('text', headerParts.title || defaultHeader);
            if (typeof headerTextObj.initDimensions === 'function') headerTextObj.initDimensions();
        }
        const headerUnitObj = collectObjectsDeep(pg).find((o: any) => o?.name === 'price_header_unit_text');
        if (headerUnitObj && isTextLikeObject(headerUnitObj)) {
            headerUnitObj.set('text', isRedBurst ? '' : (headerParts.unit || ''));
            headerUnitObj.set('visible', !isRedBurst && !!headerParts.unit);
            if (typeof headerUnitObj.initDimensions === 'function') headerUnitObj.initDimensions();
        }
        if (isRedBurst) tuneRedBurstPriceGroupLayout(pg);
        applyAtacarejoPricingToPriceGroup(pg, product);
        return pg;
    };

    if (labelTpl) {
        try {
            priceTagGroup = await buildPriceGroupFromTemplate(labelTpl);
        } catch (e) {
            console.warn('[createSmartObject] Failed to use label template, falling back', e);
            priceTagGroup = null;
        }
    }
    if (!priceTagGroup) {
        // Verificar se tem preço especial/atacado usando o novo sistema
        const availablePrices = getAvailablePrices(product);
        const hasSpecial = availablePrices.prices.some(p => p.type === 'special');
        const hasMain = availablePrices.prices.some(p => p.type === 'main' || p.type === 'pack');
        const hasCondition = !!availablePrices.condition;
        const hasWholesalePrice = hasSpecial && hasMain;
        // Mesmo com 1 preço, se houver condição/observação o card deve manter o template atacarejo e colapsar.
        const shouldUseAtacarejoTemplate = hasWholesalePrice || hasCondition || !!formatPriceValue(product.priceWholesale);
        if (shouldUseAtacarejoTemplate) {
            // Prefer template-driven atacarejo (edited in Mini Editor) over hardcoded fallback.
            const builtInAtacTpl = labelTemplates.value.find((t: any) => String(t?.id || '') === BUILTIN_ATACAREJO_LABEL_TEMPLATE_ID);
            if (builtInAtacTpl) {
                try {
                    priceTagGroup = await buildPriceGroupFromTemplate(builtInAtacTpl);
                } catch (e) {
                    console.warn('[createSmartObject] Failed to build atacarejo from template, using hardcoded fallback', e);
                }
            }
        }
        if (!priceTagGroup) {
            priceTagGroup = shouldUseAtacarejoTemplate
                ? buildAtacarejoPriceGroupForCard(product, width, cardHeight, 0)
                : buildDefaultPriceGroup();
        }
    }

    // Fill atacarejo fields even for the default group (no-op unless the template supports it).
    applyAtacarejoPricingToPriceGroup(priceTagGroup, product);

    const layout = layoutPriceGroup(priceTagGroup, width, cardHeight);
    const hForAnchor = layout?.pillH ?? (priceTagGroup.getScaledHeight?.() ?? priceTagGroup.height ?? (cardHeight * 0.18));
    priceTagGroup.set({
        originX: 'center',
        originY: 'center',
        left: 0,
        top: halfH - (hForAnchor / 2) - marginBottom
    });

    // Allow editing inside the label (select text/shapes).
    if (priceTagGroup && typeof priceTagGroup.getObjects === 'function') {
        priceTagGroup.set({ subTargetCheck: true, interactive: true });
        priceTagGroup.getObjects().forEach((child: any) => {
            const isBgImage = child?.name === 'price_bg_image' || child?.name === 'splash_image';
            child.set({
                selectable: !isBgImage,
                evented: !isBgImage,
                hasControls: !isBgImage,
                hasBorders: !isBgImage
            });
        });
    }

    const isRedBurstCard = isRedBurstPriceGroup(priceTagGroup) || String(labelTpl?.id || '') === BUILTIN_RED_BURST_LABEL_TEMPLATE_ID;
    if (isRedBurstCard) {
        title.set({
            visible: false,
            selectable: false,
            evented: false
        });
    }
    const groupChildren: any[] = [
        bg,
        imgObj,
        title,
        ...(limitObj ? [limitObj] : []),
        priceTagGroup
    ];

    // Main Product Card Group
    // NOTE: keep title above the image in stacking order (prevents it being hidden by tall images).
    const group = new fabric.Group(groupChildren, {
        left: x,
        top: y,
        name: 'product-card',
        originX: 'center',
        originY: 'center',
        isSmartObject: true,
        smartGridId: gridId,
        excludeFromExport: false,
        // Single-click deep select: user can click directly on inner elements.
        subTargetCheck: true,
        interactive: true
    });
    
    // Store card dimensions for containment checking (used by object:moving handler)
    (group as any)._cardWidth = width;
    (group as any)._cardHeight = cardHeight;

    // Persist ALL pricing metadata on the card so label templates can be reapplied safely.
    // This preserves ALL price information for future use.
    (group as any).price = (product as any).price ?? null;
    (group as any).pricePack = (product as any).pricePack ?? null;
    (group as any).priceUnit = (product as any).priceUnit ?? null;
    (group as any).priceSpecial = (product as any).priceSpecial ?? null;
    (group as any).priceSpecialUnit = (product as any).priceSpecialUnit ?? null;
    (group as any).specialCondition = getSpecialConditionFromProduct(product) ?? null;
    // Wholesale (legacy)
    (group as any).priceWholesale = (product as any).priceWholesale ?? null;
    (group as any).wholesaleTrigger = (product as any).wholesaleTrigger ?? null;
    (group as any).wholesaleTriggerUnit = (product as any).wholesaleTriggerUnit ?? null;
    // Pack metadata
    (group as any).packQuantity = (product as any).packQuantity ?? null;
    (group as any).packUnit = (product as any).packUnit ?? null;
    (group as any).packageLabel = (product as any).packageLabel ?? null;
    // Unit label
    (group as any).unit = (product as any).unit ?? null;
    (group as any).unitLabel = unitText;
    (group as any).limit = limitTextValue ?? null;
    // Store original product data for reference
    (group as any)._productData = { ...product };

    // Internal elements should be selectable for manual adjustments
    group.getObjects().forEach((obj: any) => {
        const isBackground = obj.name === 'offerBackground';
        obj.set({
            selectable: !isBackground,
            evented: !isBackground,
            hasControls: !isBackground,
            hasBorders: !isBackground
        });
    });
    
    // Add custom ID
    (group as any)._customId = makeCanvasObjectId();

    // ESSENTIAL: Force group to calculate proper coordinates and cache
    group.setCoords();
    // Keep caching OFF for product cards to avoid occasional black-flash glitches.
    group.set({
        objectCaching: false,
        statefullCache: false,
        dirty: true,
        strokeWidth: 0 // Ensure no weird borders affect layout
    });

    return group;
}

// Handler para abrir o modal de importação de lista, salvando a referência da zona
const handleImportProductList = () => {
    if (!canvas.value) return;

    const active = canvas.value.getActiveObject();
    if (active && isLikelyProductZone(active)) {
        targetGridZone.value = active;
        try {
            productImportExistingCount.value = getZoneChildren(active).length;
        } catch {
            productImportExistingCount.value = 0;
        }
    }

    showPasteListModal.value = true;
}

const normalizeImageSearchText = (value: any): string =>
    String(value || '')
        .replace(/\s+/g, ' ')
        .trim();

const normalizeImageSearchKey = (value: string): string =>
    normalizeImageSearchText(value)
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

const dedupeImageSearchTokens = (value: any): string => {
    const tokens = normalizeImageSearchText(value).split(' ').filter(Boolean);
    const seen = new Set<string>();
    const out: string[] = [];

    for (const token of tokens) {
        const key = normalizeImageSearchKey(token);
        if (!key) continue;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(token);
    }

    return out.join(' ').trim();
};

const uniqueImageSearchHints = (variants: string[]): string[] => {
    const seen = new Set<string>();
    const out: string[] = [];
    for (const entry of variants) {
        const compact = dedupeImageSearchTokens(entry);
        if (!compact) continue;
        const key = normalizeImageSearchKey(compact);
        if (!key || seen.has(key)) continue;
        seen.add(key);
        out.push(compact);
    }
    return out;
};

// Paste List Handlers
const handlePasteList = async () => {
    showPasteListModal.value = false;
    
    // Parse the list
    let data: any[] = [];
    if (activePasteTab.value === 'text') {
        data = parseProductList(pasteListText.value);
    } else {
        data = [];
    }

    if (data.length === 0) {
        pasteListText.value = '';
        pastedImage.value = null;
        return;
    }

    // Show processing state
    isProcessing.value = true;

    // Fetch images for each product from Contabo/Serper
    const productsWithImages = await Promise.all(
        data.map(async (product, index) => {
            try {
                // Build search term
                const searchTerm = dedupeImageSearchTokens(
                    `${product.name || ''} ${product.brand || ''} ${product.weight || ''}`
                );
                const searchHints = uniqueImageSearchHints([
                    `${product.name || ''} ${product.brand || ''} ${product.flavor || ''} ${product.weight || ''}`,
                    `${product.name || ''} ${product.brand || ''} ${product.weight || ''}`,
                    `${product.name || ''} ${product.brand || ''}`,
                    String(product?.name || '').trim()
                ]);
                const headers = await getApiAuthHeaders();
                
                const result = await $fetch<{ url?: string }>('/api/process-product-image', {
                    method: 'POST',
                    headers,
                    // When importing products, default to bg-removed variants (cached) for better card visuals.
                    body: {
                        term: String(searchHints[0] || product?.name || searchTerm || '').trim(),
                        searchHints,
                        ...(product?.brand ? { brand: String(product.brand).trim() } : {}),
                        ...(product?.flavor ? { flavor: String(product.flavor).trim() } : {}),
                        ...(product?.weight ? { weight: String(product.weight).trim() } : {}),
                        bgPolicy: 'always',
                        strictMode: false
                    }
                });
                
                return {
                    ...product,
                    id: `prod_${Date.now()}_${index}`,
                    imageUrl: result?.url || null,
                    image: result?.url || null,
                    status: result?.url ? 'done' : 'error'
                };
            } catch (err) {
                console.warn('Failed to fetch image for:', product.name, err);
                return { 
                    ...product, 
                    id: `prod_${Date.now()}_${index}`,
                    imageUrl: null, 
                    image: null,
                    status: 'error'
                };
            }
        })
    );

    isProcessing.value = false;
    
    // Store in review state and open review modal
    reviewProducts.value = productsWithImages;
    try {
        const zone = targetGridZone.value;
        productImportExistingCount.value = (zone && isLikelyProductZone(zone)) ? getZoneChildren(zone).length : 0;
    } catch {
        productImportExistingCount.value = 0;
    }
    showProductReviewModal.value = true;
    
    // Reset paste input (but keep data for review)
    pasteListText.value = '';
    pastedImage.value = null;
}

const resolveOrCreateZoneForFrame = (frame: any): any | null => {
    if (!canvas.value || !fabric || !frame) return null
    const frameId = String((frame as any)?._customId || '').trim()
    if (!frameId) return null

    const zonesForFrame = canvas.value
        .getObjects()
        .filter((obj: any) => isLikelyProductZone(obj) && String((obj as any)?.parentFrameId || '').trim() === frameId)

    if (zonesForFrame.length === 1) {
        ensureZoneSanity(zonesForFrame[0])
        return zonesForFrame[0]
    }

    if (zonesForFrame.length > 1) {
        const pickLargest = zonesForFrame.reduce((best: any, candidate: any) => {
            const b = getZoneMetrics(best) || best?.getBoundingRect?.(true)
            const c = getZoneMetrics(candidate) || candidate?.getBoundingRect?.(true)
            const bestArea = Number(b?.width || 0) * Number(b?.height || 0)
            const candidateArea = Number(c?.width || 0) * Number(c?.height || 0)
            return candidateArea > bestArea ? candidate : best
        }, zonesForFrame[0])
        ensureZoneSanity(pickLargest)
        return pickLargest
    }

    const frameBounds = getFrameBounds(frame)
    if (!frameBounds) return null

    const innerPadding = Math.max(12, Math.min(64, Math.round(Math.min(frameBounds.width, frameBounds.height) * 0.04)))
    const zoneWidth = Math.max(80, frameBounds.width - innerPadding * 2)
    const zoneHeight = Math.max(80, frameBounds.height - innerPadding * 2)
    const zoneCenterX = frameBounds.left + (frameBounds.width / 2)
    const zoneCenterY = frameBounds.top + (frameBounds.height / 2)

    const zoneRect = new fabric.Rect({
        width: zoneWidth,
        height: zoneHeight,
        fill: 'rgba(0,0,0,0)',
        stroke: '#404040',
        strokeWidth: 2,
        strokeDashArray: [10, 10],
        strokeUniform: true,
        rx: 16,
        ry: 16,
        originX: 'center',
        originY: 'center',
        name: 'zoneRect',
        selectable: false,
        evented: false
    })

    const zone = new fabric.Group([zoneRect], {
        left: zoneCenterX,
        top: zoneCenterY,
        originX: 'center',
        originY: 'center',
        isGridZone: true,
        isProductZone: true,
        name: 'productZoneContainer',
        columns: 0,
        rows: 0,
        gapHorizontal: 20,
        gapVertical: 20,
        cardAspectRatio: 'auto',
        lastRowBehavior: 'fill',
        layoutDirection: 'horizontal',
        verticalAlign: 'stretch',
        subTargetCheck: false,
        hoverCursor: 'move',
        moveCursor: 'move',
        lockMovementX: false,
        lockMovementY: false,
        lockScalingFlip: true,
        selectable: true,
        evented: true,
        hasControls: true,
        hasBorders: true,
        transparentCorners: false,
        cornerColor: '#8b5cf6',
        cornerStyle: 'circle',
        cornerSize: 10,
        padding: 0,
        excludeFromExport: false,
        objectCaching: false,
        statefullCache: false
    })

    ;(zone as any)._customId = makeCanvasObjectId()
    ;(zone as any)._zonePadding = 20
    ;(zone as any)._zoneWidth = zoneWidth
    ;(zone as any)._zoneHeight = zoneHeight
    ;(zone as any).parentFrameId = frameId
    // New zones should start from defaults (not from the previous page's last-selected styles).
    ;(zone as any)._zoneGlobalStyles = normalizeGlobalStyles(DEFAULT_GLOBAL_STYLES)

    canvas.value.add(zone)
    ensureZoneSanity(zone)
    getResolvedZoneFrameId(zone)
    zone.setCoords?.()
    ensureFramesBelowContents()
    return zone
}

const importProductsToMultipleFrames = async (products: any[], opts?: ProductImportOptions) => {
    if (!canvas.value || !Array.isArray(products) || products.length === 0) return

    const selectedFrameIds = Array.from(
        new Set(
            (Array.isArray(opts?.selectedFrameIds) ? opts?.selectedFrameIds : [])
                .map((id: any) => String(id || '').trim())
                .filter(Boolean)
        )
    )
    const frameById = new Map<string, any>()
    getAllFrames().forEach((frame: any) => {
        const id = String(frame?._customId || frame?.id || '').trim()
        if (id) frameById.set(id, frame)
    })

    const validFrameIds = selectedFrameIds.filter(id => frameById.has(id))
    if (validFrameIds.length === 0) {
        console.warn('[importProductsToMultipleFrames] No valid selected frames to import.')
        return
    }

    const productById = new Map<string, any>()
    const orderedProductIds: string[] = []
    products.forEach((product: any, index: number) => {
        const id = String(product?.id || `tmp-product-${index + 1}`).trim()
        if (!productById.has(id)) {
            productById.set(id, product)
            orderedProductIds.push(id)
        }
    })

    const validFrameIdSet = new Set(validFrameIds)
    const pairs: Array<{ product: any; productId: string; frameId: string }> = []
    const usedFrameIds = new Set<string>()
    const usedProductIds = new Set<string>()

    const rawAssignments = Array.isArray(opts?.frameAssignments) ? opts.frameAssignments : []
    rawAssignments.forEach((assignment: any) => {
        const productId = String(assignment?.productId || '').trim()
        const frameId = String(assignment?.frameId || '').trim()
        if (!productId || !frameId) return
        if (!validFrameIdSet.has(frameId)) return
        if (!productById.has(productId)) return
        if (usedFrameIds.has(frameId)) return
        if (usedProductIds.has(productId)) return

        usedFrameIds.add(frameId)
        usedProductIds.add(productId)
        pairs.push({
            product: productById.get(productId),
            productId,
            frameId
        })
    })

    if (pairs.length === 0) {
        const fallbackLimit = Math.min(orderedProductIds.length, validFrameIds.length)
        for (let i = 0; i < fallbackLimit; i += 1) {
            const productId = orderedProductIds[i]
            const frameId = validFrameIds[i]
            if (!productId || !frameId) continue
            pairs.push({
                product: productById.get(productId),
                productId,
                frameId
            })
        }
    }

    const effectiveLimit = Math.min(orderedProductIds.length, validFrameIds.length)
    const effectivePairs = pairs.slice(0, effectiveLimit)
    if (effectivePairs.length === 0) {
        console.warn('[importProductsToMultipleFrames] No valid product/frame pairs to import.')
        return
    }

    const labelTemplateId = typeof opts?.labelTemplateId === 'string' ? opts.labelTemplateId : undefined
    let applied = 0

    for (const pair of effectivePairs) {
        const frame = frameById.get(pair.frameId)
        if (!frame) continue
        const zone = resolveOrCreateZoneForFrame(frame)
        if (!zone) {
            console.warn('[importProductsToMultipleFrames] Could not resolve zone for frame:', pair.frameId)
            continue
        }

        await simulateSmartGrid(
            [pair.product],
            { margin: 10, gap: 15, orphanBehavior: 'fill' },
            zone,
            {
                mode: 'replace',
                labelTemplateId,
                persist: false
            }
        )
        applied += 1
    }

    if (applied > 0) {
        refreshCanvasObjects()
        canvas.value.requestRenderAll()
        refreshSelectedRef()
        saveCurrentState({ allowEmptyOverwrite: true, reason: 'simulate-smart-grid-multi-frame' })
        flushPersistenceNow('simulate-smart-grid-multi-frame')
    }
}

// Confirm import from review modal
const confirmProductImport = async (products: any[], opts?: ProductImportOptions) => {
    if (isConfirmingProductImport.value) {
        console.warn('[confirmProductImport] Import already running, ignoring duplicate trigger.')
        return
    }

    isConfirmingProductImport.value = true
    showProductReviewModal.value = false

    try {
        if (!products || products.length === 0) {
            console.warn('[confirmProductImport] No products to import!')
            return
        }

        const targetMode: ImportTargetMode = opts?.targetMode === 'multi-frame' ? 'multi-frame' : 'zone'
        if (targetMode === 'multi-frame') {
            await importProductsToMultipleFrames(products, opts)
        } else {
            // Recover the real zone object from canvas state (prevents "solto" cards on stale refs).
            const zone = resolveImportTargetZone()
            if (!zone) {
                console.warn('[confirmProductImport] Could not resolve target product zone. Import aborted to avoid detached cards.')
                notifyEditorError('Nao foi possivel localizar a zona de produtos para substituir os cards.')
                return
            }
            targetGridZone.value = zone

            // Add to canvas using the products received from the modal (with edits applied)
            const mode = (opts?.mode === 'append' || opts?.mode === 'replace') ? opts.mode : 'replace'
            const labelTemplateId = typeof opts?.labelTemplateId === 'string' ? opts.labelTemplateId : undefined
            await simulateSmartGrid(products, { margin: 10, gap: 15, orphanBehavior: 'fill' }, zone, { mode, labelTemplateId })
        }
    } finally {
        // Clear review state and zone reference
        reviewProducts.value = []
        targetGridZone.value = null
        productImportExistingCount.value = 0

        // Update layer panel
        if (canvas.value) {
            refreshCanvasObjects()
        }
        isConfirmingProductImport.value = false
    }
}

const handleProductReviewModalVisibility = (value: boolean) => {
    showProductReviewModal.value = value
    if (value || isConfirmingProductImport.value) return

    reviewProducts.value = []
    targetGridZone.value = null
    productImportExistingCount.value = 0
}

const handleFileUpload = async (e: any) => {
    const input = e?.target as HTMLInputElement | null;
    const files = Array.from(input?.files || []).filter(Boolean) as File[];
    if (input) input.value = '';
    if (!files.length) {
        clearPendingProductImageOperation();
        return;
    }

    try {
        const mode = pendingLocalImageActionMode.value;

        // Replace mode: only first file is meaningful.
        if (mode === 'replace' && pendingImageReplaceTargetId.value) {
            const file = files[0];
            if (!file) {
                clearPendingProductImageOperation();
                return;
            }
            const uploaded = await uploadFile(file);
            if (!uploaded?.success || !uploaded?.url) throw new Error('Upload falhou');
            await replaceImageByCustomId(pendingImageReplaceTargetId.value, uploaded.url);
            return;
        }

        // Add to card: allow multiple files (they'll stack; user can reposition).
        if (mode === 'add' && pendingImageAddCardId.value) {
            const card = findProductCardByCustomId(pendingImageAddCardId.value);
            if (!card) throw new Error('Card de produto não encontrado.');

            for (const file of files) {
                const uploaded = await uploadFile(file);
                if (!uploaded?.success || !uploaded?.url) throw new Error('Upload falhou');
                const added = await addImageToProductCardByUrl(card, uploaded.url);
                if (!added) throw new Error('Não foi possível adicionar imagem ao card.');
            }
            return;
        }

        // Default: insert all files into the canvas (spread to avoid overlap).
        const base = getCenterOfView();
        const cols = Math.max(1, Math.ceil(Math.sqrt(files.length)));
        const gap = 34;
        for (let i = 0; i < files.length; i++) {
            const file = files[i]!;
            const uploaded = await uploadFile(file);
            if (!uploaded?.success || !uploaded?.url) throw new Error('Upload falhou');
            const row = Math.floor(i / cols);
            const col = i % cols;
            const pos = { x: base.x + (col * gap), y: base.y + (row * gap) };
            await insertAssetToCanvas({
                id: makeCanvasObjectId(),
                name: file.name || 'Imagem',
                url: uploaded.url
            }, { pos });
        }
    } catch (err: any) {
        console.error('❌ [upload] Erro ao processar imagem:', err);
        notifyEditorError('Erro ao enviar imagem: ' + (err?.message || 'Erro desconhecido'));
    } finally {
        clearPendingProductImageOperation();
    }
}

const addGridFrames = (cols: number = 2, rows: number = 2, gap: number = 8) => {
    if (!canvas.value || !fabric) return;

    const center = getCenterOfView();
    const gridGroupId = 'grid_' + Math.random().toString(36).substr(2, 9);

    // Total grid dimensions — fit nicely in view
    const totalW = 600;
    const totalH = 600;
    const cellW = (totalW - gap * (cols - 1)) / cols;
    const cellH = (totalH - gap * (rows - 1)) / rows;

    // Top-left corner of the grid
    const startX = center.x - totalW / 2;
    const startY = center.y - totalH / 2;

    const cells: any[] = [];

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const x = startX + c * (cellW + gap) + cellW / 2;
            const y = startY + r * (cellH + gap) + cellH / 2;

            const cell = new fabric.Rect({
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                width: cellW,
                height: cellH,
                fill: '#e0e0e0',
                stroke: 'transparent',
                strokeWidth: 0,
                strokeUniform: true,
                isFrame: true,
                clipContent: true,
                name: `Grade ${cols}×${rows} [${r + 1},${c + 1}]`,
                objectCaching: false,
                statefullCache: false,
                noScaleCache: true,
                hasBorders: true,
                transparentCorners: false,
                cornerColor: '#0d99ff',
                cornerSize: 8,
                padding: 0,
                lockScalingX: false,
                lockScalingY: false,
                cornerStrokeColor: '#0d99ff',
                borderScaleFactor: 1
            });

            (cell as any)._customId = Math.random().toString(36).substr(2, 9);
            (cell as any).__strokeEnabled = false;
            (cell as any).layerName = 'FRAMER';
            (cell as any).gridGroupId = gridGroupId;
            (cell as any).gridCol = c;
            (cell as any).gridRow = r;
            (cell as any).isGridCell = true;

            cells.push(cell);
        }
    }

    // Add all cells to canvas
    cells.forEach((cell) => canvas.value!.add(cell));

    // Frames must stay below content
    ensureFramesBelowContents();

    // Select the first cell
    if (cells.length > 0) {
        canvas.value.setActiveObject(cells[0]);
    }

    canvas.value.requestRenderAll();
    refreshCanvasObjects();
    saveCurrentState();
}

const addGridZone = () => {
    if (!canvas.value) return;
    
    const center = getCenterOfView();
    // Create a nicer placeholder zone
    // Background with Glass/Dark aesthetic
    const zone = new fabric.Rect({
        width: 400, 
        height: 600, 
        fill: 'rgba(0,0,0,0)', 
        stroke: '#404040', 
        strokeWidth: 2, 
        strokeDashArray: [10, 10], 
        strokeUniform: true,
        rx: 16, ry: 16,
        originX: 'center', originY: 'center'
    });

    const group = new fabric.Group([zone], {
        left: center.x,
        top: center.y,
        originX: 'center',
        originY: 'center',
        isGridZone: true, // Marker flag
        isProductZone: true,
        name: 'gridZone',
        // Default layout behavior (matches ProductZoneSettings defaults)
        columns: 0,
        rows: 0,
        gapHorizontal: 20,
        gapVertical: 20,
        cardAspectRatio: 'auto',
        lastRowBehavior: 'fill',
        layoutDirection: 'horizontal',
        verticalAlign: 'stretch',
        subTargetCheck: false,
        hoverCursor: 'move',
        moveCursor: 'move',
        lockMovementX: false,
        lockMovementY: false,
        lockScalingFlip: true,
        selectable: true,
        evented: true,
        hasControls: true,
        hasBorders: true,
        transparentCorners: false,
        cornerColor: '#8b5cf6',
        cornerStyle: 'circle',
        cornerSize: 10,
        padding: 0,
        excludeFromExport: false,
        objectCaching: false,
        statefullCache: false
    });
    
    // Add Custom ID
    (group as any)._customId = makeCanvasObjectId();
    (group as any)._zonePadding = 20;
    // CRITICAL: Initialize zone dimensions for persistence
    (group as any)._zoneWidth = 400;
    (group as any)._zoneHeight = 600;
    // New zones should start from defaults (not from the previous page's last-selected styles).
    (group as any)._zoneGlobalStyles = normalizeGlobalStyles(DEFAULT_GLOBAL_STYLES);

    canvas.value.add(group);
    getResolvedZoneFrameId(group);
    canvas.value.setActiveObject(group);
    canvas.value.requestRenderAll();
    saveCurrentState({ allowEmptyOverwrite: true, reason: 'add-grid-zone' });
    flushPersistenceNow('add-grid-zone');
}

const simulateSmartGrid = async (
    customData: any[] = [],
    config = { margin: 10, gap: 15, orphanBehavior: 'fill' },
    zone: any = null,
    opts: SmartGridRunOptions = {}
) => {
    if (!canvas.value || !fabric) {
        console.error('[simulateSmartGrid] Canvas or fabric not available!');
        return;
    }
    await ensureLabelTemplatesReady();
    const mode: 'replace' | 'append' = (opts?.mode === 'append' || opts?.mode === 'replace') ? opts.mode : 'replace';
    const requestedTplId = typeof opts?.labelTemplateId === 'string' && opts.labelTemplateId.trim().length ? opts.labelTemplateId.trim() : undefined;

    // 1. Identify Target Context (Zone vs Page) and Template
    // Use the passed zone if available, otherwise try to get from active selection
    let targetZone: any = zone;
    let templateObject: any = null;

    if (!targetZone) {
        const activeObj = canvas.value.getActiveObject();
        if (activeObj) {
            // Check for product zone using isLikelyProductZone to handle both isGridZone and isProductZone
            if (isLikelyProductZone(activeObj)) {
                targetZone = activeObj;
            } else if (activeObj.type === 'group' && !requestedTplId) {
                templateObject = activeObj;
            }
        }
    } else {
        // Validate that the passed zone is still a valid product zone
        if (!isLikelyProductZone(targetZone)) {
            console.warn('[simulateSmartGrid] Passed zone is not a valid product zone, ignoring');
            targetZone = null;
        }
    }
    
    // 2. Setup Bounds
    let bounds = { 
        left: 0, 
        top: 0, 
        width: activePage.value?.width || 1080, 
        height: activePage.value?.height || 1920 
    };

    // When no zone is selected, try to use the first existing Frame as bounds
    // so products are placed INSIDE the visible frame area.
    if (!targetZone) {
        const existingFrame = canvas.value.getObjects().find((o: any) => !!o?.isFrame);
        if (existingFrame) {
            const fb = existingFrame.getBoundingRect(true);
            bounds = { left: fb.left, top: fb.top, width: fb.width, height: fb.height };
        }
    }

    if (targetZone) {
        // Prefer persisted zone metrics to avoid drift after reload/scaling.
        let boundingRect = getZoneMetrics(targetZone) ?? targetZone.getBoundingRect(true);
        const zoneCenterX = boundingRect.left + (boundingRect.width / 2);
        const zoneCenterY = boundingRect.top + (boundingRect.height / 2);

        if (targetZone.originX !== 'center' || targetZone.originY !== 'center') {
            targetZone.set({
                originX: 'center',
                originY: 'center',
                left: zoneCenterX,
                top: zoneCenterY
            });
            targetZone.setCoords();
            boundingRect = getZoneMetrics(targetZone) ?? targetZone.getBoundingRect(true);
        }
        
        bounds = { 
            left: boundingRect.left, 
            top: boundingRect.top, 
            width: boundingRect.width, 
            height: boundingRect.height 
        };
        
    }

    // 3. Prepare Data
    let products = Array.isArray(customData) && customData.length > 0 ? customData : MOCK_PRODUCTS;
    const count = products.length;
    if (count === 0) {
        console.warn('[simulateSmartGrid] No products to render!');
        return;
    }

    const existingZoneCardsAtStart = targetZone
        ? (() => {
            try {
                return getZoneChildren(targetZone);
            } catch {
                return [] as any[];
            }
        })()
        : [];

    // When appending into a zone, compute the existing count to place new items after it.
    let existingCount = 0;
    if (targetZone && mode === 'append') {
        existingCount = existingZoneCardsAtStart.length;
    }
    const countForLayout = targetZone ? (existingCount + count) : count;

    // 4. Grid Configuration
    const gap = config.gap || 15;
    const margin = config.margin || 20;
    const padding = targetZone && typeof targetZone._zonePadding === 'number' ? targetZone._zonePadding : (targetZone && typeof targetZone.padding === 'number' ? targetZone.padding : margin);
    const gapX = targetZone && typeof targetZone.gapHorizontal === 'number' ? targetZone.gapHorizontal : gap;
    const gapY = targetZone && typeof targetZone.gapVertical === 'number' ? targetZone.gapVertical : gap;
    const lastRowBehavior = targetZone?.lastRowBehavior || config.orphanBehavior || 'fill';
    
    // Determine Item Size
    let itemWidth = 200;
    let itemHeight = 300;
    let cols = 1; // Default
    let layoutRows = 1;

    if (targetZone) {
        const zoneConfig: ProductZone = {
            x: bounds.left,
            y: bounds.top,
            width: bounds.width,
            height: bounds.height,
            padding,
            gapHorizontal: gapX,
            gapVertical: gapY,
            columns: typeof targetZone.columns === 'number' ? targetZone.columns : 0,
            rows: typeof targetZone.rows === 'number' ? targetZone.rows : 0,
            cardAspectRatio: targetZone.cardAspectRatio ?? 'auto',
            lastRowBehavior: targetZone.lastRowBehavior ?? 'center'
        };
        
        const gridLayout = calculateGridLayout(zoneConfig, countForLayout);
        cols = gridLayout.cols;
        layoutRows = gridLayout.rows;
        itemWidth = gridLayout.itemWidth;
        itemHeight = gridLayout.itemHeight;
    } else if (templateObject) {
        itemWidth = templateObject.getScaledWidth();
        itemHeight = templateObject.getScaledHeight();
        
        if (!targetZone) {
            // If strictly replacing template on page, remove it
            canvas.value.remove(templateObject);
        }
    }

    // 5. Layout Calculation
    // Effective Width
    const effectiveWidth = bounds.width - (padding * 2);
    
    // Calculate Cols (Default Logic if not Zone)
    if (!targetZone) {
        const maxCols = Math.floor(effectiveWidth / (itemWidth + gap));
        cols = Math.max(1, Math.min(count, maxCols));
    }
    
    // Batch Generation ID
    const batchGridId = `grid_${Math.random().toString(36).substr(2, 9)}`;
    if (!targetZone) {
        layoutRows = Math.ceil(count / cols);
    }
    
    const totalRows = layoutRows;
    const lastRowItemCount = countForLayout % cols || cols;

    if (targetZone) {
        const hasFixedColumns = typeof targetZone.columns === 'number' && targetZone.columns > 0;
        targetZone._zonePadding = padding;
        targetZone.set({
            padding: 0,
            gapHorizontal: gapX,
            gapVertical: gapY,
            lastRowBehavior: lastRowBehavior,
            columns: hasFixedColumns ? targetZone.columns : 0,
            // Keep rows in auto mode. Persisting computed rows causes stale gaps after reload.
            rows: 0,
            // Ensure both flags are set for consistency
            isGridZone: true,
            isProductZone: true
        });
    }

    isProcessing.value = true;
    isBulkProductMutation = true;

    try {
        // Allow import-time override of the label template.
        const prevZoneTplId = targetZone ? String((targetZone as any)._zoneGlobalStyles?.splashTemplateId || '').trim() : '';
        const prevZoneTplIdNormalized = prevZoneTplId.length ? prevZoneTplId : undefined;
        const snapshotId = targetZone ? String((targetZone as any)?._zoneTemplateSnapshotId || '').trim() : '';
        const snapshotGroup = targetZone ? (targetZone as any)?._zoneTemplateSnapshot : null;
        const snapshotIdNormalized = snapshotId.length ? snapshotId : undefined;
        // Resolve template id from explicit import choice, zone style, or stored snapshot id.
        // Runtime should prefer the live template record and only fallback to snapshot JSON.
        const zoneTplId = requestedTplId ?? prevZoneTplIdNormalized ?? snapshotIdNormalized;
        const snapshotAvailable = !!(snapshotGroup && typeof snapshotGroup === 'object');
        // Prefer the live template (latest Mini Editor state). Use zone snapshot only as fallback.
        const liveZoneTpl = zoneTplId ? labelTemplates.value.find(t => t.id === zoneTplId) : undefined;
        const canUseSnapshotFallback = snapshotAvailable && (!requestedTplId || !zoneTplId || zoneTplId === snapshotIdNormalized);
        const zoneTpl = liveZoneTpl
            ?? (canUseSnapshotFallback
                ? ({
                    id: zoneTplId || snapshotIdNormalized || 'zone-template-snapshot',
                    name: 'Zone Template Snapshot',
                    kind: 'priceGroup-v1',
                    group: snapshotGroup
                } as any as LabelTemplate)
                : undefined);
        let effectiveZoneTpl = zoneTpl;
        const getDonorTemplateFromExistingCards = () => {
            const donorCard = existingZoneCardsAtStart.find((c: any) => !!getPriceGroupFromAny(c));
            const donorPg = donorCard ? getPriceGroupFromAny(donorCard) : null;
            if (donorPg) {
                const donorGroupJson = serializePriceGroupForTemplate(donorPg);
                if (donorGroupJson) {
                    const donorTpl = {
                        id: 'zone-card-snapshot',
                        name: 'Zone Card Snapshot',
                        kind: 'priceGroup-v1',
                        group: donorGroupJson
                    } as any as LabelTemplate;
                    // Keep zone snapshot aligned with what is effectively being rendered.
                    const zoneSnapshotId = zoneTplId || snapshotIdNormalized || String((targetZone as any)._zoneGlobalStyles?.splashTemplateId || '').trim() || 'zone-card-snapshot';
                    (targetZone as any)._zoneTemplateSnapshotId = zoneSnapshotId;
                    (targetZone as any)._zoneTemplateSnapshot = cloneTemplateGroupJson(donorGroupJson) || donorGroupJson;
                    return donorTpl;
                }
            }
            return null;
        };

        if (targetZone && !requestedTplId && existingZoneCardsAtStart.length > 0) {
            // Preserve the CURRENT zone visual label for both replace and append
            // when user did not explicitly pick a template in the modal.
            const donorTpl = getDonorTemplateFromExistingCards();
            if (donorTpl) effectiveZoneTpl = donorTpl;
        } else if (!effectiveZoneTpl && targetZone) {
            // Last-resort source of truth when zone metadata doesn't define a usable template.
            const donorTpl = getDonorTemplateFromExistingCards();
            if (donorTpl) effectiveZoneTpl = donorTpl;
        }

        // Persist override on the zone so future imports use the same template.
        if (targetZone && requestedTplId && requestedTplId !== prevZoneTplIdNormalized) {
            const prev = getZoneGlobalStyles(targetZone);
            (targetZone as any)._zoneGlobalStyles = { ...prev, splashTemplateId: requestedTplId };
            const requestedTpl = labelTemplates.value.find((t: any) => String(t?.id || '') === String(requestedTplId));
            (targetZone as any)._zoneTemplateSnapshotId = requestedTplId;
            (targetZone as any)._zoneTemplateSnapshot = cloneTemplateGroupJson((requestedTpl as any)?.group) || null;
        }

        // If the user picked a template while appending, keep the zone consistent (apply to existing cards too).
        if (targetZone && mode === 'append' && requestedTplId && requestedTplId !== prevZoneTplIdNormalized && existingCount > 0) {
            await applyLabelTemplateToZone(targetZone, requestedTplId);
        }

        const zoneStylesForNewCards = targetZone
            ? getZoneGlobalStyles(targetZone)
            : normalizeGlobalStyles(productZoneState.globalStyles.value);

        const promises = products.map(async (product: any, index: number) => {
            const slotIndex = existingCount + index;
            const currentRow = Math.floor(slotIndex / cols);
            const currentCol = slotIndex % cols;
            
            // Base Position (Relative to bounds)
            // Calculate strictly based on itemWidth/Height to fill the Zone
            let xOffset = padding + (currentCol * (itemWidth + gapX));
            const yOffset = padding + (currentRow * (itemHeight + gapY));
            
            // Center only if requested; "fill" will be handled by the zone relayout pass.
            if (currentRow === totalRows - 1 && lastRowItemCount < cols && lastRowBehavior === 'center') {
                const rowWidth = (lastRowItemCount * itemWidth) + ((lastRowItemCount - 1) * gapX);
                const totalZoneWidth = effectiveWidth;
                const centerStart = (totalZoneWidth - rowWidth) / 2;
                xOffset = centerStart + (currentCol * (itemWidth + gapX)) + padding;
            }

            const finalX = bounds.left + xOffset + (itemWidth / 2);
            const finalY = bounds.top + yOffset + (itemHeight / 2);
            
            // Generate Object
            if (templateObject) {
                  // Clone using Promise API (Fabric v6+)
                 const cloned: any = await templateObject.clone(['name', 'id', 'smartGridId', 'isSmartObject', 'originX', 'originY']);

                  // CRITICAL FIX: Preserve nested object names after clone
                  // The clone operation loses names of children inside groups (like priceGroup)
                  const fixNestedNames = (clonedObj: any, sourceObj: any) => {
                      if (!clonedObj || !sourceObj) return;
                      
                      // Fix direct children
                      if (typeof clonedObj.getObjects === 'function' && typeof sourceObj.getObjects === 'function') {
                          const clonedChildren = clonedObj.getObjects();
                          const sourceChildren = sourceObj.getObjects();
                          
                          clonedChildren.forEach((child: any, idx: number) => {
                              const sourceChild = sourceChildren[idx];
                              if (sourceChild && sourceChild.name && !child.name) {
                                  child.set('name', sourceChild.name);
                              }
                              
                              // Recursively fix nested groups
                              if (child.type === 'group' && sourceChild && sourceChild.type === 'group') {
                                  fixNestedNames(child, sourceChild);
                              }
                          });
                      }
                  };
                  
                  fixNestedNames(cloned, templateObject);

	                  cloned.set({
	                     left: finalX,
	                     top: finalY,
	                     smartGridId: batchGridId,
	                     opacity: 1,
	                     visible: true,
	                     originX: 'center',
	                     originY: 'center',
	                     // Product cards must support inner-element targeting (image/text) consistently.
	                     subTargetCheck: true,
	                     interactive: true
	                  });
                  const clonedName = String((cloned as any)?.name || '').trim();
                  if (!clonedName || clonedName === 'priceGroup') {
                      cloned.set('name', 'product-card');
                  }

	                  // Ensure internal elements are selectable (recursive for nested groups in templates).
	                  const applyInteractivityRecursively = (node: any) => {
	                      if (!node) return;
	                      const t = String(node?.type || '').toLowerCase();
	                      const n = String(node?.name || '');
	                      const isBackground =
	                          n === 'offerBackground' ||
	                          n === 'price_bg' ||
	                          n === 'price_bg_image' ||
	                          n === 'splash_image';
	                      if (t === 'group' && typeof node.getObjects === 'function') {
	                          node.set({
	                              subTargetCheck: true,
	                              interactive: true,
	                              selectable: true,
	                              evented: true
	                          });
	                          (node.getObjects() || []).forEach((child: any) => applyInteractivityRecursively(child));
	                          return;
	                      }
	                      node.set({
	                          selectable: !isBackground,
	                          evented: !isBackground,
	                          hasControls: !isBackground,
	                          hasBorders: !isBackground
	                      });
	                  };
	                  applyInteractivityRecursively(cloned);

	                 // Data Injection Logic
	                  let titleFound = false;
	                  let priceFound = false;
	                  const { cleanedName, extractedLimit } = extractLimitFromName(product?.name);
	                  const limitTextValue = normalizeLimitText(product?.limit ?? extractedLimit);
	                  let limitFound = false;
	                  const objects = typeof cloned.getObjects === 'function' ? (cloned.getObjects() || []) : [];
	                  const isTextNode = (node: any) => String(node?.type || '').toLowerCase().includes('text');

	                  // Determinar preço principal (dinâmico - usa os preços disponíveis)
	                  const availablePrices = getAvailablePrices(product);
	                  const displayPrice = availablePrices.mainPrice;

	                 objects.forEach((obj: any) => {
	                    if (isTextNode(obj)) {
	                        if (obj.name === 'smart_title') {
	                            obj.set('text', cleanedName);
	                            titleFound = true;
	                        } else if (obj.name === 'smart_price') {
	                            obj.set('text', displayPrice);
                            priceFound = true;
                        } else if (
                            obj?.name === 'smart_limit' ||
                            obj?.name === 'limitText' ||
                            obj?.name === 'product_limit' ||
                            obj?.data?.smartType === 'product-limit'
                        ) {
                            obj.set('text', limitTextValue || '');
                            if (typeof obj.initDimensions === 'function') obj.initDimensions();
                            limitFound = true;
                        }
                    }
                 });

	                 // Fallback
	                 if (!titleFound || !priceFound) {
	                     const texts = objects.filter((o: any) => isTextNode(o));
	                     if (texts.length >= 1 && !titleFound) texts[0].set('text', cleanedName);
	                     if (texts.length >= 2 && !priceFound) texts[1].set('text', displayPrice);
	                 }

                 // If template doesn't include a limit object but product has a limit, create one.
                 if (!limitFound && limitTextValue) {
                     const cardW = cloned._cardWidth ?? cloned.width ?? itemWidth;
                     const cardH = cloned._cardHeight ?? cloned.height ?? itemHeight;
                     const baseSize = Math.min(cardW || itemWidth, cardH || itemHeight);
                     const limitObj = new fabric.Textbox(limitTextValue, {
                         fontSize: baseSize * 0.045,
                         fontFamily: 'Inter',
                         fontWeight: '900',
                         fill: '#d32f2f',
                         textAlign: 'center',
                         originX: 'center',
                         originY: 'top',
                         left: 0,
                         top: -(cardH || itemHeight) / 2 + ((cardH || itemHeight) * 0.12),
                         width: (cardW || itemWidth) * 0.9,
                         name: 'smart_limit',
                         data: { smartType: 'product-limit' },
                         lockScalingY: true,
                         splitByGrapheme: false
                     });
                     if (typeof (limitObj as any).initDimensions === 'function') (limitObj as any).initDimensions();
                     safeAddWithUpdate(cloned, limitObj);
                 }

                 // Keep template-cloned cards aligned with current zone styles.
                 // Without this pass, replacing products can resurrect stale template colors/borders.
                 if (targetZone) {
                     try {
                         resizeSmartObject(cloned, itemWidth, itemHeight, zoneStylesForNewCards);
                     } catch (styleErr) {
                         console.warn('[replace-products] Falha ao aplicar estilos da zona no card clonado:', styleErr);
                     }
                 }
                
                 cloned._customId = makeCanvasObjectId();
                 cloned.excludeFromExport = false;
                 return cloned;

                 } else {
                  return await createSmartObject(
                      product,
                      finalX,
                      finalY,
                      itemWidth,
                      itemHeight,
                      batchGridId,
                      effectiveZoneTpl,
                      zoneStylesForNewCards
                  );
            }
        });

        const smartObjects = await Promise.all(promises);
        
        // If we have a target zone, update it in place
        if (targetZone && canvas.value) {
            const zoneFrameId = getResolvedZoneFrameId(targetZone);

            // Get existing objects from zone (like background rect, labels)
            const existingZoneObjects = targetZone.getObjects ? targetZone.getObjects() : [];
            const existingCards = (() => {
                try {
                    return getZoneChildren(targetZone);
                } catch {
                    return [];
                }
            })();

            const zoneBounds = getZoneMetrics(targetZone) ?? targetZone.getBoundingRect(true);
            const zoneRect = existingZoneObjects.find((obj: any) => obj.type === 'rect' && obj.strokeDashArray);

            // Remove previous cards from the zone only when replacing.
            if (mode === 'replace') {
                existingCards.forEach((card: any) => canvas.value.remove(card));
            }

            // IMPORTANT: For Fabric.js groups, internal object positions are relative to the GROUP CENTER
            // The zone has originX: 'center', originY: 'center', so we need to offset by half the zone dimensions
            const zoneWidth = Number((zoneBounds as any)?.width || zoneRect?.width || 400) || 400;
            const zoneHeight = Number((zoneBounds as any)?.height || zoneRect?.height || 600) || 600;

            // CRITICAL: Clear any clipPath from the zone to prevent rendering errors
            // Product zones should not have clipPath as cards are added separately to canvas
            if (targetZone && targetZone.clipPath) {
                targetZone.clipPath = null;
            }

            // DON'T add to zone group - add directly to canvas to avoid coordinate issues
            // This is the Figma-like behavior where elements are independent
            let maxOrder = -1;
            if (mode === 'append' && existingCards.length > 0) {
                existingCards.forEach((c: any) => {
                    const o = Number((c as any)._zoneOrder);
                    if (Number.isFinite(o)) maxOrder = Math.max(maxOrder, o);
                });
                if (maxOrder < 0) maxOrder = existingCards.length - 1;
            }
            smartObjects.forEach((obj: any, idx: number) => {
                obj.isProductCard = true;
                obj.parentZoneId = targetZone._customId;
                obj.parentFrameId = zoneFrameId;
                obj.excludeFromExport = false;
                obj.clipPath = null;
                delete obj._frameClipOwner;
                // Fresh cards must not keep stale slot metadata from previous zones/operations.
                (obj as any)._zoneSlot = undefined;
                // Preserve stable ordering when adding to an existing zone.
                if (mode === 'append') {
                    (obj as any)._zoneOrder = maxOrder + 1;
                    maxOrder += 1;
                } else {
                    (obj as any)._zoneOrder = idx;
                }
                // Avoid rare black-flash rendering glitches on some browsers by disabling caching on cards.
                obj.set?.({ objectCaching: false, statefullCache: false, dirty: true });
                canvas.value.add(obj);
            });

            // Keep frames behind all content in one pass (faster than bringToFront per card).
            ensureFramesBelowContents();

            targetZone.set({
                isProductZone: true,
                isGridZone: true, // Ensure both flags are set for compatibility
                subTargetCheck: false, // Disable sub-target since cards are separate
                selectable: true,
                evented: true,
                name: 'productZoneContainer',
                lockScalingFlip: true,
                objectCaching: false,
                statefullCache: false
            });

            // Store zone dimensions for reference
            (targetZone as any)._zoneWidth = zoneWidth;
            (targetZone as any)._zoneHeight = zoneHeight;

            targetZone.setCoords();
            
            // Force Layout Recalculation to ensure alignment (centering, gaps) is perfect
            // We pass smartObjects explicitly so it doesn't have to search
            try {
                const cache = (mode === 'append') ? [...existingCards, ...smartObjects] : smartObjects;
                syncZoneCardFrameBindings(targetZone, cache);
                recalculateZoneLayout(targetZone, cache, { save: false });
            } catch (calcErr) {
                console.warn('Grid layout recalc error:', calcErr);
            }

            // Select the first created object
            if (smartObjects.length > 0) {
                canvas.value.setActiveObject(smartObjects[0]);
            }
        } else {
            // No zone - add directly to canvas and ensure they're above the Frame
            smartObjects.forEach((obj: any) => {
                // Ensure cards are NOT parented to any Frame (prevents clipPath hiding them)
                obj.clipPath = null;
                obj.parentFrameId = undefined;
                delete obj._frameClipOwner;
                obj.visible = true;
                obj.opacity = 1;
                canvas.value.add(obj);
            });
            // Ensure frames stay behind all content (products on top, frame at back)
            ensureFramesBelowContents();

            // Select the first created object
            if (smartObjects.length > 0) {
                canvas.value.setActiveObject(smartObjects[0]);
            }

        }

    } catch (err) {
        console.error("Grid Generation Failed:", err);
    } finally {
        isBulkProductMutation = false;
        isProcessing.value = false;
        refreshCanvasObjects();
        invalidateScrollbarBounds();
        updateScrollbars();
        canvas.value.requestRenderAll();
        if (opts?.persist !== false) {
            saveCurrentState({ allowEmptyOverwrite: true, reason: 'simulate-smart-grid' });
            flushPersistenceNow('simulate-smart-grid');
        }
    }
}

// === ZONE LOGIC ===

function normalizeGlobalStyles(styles?: Partial<GlobalStyles> | null): GlobalStyles {
    const source = (styles && typeof styles === 'object') ? styles : {};
    const merged = {
        ...DEFAULT_GLOBAL_STYLES,
        ...source
    };
    const defaultColor = {
        cardColor: DEFAULT_GLOBAL_STYLES.cardColor || '#ffffff',
        cardBorderColor: DEFAULT_GLOBAL_STYLES.cardBorderColor || '#000000',
        accentColor: DEFAULT_GLOBAL_STYLES.accentColor || '#dc2626',
        prodNameColor: DEFAULT_GLOBAL_STYLES.prodNameColor || '#000000',
        limitColor: DEFAULT_GLOBAL_STYLES.limitColor || '#ef4444',
        splashColor: DEFAULT_GLOBAL_STYLES.splashColor || '#dc2626',
        splashTextColor: DEFAULT_GLOBAL_STYLES.splashTextColor || '#ffffff',
        splashFill: DEFAULT_GLOBAL_STYLES.splashFill || '#000000'
    };
    const defaultNumber = {
        cardBorderRadius: DEFAULT_GLOBAL_STYLES.cardBorderRadius ?? 8,
        cardBorderWidth: DEFAULT_GLOBAL_STYLES.cardBorderWidth ?? 0,
        prodNameScale: DEFAULT_GLOBAL_STYLES.prodNameScale ?? 1,
        prodNameLineHeight: DEFAULT_GLOBAL_STYLES.prodNameLineHeight ?? 1.05,
        splashScale: DEFAULT_GLOBAL_STYLES.splashScale ?? 1,
        splashTextScale: DEFAULT_GLOBAL_STYLES.splashTextScale ?? 1,
        splashRoundness: DEFAULT_GLOBAL_STYLES.splashRoundness ?? 1,
        splashOffsetY: DEFAULT_GLOBAL_STYLES.splashOffsetY ?? 0
    };

    const normalizeHexColor = (
        value: any,
        fallback: string,
        opts: { allowTransparent?: boolean; allowUndefined?: boolean } = {}
    ): string | undefined => {
        if (value === undefined || value === null || value === '') {
            return opts.allowUndefined ? undefined : fallback;
        }
        const raw = String(value).trim();
        if (!raw) return opts.allowUndefined ? undefined : fallback;
        if (opts.allowTransparent && raw.toLowerCase() === 'transparent') return 'transparent';

        const prefixed = raw.startsWith('#') ? raw : `#${raw}`;
        const short = /^#([0-9a-f]{3})$/i.exec(prefixed);
        if (short) {
            const shortToken = String(short[1] || '');
            const expanded = shortToken.split('').map((ch) => ch + ch).join('').toLowerCase();
            return `#${expanded}`;
        }
        if (/^#[0-9a-f]{6}$/i.test(prefixed)) {
            return prefixed.toLowerCase();
        }
        return opts.allowUndefined ? undefined : fallback;
    };

    const toFinite = (value: any, fallback: number, min?: number, max?: number): number => {
        const n = Number(value);
        if (!Number.isFinite(n)) return fallback;
        if (typeof min === 'number' && n < min) return min;
        if (typeof max === 'number' && n > max) return max;
        return n;
    };

    const normalized: GlobalStyles = {
        ...merged,
        cardColor: normalizeHexColor(merged.cardColor, defaultColor.cardColor, { allowTransparent: true }),
        cardBorderColor: normalizeHexColor(merged.cardBorderColor, defaultColor.cardBorderColor),
        accentColor: normalizeHexColor(merged.accentColor, defaultColor.accentColor),
        prodNameColor: normalizeHexColor(merged.prodNameColor, defaultColor.prodNameColor),
        limitColor: normalizeHexColor(merged.limitColor, defaultColor.limitColor),
        splashColor: normalizeHexColor(merged.splashColor, defaultColor.splashColor),
        splashTextColor: normalizeHexColor(merged.splashTextColor, defaultColor.splashTextColor),
        splashFill: normalizeHexColor(merged.splashFill, defaultColor.splashFill),
        isProdBgTransparent: !!merged.isProdBgTransparent,
        cardBorderRadius: toFinite(merged.cardBorderRadius, defaultNumber.cardBorderRadius, 0, 120),
        cardBorderWidth: toFinite(merged.cardBorderWidth, defaultNumber.cardBorderWidth, 0, 24),
        prodNameScale: toFinite(merged.prodNameScale, defaultNumber.prodNameScale, 0.5, 2.5),
        prodNameLineHeight: toFinite(merged.prodNameLineHeight, defaultNumber.prodNameLineHeight, 0.7, 2.2),
        splashScale: toFinite(merged.splashScale, defaultNumber.splashScale, 0.35, 2.5),
        splashTextScale: toFinite(merged.splashTextScale, defaultNumber.splashTextScale, 0.4, 2.8),
        splashRoundness: toFinite(merged.splashRoundness, defaultNumber.splashRoundness, 0, 1),
        splashOffsetY: toFinite(merged.splashOffsetY, defaultNumber.splashOffsetY, -300, 300),
        priceTextColor: normalizeHexColor(merged.priceTextColor, defaultColor.splashTextColor, { allowUndefined: true }),
        priceCurrencyColor: normalizeHexColor(merged.priceCurrencyColor, defaultColor.splashTextColor, { allowUndefined: true }),
        priceFontWeight: merged.priceFontWeight === '' || merged.priceFontWeight === null ? undefined : merged.priceFontWeight
    };

    const align = String(normalized.prodNameAlign || '').toLowerCase();
    if (align !== 'left' && align !== 'center' && align !== 'right') {
        normalized.prodNameAlign = DEFAULT_GLOBAL_STYLES.prodNameAlign;
    }
    const transform = String(normalized.prodNameTransform || '').toLowerCase();
    if (transform !== 'none' && transform !== 'upper' && transform !== 'lower') {
        normalized.prodNameTransform = DEFAULT_GLOBAL_STYLES.prodNameTransform;
    }
    if (typeof normalized.priceFont !== 'string' || !normalized.priceFont.trim()) {
        normalized.priceFont = DEFAULT_GLOBAL_STYLES.priceFont;
    }
    if (typeof normalized.prodNameFont !== 'string' || !normalized.prodNameFont.trim()) {
        normalized.prodNameFont = DEFAULT_GLOBAL_STYLES.prodNameFont;
    }

    return normalized;
}

function getZoneGlobalStyles(zone?: any): GlobalStyles {
    if (zone && typeof (zone as any)._zoneGlobalStyles === 'object' && (zone as any)._zoneGlobalStyles !== null) {
        return normalizeGlobalStyles((zone as any)._zoneGlobalStyles as Partial<GlobalStyles>);
    }
    return normalizeGlobalStyles(productZoneState.globalStyles.value);
}

const DEBOUNCED_GLOBAL_STYLE_PROPS = new Set<string>([
    'cardBorderRadius',
    'cardBorderWidth',
    'splashScale',
    'splashTextScale',
    'splashRoundness',
    'splashOffsetY',
    'prodNameScale',
    'prodNameLineHeight'
]);

const isDebouncedGlobalStyleProp = (prop: string) => DEBOUNCED_GLOBAL_STYLE_PROPS.has(String(prop || ''));

const scheduleGlobalStylesStateSave = (prop: string) => {
    const immediate = !isDebouncedGlobalStyleProp(prop);
    if (globalStylesSaveTimer) {
        clearTimeout(globalStylesSaveTimer);
        globalStylesSaveTimer = null;
    }

    if (immediate) {
        saveCurrentState({ reason: `global-style:${prop}`, skipIfUnchanged: true });
        return;
    }

    globalStylesSaveTimer = setTimeout(() => {
        globalStylesSaveTimer = null;
        saveCurrentState({ reason: 'global-style:debounced', skipIfUnchanged: true });
    }, 180);
};

const getCurrentZoneObject = () => {
    if (!canvas.value) return null;
    
    // 1. Check active canvas object first (the real Fabric object)
    const active = canvas.value.getActiveObject?.();
    if (active && isLikelyProductZone(active)) return active;
    
    // 2. If active is a product card, find its parent zone on canvas
    if (active && isLikelyProductCard(active)) {
        const parentZoneId = (active as any).parentZoneId;
        if (parentZoneId) {
            const zone = canvas.value.getObjects().find((o: any) => 
                isLikelyProductZone(o) && o._customId === parentZoneId
            );
            if (zone) return zone;
        }
    }
    
    // 3. If selected snapshot looks like a zone, find the REAL Fabric object by _customId
    // CRITICAL: Use isLikelyProductZone() for FULL detection (flags, name, custom props, strokeDashArray)
    // instead of checking individual properties. This is essential for legacy arts where flags
    // may not have been serialized originally.
    const selected = selectedObjectRef.value as any;
    if (selected && (selected.isGridZone || selected.isProductZone || selected.name === 'gridZone' || selected.name === 'productZoneContainer'
        || (typeof selected._zonePadding === 'number' && typeof selected._zoneWidth === 'number')
    )) {
        const zoneId = selected._customId;
        if (zoneId) {
            // First try with full detection
            let zone = canvas.value.getObjects().find((o: any) => 
                isLikelyProductZone(o) && o._customId === zoneId
            );
            if (zone) return zone;
            // Fallback: find by _customId alone and set flags if it's a group
            // (handles edge case where real object lost flags but snapshot preserved them)
            zone = canvas.value.getObjects().find((o: any) => o._customId === zoneId && o.type === 'group');
            if (zone) {
                zone.isGridZone = true;
                ensureZoneSanity(zone);
                return zone;
            }
        }
    }
    
    // 4. If selected snapshot is a product card, find parent zone on canvas
    if (selected && isLikelyProductCard(selected)) {
        const parentZoneId = selected.parentZoneId;
        if (parentZoneId) {
            const zone = canvas.value.getObjects().find((o: any) => 
                isLikelyProductZone(o) && o._customId === parentZoneId
            );
            if (zone) return zone;
        }
    }
    
    // 5. FALLBACK: If snapshot has _customId, try to find any matching object on canvas
    // This handles cases where Fabric v7 lost flags but the object still exists
    if (selected && selected._customId) {
        const obj = canvas.value.getObjects().find((o: any) => o._customId === selected._customId);
        if (obj && obj.type === 'group' && isLikelyProductZone(obj)) {
            return obj;
        }
    }
    
    // 6. LAST RESORT: only auto-pick when there is exactly one zone.
    const zones = canvas.value.getObjects().filter((o: any) => isLikelyProductZone(o));
    if (zones.length === 1) return zones[0];
    
    return null;
}

const resolveZoneTargetsForUpdates = (opts: { allowAllFallback?: boolean } = {}) => {
    if (!canvas.value) return [] as any[];

    const zones = canvas.value.getObjects().filter((o: any) => isLikelyProductZone(o));
    const byId = new Map<string, any>();
    zones.forEach((z: any) => {
        const id = String(z?._customId || '').trim();
        if (id) byId.set(id, z);
    });

    const resolved: any[] = [];
    const pushZone = (z: any) => {
        if (!z || !isLikelyProductZone(z)) return;
        if (!resolved.includes(z)) resolved.push(z);
    };

    // 1) Primary source: currently resolved zone (active/snapshot/card parent).
    pushZone(getCurrentZoneObject());

    // 2) Snapshot selected zone id.
    const snap = selectedObjectRef.value as any;
    const snapId = String(snap?._customId || '').trim();
    if (snapId && byId.has(snapId)) pushZone(byId.get(snapId));

    // 3) Snapshot selected card parent zone.
    const parentId = String(snap?.parentZoneId || '').trim();
    if (parentId && byId.has(parentId)) pushZone(byId.get(parentId));

    // 4) If still unresolved and there is only one zone in canvas, use it.
    if (!resolved.length && zones.length === 1) pushZone(zones[0]);

    // 5) Emergency fallback: apply to all zones (prevents silent no-op).
    if (!resolved.length && opts.allowAllFallback && zones.length > 0) {
        zones.forEach((z: any) => pushZone(z));
    }

    return resolved;
}

const resolveZoneUpdatesPayload = (propOrPayload: any, val: any): Record<string, any> => {
    if (typeof propOrPayload === 'string' && propOrPayload.trim()) {
        return { [propOrPayload]: val };
    }
    if (propOrPayload && typeof propOrPayload === 'object' && !Array.isArray(propOrPayload)) {
        const payload = propOrPayload as Record<string, any>;
        if (typeof payload.prop === 'string' && payload.prop.trim()) {
            return { [payload.prop]: payload.value };
        }
        return { ...payload };
    }
    return {};
};

const handleUpdateZone = (propOrPayload: string | Record<string, any>, val?: any) => {
    const updates = resolveZoneUpdatesPayload(propOrPayload, val);
    const entries = Object.entries(updates).filter(([key]) => key && key !== 'prop' && key !== 'value');
    if (!entries.length) {
        console.warn('⚠️ [handleUpdateZone] Invalid payload received:', propOrPayload);
        return;
    }

    // 1. Update Reactive State
    productZoneState.updateZone(Object.fromEntries(entries));

    // 2. Apply to Canvas Object
    entries.forEach(([prop, value]) => updateZoneOnCanvas(prop, value));
}

const applyZoneUpdates = (zone: any, updates: Record<string, any>, opts: { save?: boolean } = {}) => {
    if (!canvas.value || !zone) return;
    ensureZoneSanity(zone);

    // CRITICAL: Save zone reference BEFORE any Fabric layout operations.
    // In Fabric v7, triggerLayout() can deselect the active object,
    // causing refreshSelectedRef to lose the zone.
    const zoneId = zone._customId;

    const zoneRect = getZoneRect(zone);
    const relayoutProps = new Set([
        'padding',
        'gapHorizontal',
        'gapVertical',
        'columns',
        'rows',
        'cardAspectRatio',
        'lastRowBehavior',
        'layoutDirection',
        'verticalAlign',
        'highlightCount',
        'highlightPos',
        'highlightHeight'
    ]);

    let shouldRelayout = false;

    Object.entries(updates).forEach(([prop, val]) => {
        if (prop === 'padding') {
            zone._zonePadding = Number(val);
            zone.set('padding', 0);
            shouldRelayout = true;
            return;
        }

        if (prop === 'isLocked') {
            const locked = !!val;
            zone.set({
                lockMovementX: locked,
                lockMovementY: locked,
                lockScalingX: locked,
                lockScalingY: locked
            });
            return;
        }

        // Visual props live on the inner rect.
        if (prop === 'backgroundColor' && zoneRect) {
            // Persist the intent on the zone (so we can distinguish "no background" vs Fabric default black).
            zone.set('backgroundColor', val);
            zoneRect.set('fill', val || 'transparent');
            return;
        }
        if (prop === 'borderColor' && zoneRect) {
            zoneRect.set('stroke', val);
            return;
        }
        if (prop === 'borderWidth' && zoneRect) {
            zoneRect.set('strokeWidth', Number(val));
            return;
        }
        if (prop === 'borderRadius' && zoneRect) {
            const r = Number(val);
            zoneRect.set({ rx: r, ry: r });
            return;
        }
        if (prop === 'showBorder' && zoneRect) {
            zoneRect.set('strokeWidth', val ? Math.max(zoneRect.strokeWidth || 0, 2) : 0);
            return;
        }

        zone.set(prop, val);
        if (relayoutProps.has(prop)) shouldRelayout = true;
    });

    // FIX Fabric v7: Avoid triggerLayout() for non-structural changes.
    // triggerLayout() can deselect the zone group, breaking the UI loop.
    // Only recalculate group bounds when children/structure actually changed.
    if (shouldRelayout) {
        // Mark zone dirty and update coords (lightweight alternative to full addWithUpdate/triggerLayout)
        zone.dirty = true;
        zone.setCoords();
        // Cache children before relayout to prevent losing them
        const cachedChildren = getZoneChildren(zone);
        recalculateZoneLayout(zone, cachedChildren, { save: false });
    } else {
        // For non-relayout property changes, just update coords and mark dirty
        zone.dirty = true;
        if (zoneRect) zoneRect.dirty = true;
        zone.setCoords();
    }

    // FIX Fabric v7: Re-select zone if it got deselected during layout recalculation
    const currentActive = canvas.value.getActiveObject?.();
    if (!currentActive || currentActive._customId !== zoneId) {
        try {
            canvas.value.setActiveObject(zone);
        } catch { /* ignore */ }
    }

    canvas.value.requestRenderAll();
    if (opts.save !== false) {
        // Set flag to prevent object:modified event from also saving state (prevents duplicate entries)
        isApplyingZoneUpdate = true;
        saveCurrentState();
        isApplyingZoneUpdate = false;
    }
    // Refresh snapshot so PropertiesPanel picks up the new values
    refreshSelectedRef();
};

const updateZoneOnCanvas = (prop: string, val: any) => {
    const targets = resolveZoneTargetsForUpdates({ allowAllFallback: false });
    if (!targets.length) {
        console.warn('⚠️ [updateZoneOnCanvas] No zone found! Cannot update canvas.');
        return;
    }
    if (targets.length === 1) {
        applyZoneUpdates(targets[0], { [prop]: val });
        return;
    }

    // Multiple target fallback (rare): apply without intermediate saves and commit once.
    targets.forEach((z: any) => applyZoneUpdates(z, { [prop]: val }, { save: false }));
    canvas.value?.requestRenderAll();
    saveCurrentState();
    refreshSelectedRef();
}

const LIGHTWEIGHT_GLOBAL_STYLE_PROPS = new Set<string>([
    'cardColor',
    'isProdBgTransparent',
    'cardBorderColor',
    'cardBorderWidth',
    'cardBorderRadius',
    'prodNameFont',
    'prodNameColor',
    'prodNameWeight',
    'prodNameAlign',
    'prodNameTransform',
    'prodNameLineHeight',
    'limitFont',
    'limitColor',
    'splashColor',
    'accentColor',
    'splashTextColor',
    'priceTextColor',
    'priceCurrencyColor',
    'priceFont',
    'priceFontWeight',
    'splashTextScale',
    'splashFill'
]);

const isLightweightGlobalStyleProp = (prop: string) => LIGHTWEIGHT_GLOBAL_STYLE_PROPS.has(String(prop || '').trim());

const getCardBackgroundRect = (card: any) => {
    if (!card || typeof card.getObjects !== 'function') return null;
    const objects = card.getObjects() || [];
    const byName = objects.find((o: any) => String(o?.name || '') === 'offerBackground' && String(o?.type || '').toLowerCase() === 'rect');
    if (byName) return byName;
    const byPattern = objects.find((o: any) => String(o?.type || '').toLowerCase() === 'rect' && /(offerBackground|background|bg)/i.test(String(o?.name || '')));
    if (byPattern) return byPattern;
    let largestRect: any = null;
    let largestArea = -1;
    objects.forEach((o: any) => {
        if (String(o?.type || '').toLowerCase() !== 'rect') return;
        const area = Number(o?.width || 0) * Number(o?.height || 0) * Number(o?.scaleX || 1) * Number(o?.scaleY || 1);
        if (area > largestArea) {
            largestArea = area;
            largestRect = o;
        }
    });
    return largestRect;
};

const getCardTitleText = (card: any) => {
    if (!card || typeof card.getObjects !== 'function') return null;
    const objects = card.getObjects() || [];
    const named = objects.find((o: any) => String(o?.name || '') === 'smart_title');
    if (named) return named;
    let topMostText: any = null;
    let topMost = Number.POSITIVE_INFINITY;
    objects.forEach((o: any) => {
        const t = String(o?.type || '').toLowerCase();
        const isText = t === 'text' || t === 'i-text' || t === 'textbox';
        if (!isText) return;
        const top = Number.isFinite(Number(o?.top)) ? Number(o.top) : Number.POSITIVE_INFINITY;
        if (top <= topMost) {
            topMost = top;
            topMostText = o;
        }
    });
    return topMostText;
};

const getCardLimitText = (card: any) => {
    if (!card || typeof card.getObjects !== 'function') return null;
    const objects = card.getObjects() || [];
    return objects.find((o: any) =>
        String(o?.name || '') === 'smart_limit' ||
        String(o?.name || '') === 'limitText' ||
        String(o?.name || '') === 'product_limit' ||
        String(o?.data?.smartType || '') === 'product-limit'
    ) || null;
};

const applyGlobalStylePropToCardFast = (card: any, prop: string, styles: GlobalStyles): boolean => {
    if (!card || card.type !== 'group' || typeof card.getObjects !== 'function') return false;
    const p = String(prop || '').trim();
    if (!p || !isLightweightGlobalStyleProp(p)) return false;

    const bg = getCardBackgroundRect(card);
    const title = getCardTitleText(card);
    const limit = getCardLimitText(card);
    const priceGroup = getPriceGroupFromAny(card);
    const cardBounds = typeof card.getBoundingRect === 'function' ? card.getBoundingRect(true) : null;
    const cardW = Number(card?._cardWidth ?? card?.width ?? card?.getScaledWidth?.() ?? cardBounds?.width ?? 0) || 0;
    const cardH = Number(card?._cardHeight ?? card?.height ?? card?.getScaledHeight?.() ?? cardBounds?.height ?? 0) || 0;
    let changed = false;

    if ((p === 'cardColor' || p === 'isProdBgTransparent') && bg && String(bg?.type || '').toLowerCase() === 'rect') {
        bg.set('fill', styles.isProdBgTransparent ? 'transparent' : (styles.cardColor || '#ffffff'));
        changed = true;
    } else if (p === 'cardBorderRadius' && bg && String(bg?.type || '').toLowerCase() === 'rect') {
        const r = Number.isFinite(Number(styles.cardBorderRadius)) ? Number(styles.cardBorderRadius) : 0;
        bg.set({ rx: r, ry: r });
        changed = true;
    } else if (p === 'cardBorderColor' && bg && String(bg?.type || '').toLowerCase() === 'rect') {
        const borderWidth = Number.isFinite(Number(styles.cardBorderWidth)) ? Math.max(0, Number(styles.cardBorderWidth)) : 0;
        if (styles.cardBorderColor) {
            bg.set('stroke', borderWidth > 0 ? styles.cardBorderColor : undefined);
            bg.set('strokeWidth', borderWidth);
        } else {
            bg.set('stroke', undefined);
            bg.set('strokeWidth', 0);
        }
        changed = true;
    } else if (p === 'cardBorderWidth' && bg && String(bg?.type || '').toLowerCase() === 'rect') {
        const borderWidth = Math.max(0, Number(styles.cardBorderWidth ?? 0));
        if (styles.cardBorderColor && borderWidth > 0) {
            bg.set('stroke', styles.cardBorderColor);
            bg.set('strokeWidth', borderWidth);
        } else {
            bg.set('stroke', undefined);
            bg.set('strokeWidth', 0);
        }
        changed = true;
    } else if (
        (p === 'prodNameColor' || p === 'prodNameFont' || p === 'prodNameWeight' || p === 'prodNameAlign' || p === 'prodNameTransform' || p === 'prodNameLineHeight') &&
        title &&
        isTextLikeObject(title)
    ) {
        if (styles.prodNameColor) title.set('fill', styles.prodNameColor);
        if (styles.prodNameFont) title.set('fontFamily', styles.prodNameFont);
        if (styles.prodNameWeight !== undefined) title.set('fontWeight', styles.prodNameWeight as any);
        if (styles.prodNameAlign) title.set('textAlign', styles.prodNameAlign);
        if (typeof styles.prodNameLineHeight === 'number') title.set('lineHeight', styles.prodNameLineHeight);

        const rawKey = '__rawText';
        const curText = String((title as any).text ?? '');
        if (typeof (title as any)[rawKey] !== 'string') (title as any)[rawKey] = curText;
        const mode = styles.prodNameTransform ?? 'none';
        if (mode === 'none') {
            (title as any)[rawKey] = curText;
        } else {
            const baseText = String((title as any)[rawKey] ?? curText);
            const nextText = mode === 'upper'
                ? baseText.toUpperCase()
                : mode === 'lower'
                    ? baseText.toLowerCase()
                    : baseText;
            if (nextText !== curText) title.set('text', nextText);
        }

        if (String(title.type || '').toLowerCase() === 'textbox' && cardW > 0) {
            const manualRatio = Number((title as any).__manualTextWidthRatio);
            const manualWidth = Number((title as any).__manualTextWidth);
            const hasManualWidth = !!(title as any).__manualTransform && (
                (Number.isFinite(manualRatio) && manualRatio > 0) ||
                (Number.isFinite(manualWidth) && manualWidth > 0)
            );
            if (!hasManualWidth) {
                title.set({ width: Math.max(20, cardW * 0.9) });
            }
        }
        if (typeof title.initDimensions === 'function') title.initDimensions();
        changed = true;
    } else if ((p === 'limitColor' || p === 'limitFont') && limit && isTextLikeObject(limit)) {
        if (styles.limitColor) limit.set('fill', styles.limitColor);
        if (styles.limitFont) limit.set('fontFamily', styles.limitFont);
        if (typeof limit.initDimensions === 'function') limit.initDimensions();
        changed = true;
    } else if (
        (
            p === 'splashColor' ||
            p === 'accentColor' ||
            p === 'splashFill' ||
            p === 'priceTextColor' ||
            p === 'priceCurrencyColor' ||
            p === 'splashTextColor' ||
            p === 'priceFont' ||
            p === 'priceFontWeight' ||
            p === 'splashTextScale'
    ) &&
        priceGroup &&
        String(priceGroup?.type || '').toLowerCase() === 'group' &&
        typeof priceGroup.getObjects === 'function'
    ) {
        const parts = collectObjectsDeep(priceGroup);
        const priceBg = parts.find((o: any) => o?.name === 'price_bg');
        const currencyText = parts.find((o: any) => o?.name === 'price_currency_text');
        const priceTexts = parts.filter((o: any) => ['price_integer_text', 'price_decimal_text', 'price_unit_text', 'price_value_text'].includes(String(o?.name || '')));

        if ((p === 'splashColor' || p === 'accentColor') && priceBg) {
            const accent = styles.splashColor ?? styles.accentColor;
            if (accent) priceBg.set('stroke', accent);
            changed = true;
        }
        if (p === 'splashFill' && priceBg) {
            if (styles.splashFill) priceBg.set('fill', styles.splashFill);
            changed = true;
        }
        if (p === 'priceCurrencyColor' && currencyText && isTextLikeObject(currencyText)) {
            const nextCurrency = styles.priceCurrencyColor ?? styles.priceTextColor ?? styles.splashTextColor;
            if (nextCurrency) currencyText.set('fill', nextCurrency);
            if (typeof currencyText.initDimensions === 'function') currencyText.initDimensions();
            changed = true;
        }
        if (p === 'priceTextColor' || p === 'splashTextColor') {
            const nextTextColor = styles.priceTextColor ?? styles.splashTextColor;
            if (nextTextColor) {
                priceTexts.forEach((txt: any) => {
                    if (!isTextLikeObject(txt)) return;
                    txt.set('fill', nextTextColor);
                    if (typeof txt.initDimensions === 'function') txt.initDimensions();
                });
                changed = true;
            }
        }

        if (p === 'priceFont' || p === 'priceFontWeight' || p === 'splashTextScale') {
            const allPriceTexts = [currencyText, ...priceTexts];
            allPriceTexts.forEach((txt: any) => {
                if (!isTextLikeObject(txt)) return;
                if (styles.priceFont) txt.set('fontFamily', styles.priceFont);
                if (styles.priceFontWeight !== undefined) txt.set('fontWeight', styles.priceFontWeight as any);

                const mult = typeof styles.splashTextScale === 'number' ? styles.splashTextScale : 1;
                if (typeof txt.__fontScale === 'number') {
                    if (typeof txt.__fontScaleBase !== 'number') txt.__fontScaleBase = txt.__fontScale;
                    txt.__fontScale = txt.__fontScaleBase * mult;
                }
                if (typeof txt.initDimensions === 'function') txt.initDimensions();
            });

            if (cardW > 0 && cardH > 0) {
                layoutPriceGroup(priceGroup, cardW, cardH);
            }
            changed = true;
        }
    }

    return changed;
};

const applyGlobalStylesToCards = (styles: Partial<GlobalStyles>, zone?: any, opts: { prop?: string } = {}) => {
    const summary = { cardsTouched: 0, fastApplied: 0, fullRelayout: 0 };
    if (!canvas.value) {
        console.warn('⚠️ [applyGlobalStylesToCards] No canvas!');
        return summary;
    }
    const effectiveStyles = normalizeGlobalStyles(styles);
    const objs = canvas.value.getObjects();
    const isCardCandidate = (o: any) => {
        if (!o || o.type !== 'group') return false;
        if ((o as any).excludeFromExport) return false;
        if ((o as any).isFrame) return false;
        if (isLikelyProductZone(o)) return false;
        if (String(o.name || '') === 'priceGroup') return false;
        return !!(
            o.isSmartObject ||
            o.isProductCard ||
            isLikelyProductCard(o) ||
            String((o as any).parentZoneId || '').trim().length ||
            String((o as any).smartGridId || '').trim().length ||
            (Number.isFinite((o as any)._cardWidth) && Number((o as any)._cardWidth) > 0) ||
            (Number.isFinite((o as any)._cardHeight) && Number((o as any)._cardHeight) > 0)
        );
    };

    // Product cards are top-level canvas objects by design. Avoid deep traversal to prevent
    // false positives on nested groups (e.g., priceGroup inside cards).
    const allCards = objs.filter((o: any) => isCardCandidate(o));
    const dedupeCards = (arr: any[]) => {
        const map = new Map<any, any>();
        arr.forEach((c: any) => {
            const key = c?._customId ?? c?.id ?? c;
            map.set(key, c);
        });
        return Array.from(map.values());
    };
    const hasStrongCardSignature = (o: any) => {
        if (!o || o.type !== 'group' || typeof o.getObjects !== 'function') return false;
        const cw = Number((o as any)?._cardWidth);
        const ch = Number((o as any)?._cardHeight);
        if (Number.isFinite(cw) && cw > 0 && Number.isFinite(ch) && ch > 0) return true;

        const children = o.getObjects() || [];
        if (!Array.isArray(children) || children.length === 0) return false;

        const hasOfferBg = children.some((c: any) => String(c?.name || '') === 'offerBackground');
        if (hasOfferBg) return true;

        const hasPriceGroup = children.some((c: any) => String(c?.type || '').toLowerCase() === 'group' && String(c?.name || '') === 'priceGroup');
        const hasImage = children.some((c: any) => String(c?.type || '').toLowerCase() === 'image');
        return hasPriceGroup && hasImage;
    };

    let list: any[] = allCards;
    const zoneWarnKey = String((zone as any)?._customId || '').trim() || 'unknown-zone';
    const resolveCardsForZone = (zoneObj: any, pool: any[]) => {
        const zid = String((zoneObj as any)?._customId || '').trim();
        const zBounds = getZoneMetrics(zoneObj) ?? zoneObj.getBoundingRect(true);
        const zMargin = (() => {
            const pad = typeof (zoneObj as any)._zonePadding === 'number' ? (zoneObj as any)._zonePadding : 20;
            const base = Math.min(zBounds.width || 0, zBounds.height || 0);
            return Math.max(80, Math.min(260, pad + base * 0.14));
        })();

        const fromBinding = zid
            ? pool.filter((c: any) => String((c as any)?.parentZoneId || '').trim() === zid)
            : [];
        const fromSlot = zid
            ? pool.filter((c: any) => String((c as any)?._zoneSlot?.zoneId || '').trim() === zid)
            : [];
        const fromHeuristic = getZoneChildren(zoneObj);
        const fromIntersection = pool.filter((c: any) => {
            const center = typeof c.getCenterPoint === 'function'
                ? c.getCenterPoint()
                : { x: Number(c.left || 0), y: Number(c.top || 0) };
            const nearInside =
                center.x >= (zBounds.left - zMargin) &&
                center.x <= (zBounds.left + zBounds.width + zMargin) &&
                center.y >= (zBounds.top - zMargin) &&
                center.y <= (zBounds.top + zBounds.height + zMargin);
            if (nearInside) return true;
            try {
                return typeof zoneObj.intersectsWithObject === 'function' && zoneObj.intersectsWithObject(c);
            } catch {
                return false;
            }
        });

        return dedupeCards([...fromBinding, ...fromSlot, ...fromHeuristic, ...fromIntersection]);
    };
    if (zone && isLikelyProductZone(zone)) {
        list = resolveCardsForZone(zone, allCards);

        // Multi-zone safety: never bleed a zone style into every card.
        if (!list.length) {
            const zones = objs.filter((o: any) => isLikelyProductZone(o));
            if (!allCards.length) {
                // Normal state: zone exists but still has no cards.
                if (import.meta.dev) {
                    console.debug('[applyGlobalStylesToCards] Zone has no cards yet; skipping style apply');
                }
                return summary;
            }

            // Binding metadata can be stale after undo/reload; try one repair pass first.
            try {
                repairLooseZoneCardBindings();
            } catch {
                // keep safe fallback below
            }
            const refreshedObjects = canvas.value.getObjects();
            const refreshedCards = refreshedObjects.filter((o: any) => isCardCandidate(o));
            list = resolveCardsForZone(zone, refreshedCards.length ? refreshedCards : allCards);

            if (!list.length) {
                const zid = String((zone as any)?._customId || '').trim();
                const zBounds = getZoneMetrics(zone) ?? zone.getBoundingRect(true);
                const emergencyUnbound = refreshedObjects.filter((o: any) => {
                    if (!o || o.type !== 'group' || typeof o.getObjects !== 'function') return false;
                    if ((o as any).excludeFromExport || (o as any).isFrame || isLikelyProductZone(o)) return false;
                    if (isStandalonePriceGroup(o)) return false;
                    if (!hasStrongCardSignature(o)) return false;

                    const boundId = String((o as any)?.parentZoneId || '').trim();
                    const slotZoneId = String((o as any)?._zoneSlot?.zoneId || '').trim();
                    if ((boundId && boundId !== zid) || (slotZoneId && slotZoneId !== zid)) return false;
                    if (boundId || slotZoneId) return false;

                    const center = typeof o.getCenterPoint === 'function'
                        ? o.getCenterPoint()
                        : { x: Number(o.left || 0), y: Number(o.top || 0) };

                    return (
                        center.x >= zBounds.left &&
                        center.x <= (zBounds.left + zBounds.width) &&
                        center.y >= zBounds.top &&
                        center.y <= (zBounds.top + zBounds.height)
                    );
                });

                if (emergencyUnbound.length > 0) {
                    const zoneFrameId = getResolvedZoneFrameId(zone);
                    emergencyUnbound.forEach((card: any) => {
                        if (zid && !String((card as any)?.parentZoneId || '').trim()) {
                            (card as any).parentZoneId = zid;
                        }
                        applyCardFrameBinding(card, zoneFrameId);
                    });
                    list = dedupeCards(emergencyUnbound);
                }
            }

            if (!list.length) {
                // If the target zone is truly empty, skipping style-apply is expected behavior.
                // Persisted zone styles still remain for future cards.
                const hasZoneBoundCards = (() => {
                    const zid = String((zone as any)?._customId || '').trim();
                    if (!zid) return false;
                    const inZone = refreshedObjects.some((o: any) => {
                        if (!o || o.type !== 'group' || typeof o.getObjects !== 'function') return false;
                        if ((o as any).excludeFromExport || (o as any).isFrame || isLikelyProductZone(o)) return false;
                        if (isStandalonePriceGroup(o)) return false;

                        const boundId = String((o as any)?.parentZoneId || '').trim();
                        const slotZoneId = String((o as any)?._zoneSlot?.zoneId || '').trim();
                        return boundId === zid || slotZoneId === zid;
                    });
                    return inZone;
                })();

                if (!hasZoneBoundCards) {
                    const warnedMap = ((applyGlobalStylesToCards as any).__warnedZones ||= new Set<string>());
                    warnedMap.delete(zoneWarnKey);
                    if (import.meta.dev) {
                        console.debug('[applyGlobalStylesToCards] Zone has no bound cards; skipping style apply');
                    }
                    return summary;
                }

                if (zones.length <= 1) {
                    console.warn('⚠️ [applyGlobalStylesToCards] No cards resolved for zone; fallback to all cards (single-zone canvas)');
                    list = allCards;
                } else {
                    const warnedMap = ((applyGlobalStylesToCards as any).__warnedZones ||= new Set<string>());
                    if (!warnedMap.has(zoneWarnKey)) {
                        warnedMap.add(zoneWarnKey);
                        console.warn('⚠️ [applyGlobalStylesToCards] No cards resolved for zone; aborting global-style apply to avoid cross-zone pollution');
                    }
                    return summary;
                }
            } else {
                const warnedMap = ((applyGlobalStylesToCards as any).__warnedZones ||= new Set<string>());
                warnedMap.delete(zoneWarnKey);
            }
        }
    }
    
    const fastProp = String(opts?.prop || '').trim();
    const allowFastPath = !!fastProp && isLightweightGlobalStyleProp(fastProp);

    list.forEach((card: any, idx: number) => {
        try {
        if (!card || card.type !== 'group' || typeof card.getObjects !== 'function') {
            return;
        }
        // CRITICAL: Recursively mark ALL children dirty and disable objectCaching.
        // After loadFromJSON, objectCaching defaults to true on cards/nested groups,
        // which can prevent visual updates from appearing until the cache is invalidated.
        const markDirtyRecursive = (obj: any) => {
            if (!obj) return;
            obj.dirty = true;
            if (obj.objectCaching) obj.objectCaching = false;
            if (obj.statefullCache) obj.statefullCache = false;
            if (typeof obj.getObjects === 'function') {
                (obj.getObjects() || []).forEach((child: any) => markDirtyRecursive(child));
            }
        };

        if (allowFastPath && applyGlobalStylePropToCardFast(card, fastProp, effectiveStyles)) {
            summary.cardsTouched += 1;
            summary.fastApplied += 1;
            markDirtyRecursive(card);
            card.setCoords();
            return;
        }

        // Explicit global-style updates (coming from sidebar controls) must always relayout.
        // This guarantees realtime visual feedback even if a style is not part of the layout signature.
        if (fastProp) {
            (card as any).__forceCardRelayout = true;
        }

        const cardBounds = typeof card.getBoundingRect === 'function' ? card.getBoundingRect(true) : null;
        const cardW = card._cardWidth ?? card.width ?? card.getScaledWidth?.() ?? cardBounds?.width ?? 0;
        const cardH = card._cardHeight ?? card.height ?? card.getScaledHeight?.() ?? cardBounds?.height ?? 0;
        if (cardW && cardH) {
            resizeSmartObject(card, cardW, cardH, effectiveStyles);
        } else {
            // Final fallback prevents dead cards after corrupted reload states.
            resizeSmartObject(card, 180, 260, effectiveStyles);
        }
        summary.cardsTouched += 1;
        summary.fullRelayout += 1;
        // Do NOT call safeAddWithUpdate — resizeSmartObject already freezes dimensions.
        markDirtyRecursive(card);
        card.setCoords();
        } catch (err) {
            console.warn(`⚠️ [applyGlobalStylesToCards] Failed on card ${idx}`, err);
        }
    });
    return summary;
};

const handleApplyZonePreset = (presetId: string) => {
    productZoneState.applyPreset(presetId);
    if (!canvas.value) return;
    const active = getCurrentZoneObject();
    if (!active) return;
    const z = productZoneState.productZone.value;
    applyZoneUpdates(active, {
        padding: z.padding ?? 15,
        gapHorizontal: z.gapHorizontal ?? z.padding ?? 15,
        gapVertical: z.gapVertical ?? z.padding ?? 15,
        columns: z.columns ?? 0,
        rows: z.rows ?? 0,
        layoutDirection: z.layoutDirection ?? 'horizontal',
        cardAspectRatio: z.cardAspectRatio ?? 'fill',
        lastRowBehavior: z.lastRowBehavior ?? 'fill',
        verticalAlign: z.verticalAlign ?? 'stretch',
        highlightCount: z.highlightCount ?? 0,
        highlightPos: z.highlightPos ?? 'first',
        highlightHeight: z.highlightHeight ?? 1.5
    });
};

const handleSyncZoneGaps = (padding: number) => {
    productZoneState.syncGapsWithPadding(padding);
    if (!canvas.value) return;
    const active = getCurrentZoneObject();
    if (!active) return;
    const z = productZoneState.productZone.value;
    applyZoneUpdates(active, {
        padding: z.padding,
        gapHorizontal: z.gapHorizontal ?? z.padding,
        gapVertical: z.gapVertical ?? z.padding
    });
};

const ALLOW_UNDEFINED_GLOBAL_STYLE_PROPS = new Set<string>([
    'splashTemplateId',
    'priceTextColor',
    'priceCurrencyColor',
    'priceFontWeight'
]);

const resolveGlobalStyleUpdatePayload = (propOrPayload: any, val: any): { prop: string; value: any } | null => {
    if (typeof propOrPayload === 'string' && propOrPayload.trim()) {
        return { prop: propOrPayload, value: val };
    }
    if (propOrPayload && typeof propOrPayload === 'object' && !Array.isArray(propOrPayload)) {
        const payload = propOrPayload as Record<string, any>;
        if (typeof payload.prop === 'string' && payload.prop.trim()) {
            return { prop: payload.prop, value: payload.value };
        }
        const keys = Object.keys(payload);
        if (keys.length === 1 && keys[0]) {
            return { prop: keys[0], value: payload[keys[0]] };
        }
    }
    return null;
};

const handleUpdateGlobalStyles = async (propOrPayload: string | Record<string, any>, val?: any) => {
    if (!canvas.value) return;
    const parsed = resolveGlobalStyleUpdatePayload(propOrPayload, val);
    if (!parsed) {
        console.warn('⚠️ [handleUpdateGlobalStyles] Invalid payload received:', propOrPayload);
        return;
    }

    const prop = parsed.prop;
    const value = parsed.value;
    if (value === undefined && !ALLOW_UNDEFINED_GLOBAL_STYLE_PROPS.has(prop)) {
        console.warn(`⚠️ [handleUpdateGlobalStyles] Ignoring undefined value for "${prop}" to avoid unintended resets.`);
        return;
    }

    const perfStart = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();

    // Gather ALL zones in canvas first (for fallback).
    const allZones = canvas.value.getObjects().filter((o: any) => isLikelyProductZone(o));

    const targets = resolveZoneTargetsForUpdates({ allowAllFallback: false });
    const primaryZone = targets[0];

    // If no zone found but a card is selected, try to find its parent zone
    let zone = primaryZone;
    if (!zone && selectedObjectRef.value && isLikelyProductCard(selectedObjectRef.value)) {
        const parentZoneId = selectedObjectRef.value.parentZoneId;
        if (parentZoneId) {
            zone = canvas.value.getObjects().find((o: any) =>
                isLikelyProductZone(o) && o._customId === parentZoneId
            );
        }
    }

    // Reload safety: if a zone snapshot is selected but Fabric lost activeObject,
    // resolve the real zone directly by _customId.
    if (!zone && selectedObjectRef.value?._customId) {
        const selectedId = String(selectedObjectRef.value._customId).trim();
        if (selectedId) {
            zone = canvas.value.getObjects().find((o: any) =>
                String((o as any)?._customId || '').trim() === selectedId && isLikelyProductZone(o)
            );
        }
    }

    // Last deterministic fallback: pick the single zone if there's only one.
    // IMPORTANT: For global styles this is safe (applies to the whole canvas).
    if (!zone && allZones.length === 1) {
        zone = allZones[0];
    }

    // Keep composable synchronized with EFFECTIVE styles (defaults + zone overrides),
    // so controls always operate on a complete style object.
    const baseStylesForState = zone
        ? getZoneGlobalStyles(zone)
        : normalizeGlobalStyles(productZoneState.globalStyles.value);
    const nextStylesForState = normalizeGlobalStyles({ ...baseStylesForState, [prop]: value });
    productZoneState.updateGlobalStyles(nextStylesForState);

    // Persist styles on the zone so they survive undo/redo and reload.
    const effectiveTargets = targets.length > 0
        ? targets
        : (zone ? [zone] : (allZones.length === 1 ? [allZones[0]] : []));
    
    if (effectiveTargets.length > 0) {
        effectiveTargets.forEach((z: any) => {
            const prev = getZoneGlobalStyles(z);
            (z as any)._zoneGlobalStyles = normalizeGlobalStyles({ ...prev, [prop]: value });
        });
    }

    // Special case: label template selection.
    // Apply to existing cards immediately so the preview/canvas always matches the chosen template.
    if (prop === 'splashTemplateId' && effectiveTargets.length > 0) {
        for (const z of effectiveTargets) {
            // Keep UI and canvas consistent: when the user picks a template,
            // apply it to existing cards in the zone as well.
            await applyLabelTemplateToZone(z, value, true);
        }
        refreshSelectedRef();
        return;
    }

    if (effectiveTargets.length > 0) {
        let totalCardsTouched = 0;
        let totalFastApplied = 0;
        let totalFullRelayout = 0;
        effectiveTargets.forEach((z: any) => {
            const zStyles = getZoneGlobalStyles(z);
            const stats = applyGlobalStylesToCards(zStyles, z, { prop });
            totalCardsTouched += Number(stats?.cardsTouched || 0);
            totalFastApplied += Number(stats?.fastApplied || 0);
            totalFullRelayout += Number(stats?.fullRelayout || 0);
        });
        if (import.meta.dev) {
            const perfEnd = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
            const elapsedMs = Math.max(0, perfEnd - perfStart);
            console.log('[perf:global-styles]', {
                prop,
                zones: effectiveTargets.length,
                cardsTouched: totalCardsTouched,
                fastApplied: totalFastApplied,
                fullRelayout: totalFullRelayout,
                elapsedMs: Number(elapsedMs.toFixed(2))
            });
        }
    } else {
        console.warn('⚠️ [handleUpdateGlobalStyles] No target zone resolved; skipping apply to avoid cross-zone pollution');
        return;
    }

    // CRITICAL: Force aggressive re-render. After loadFromJSON, Fabric v7 groups
    // may cache stale renders. Clearing renderCache on all affected cards ensures
    // the new styles are visually applied.
    canvas.value.requestRenderAll();
    if (!isDebouncedGlobalStyleProp(prop)) {
        nextTick(() => {
            if (canvas.value) {
                // Force dirty on entire canvas to guarantee re-render
                canvas.value.getObjects().forEach((o: any) => {
                    if (o?.isSmartObject || o?.isProductCard) {
                        o.dirty = true;
                        if (typeof o.getObjects === 'function') {
                            (o.getObjects() || []).forEach((child: any) => {
                                if (child) child.dirty = true;
                            });
                        }
                    }
                });
                canvas.value.requestRenderAll();
            }
        });
    }
    scheduleGlobalStylesStateSave(prop);
    refreshSelectedRef();
};

const handleApplyTemplateToZone = async () => {
    const zone = getCurrentZoneObject();
    if (!zone) return;

    const templateId = (zone as any)._zoneGlobalStyles?.splashTemplateId;
    if (!templateId) {
        return;
    }

    await applyLabelTemplateToZone(zone, templateId, true); // true = apply to existing cards
    refreshSelectedRef();
};

const collectObjectsDeep = (root: any): any[] => {
    const out: any[] = [];
    const walk = (obj: any) => {
        if (!obj) return;
        out.push(obj);
        if (obj.type === 'group' && typeof obj.getObjects === 'function') {
            const children = obj.getObjects() || [];
            children.forEach(walk);
        }
    };
    if (root && typeof root.getObjects === 'function') {
        root.getObjects().forEach(walk);
    }
    return out;
};

const findByName = (objects: any[], name: string) => objects.find((o: any) => o?.name === name);
const isTextLikeObject = (obj: any) => {
    const t = String(obj?.type || '').toLowerCase();
    return t === 'text' || t === 'i-text' || t === 'textbox';
};

const parsePriceToCents = (v: any): number | null => {
    if (v === null || v === undefined) return null;
    const s0 = String(v).trim();
    if (!s0) return null;
    const s = s0.replace(/[^\d.,-]/g, '');
    if (!s) return null;
    const hasComma = s.includes(',');
    const hasDot = s.includes('.');
    let normalized = s;
    if (hasComma && hasDot) normalized = s.replace(/\./g, '').replace(',', '.'); // 1.234,56 -> 1234.56
    else if (hasComma) normalized = s.replace(/\./g, '').replace(',', '.'); // 123,45 -> 123.45
    else normalized = s.replace(/,/g, ''); // 1,234.56 -> 1234.56
    const n = Number(normalized);
    if (!Number.isFinite(n)) return null;
    return Math.round(n * 100);
};

const formatCentsToPrice = (cents: number | null): string | null => {
    if (cents === null || cents === undefined || !Number.isFinite(cents)) return null;
    const n = Math.round(cents);
    const abs = Math.abs(n);
    const int = Math.floor(abs / 100);
    const dec = String(abs % 100).padStart(2, '0');
    const sign = n < 0 ? '-' : '';
    return `${sign}${int},${dec}`;
};

const splitPriceParts = (raw: any): { integer: string; dec: string } => {
    const parsed = parsePriceBR(String(raw ?? ''));
    return { integer: parsed.inteiro, dec: parsed.centavos };
};

type AtacVariantKey = 'tiny' | 'normal' | 'large';
const resolveAtacVariantKeyFromPrice = (raw: any): AtacVariantKey => {
    const parsed = parsePriceBR(String(raw ?? ''));
    const integerDigits = String(parsed.inteiro || '0').replace(/^0+(?=\d)/, '');
    const digitsCount = Math.max(1, integerDigits.length || 1);
    if (digitsCount <= 1) return 'tiny';
    // 3+ digits (e.g. 129,99) require the "large" behavior to avoid overlap.
    if (digitsCount >= 3) return 'large';
    return 'normal';
};

// Parse de preço brasileiro (ex: "129,99" => { inteiro: "129", centavos: "99" })
const parsePriceBR = (preco: string): { inteiro: string; centavos: string } => {
    const s0 = String(preco ?? '')
        .replace(/R\$\s*/gi, '')
        .replace(/\s+/g, '')
        .trim();
    if (!s0) return { inteiro: '0', centavos: '00' };

    const lastComma = s0.lastIndexOf(',');
    const lastDot = s0.lastIndexOf('.');
    const sepIdx = Math.max(lastComma, lastDot);

    if (sepIdx === -1) {
        const inteiro = s0.replace(/[^\d]/g, '') || '0';
        return { inteiro, centavos: '00' };
    }

    const rawInt = s0.slice(0, sepIdx);
    const rawDec = s0.slice(sepIdx + 1);
    const inteiro = rawInt.replace(/[^\d]/g, '') || '0';
    const centavos = rawDec.replace(/[^\d]/g, '').padEnd(2, '0').slice(0, 2) || '00';
    return { inteiro, centavos };
};

const normalizeUnitForLabel = (raw: any): 'KG' | 'UN' => {
    const s0 = String(raw ?? '').trim();
    if (!s0) return 'UN';
    const s = s0.toUpperCase().replace(/\s+/g, '');

    // Remove a leading numeric quantity (e.g. "500ML", "1KG", "2,5KG") so we don't show gramatura.
    const tok = s.replace(/^\d+(?:[.,]\d+)?/, '');

    // Only allow these units on the label.
    if (tok === 'KG' || tok === 'K' || tok === 'KILO' || tok === 'KILOS' || tok.includes('KG')) return 'KG';
    if (tok === 'UN' || tok === 'UND' || tok === 'UNID' || tok === 'UNIDADE' || tok.includes('UN')) return 'UN';

    // Everything else (ML/L/G/etc) becomes "UN" (gramatura stays in the product name).
    return 'UN';
};

const PRICE_INTEGER_DECIMAL_GAP_PX = 1;

const layoutPrice = (opts: {
    priceInteger: any;
    priceDecimal: any;
    priceUnit?: any;
    intX: number;
    intY: number;
    decY: number;
    unitY: number;
    maxWidth?: number;
    gapPx?: number;
    minGapPx?: number;
    maxGapPx?: number;
    targetCenterX?: number;
}) => {
    const integer = opts.priceInteger;
    const decimal = opts.priceDecimal;
    if (!integer || !decimal) return null;

    const getW = (t: any) => (t && typeof t.getScaledWidth === 'function' ? t.getScaledWidth() : 0);
    const minGap = Number.isFinite(Number(opts.minGapPx)) ? Number(opts.minGapPx) : PRICE_INTEGER_DECIMAL_GAP_PX;
    const maxGap = Number.isFinite(Number(opts.maxGapPx)) ? Number(opts.maxGapPx) : PRICE_INTEGER_DECIMAL_GAP_PX;
    const autoGap = PRICE_INTEGER_DECIMAL_GAP_PX;
    let gap = Number.isFinite(Number(opts.gapPx)) ? Number(opts.gapPx) : autoGap;
    gap = Math.min(maxGap, Math.max(minGap, gap));

    integer.set?.({ originX: 'left', originY: 'center' });
    decimal.set?.({ originX: 'left', originY: 'center' });

    // Keep UN/KG only.
    const unitObj = opts.priceUnit;
    const rawUnit = String(unitObj?.text || '').trim();
    const hasUnit = !!(unitObj && rawUnit.length > 0);
    if (unitObj) {
        // Respect explicit hidden state (used by collapsed atacarejo tiers).
        // Avoid auto-reactivating hidden unit texts.
        if (unitObj.visible === false) {
            unitObj.set?.({ visible: false });
        } else if (hasUnit) {
            const unitNorm = normalizeUnitForLabel(rawUnit);
            if (unitNorm !== rawUnit.toUpperCase().replace(/\s+/g, '')) {
                unitObj.set?.('text', unitNorm);
                unitObj.initDimensions?.();
            }
            unitObj.set?.({ visible: true });
        } else {
            unitObj.set?.({ visible: false });
        }
    }

    const maxWidth = Number.isFinite(Number(opts.maxWidth)) ? Number(opts.maxWidth) : 0;
    let intW = getW(integer);
    const decWInitial = getW(decimal);

    // If the value is too wide, shrink the integer only (preserves design hierarchy).
    if (maxWidth > 0 && intW > 0) {
        const allowedIntW = Math.max(8, maxWidth - decWInitial - gap);
        if (intW > allowedIntW) {
            const baseScaleX = Number(integer.scaleX || 1);
            const baseScaleY = Number(integer.scaleY || 1);
            const shrink = Math.min(1, Math.max(0.35, allowedIntW / intW));
            integer.set?.({
                scaleX: baseScaleX * shrink,
                scaleY: baseScaleY * shrink
            });
            integer.initDimensions?.();
            intW = getW(integer);
        }
    }

    integer.set?.({
        left: opts.intX,
        top: opts.intY
    });

    const centsX = opts.intX + intW + gap; // regra pedida: depende da largura renderizada do inteiro
    decimal.set?.({
        left: centsX,
        top: opts.decY
    });

    const decW = getW(decimal);
    if (unitObj && unitObj.visible !== false) {
        const decCenterX = centsX + (decW / 2);
        unitObj.set?.({
            originX: 'center',
            originY: 'center',
            left: decCenterX,
            top: opts.unitY
        });

        const unitW = getW(unitObj);
        if (decW > 0 && unitW > decW) {
            const s = decW / unitW;
            unitObj.set?.({ scaleX: s, scaleY: s });
            unitObj.set?.({ left: decCenterX });
        } else {
            unitObj.set?.({ scaleX: 1, scaleY: 1 });
            unitObj.set?.({ left: decCenterX });
        }
    }

    // Keep the "inteiro + centavos (+ unidade)" block visually centered when requested.
    const toFinite = (v: any) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
    };
    const edgeLR = (obj: any): { left: number; right: number } | null => {
        if (!obj) return null;
        const w = getW(obj);
        if (!Number.isFinite(w) || w <= 0) return null;
        const x = Number(obj.left || 0);
        const ox = String(obj.originX || 'left');
        if (ox === 'center') return { left: x - (w / 2), right: x + (w / 2) };
        if (ox === 'right') return { left: x - w, right: x };
        return { left: x, right: x + w };
    };
    const targetCenterX = toFinite(opts.targetCenterX);
    if (targetCenterX !== null) {
        const edges = [edgeLR(integer), edgeLR(decimal), (unitObj?.visible !== false ? edgeLR(unitObj) : null)]
            .filter(Boolean) as Array<{ left: number; right: number }>;
        if (edges.length > 0) {
            const minX = Math.min(...edges.map((e) => e.left));
            const maxX = Math.max(...edges.map((e) => e.right));
            const currentCenter = (minX + maxX) / 2;
            const dx = targetCenterX - currentCenter;
            if (Math.abs(dx) > 0.001) {
                integer.set?.({ left: Number(integer.left || 0) + dx });
                decimal.set?.({ left: Number(decimal.left || 0) + dx });
                if (unitObj && unitObj.visible !== false) {
                    unitObj.set?.({ left: Number(unitObj.left || 0) + dx });
                }
            }
        }
    }

    return {
        intX: opts.intX,
        centsX,
        intW,
        decW,
        gap
    };
};

const isObjectShownForBounds = (obj: any) => {
    if (!obj) return false;
    if (obj.visible === false) return false;
    const sx = Number(obj.scaleX ?? 1);
    const sy = Number(obj.scaleY ?? 1);
    return sx !== 0 && sy !== 0;
};

const getObjectHorizontalBoundsLocal = (obj: any): { left: number; right: number } | null => {
    if (!isObjectShownForBounds(obj)) return null;
    const widthRaw = Number(obj?.width ?? 0);
    const scaleX = Math.abs(Number(obj?.scaleX ?? 1)) || 1;
    const width = widthRaw * scaleX;
    if (!Number.isFinite(width) || width <= 0) return null;
    const x = Number(obj?.left ?? 0);
    const ox = String(obj?.originX || 'left');
    if (ox === 'center') return { left: x - (width / 2), right: x + (width / 2) };
    if (ox === 'right') return { left: x - width, right: x };
    return { left: x, right: x + width };
};

const measureHorizontalBoundsLocal = (objects: any[]): { left: number; right: number; width: number } | null => {
    const bounds = (objects || [])
        .map((o) => getObjectHorizontalBoundsLocal(o))
        .filter(Boolean) as Array<{ left: number; right: number }>;
    if (!bounds.length) return null;
    const left = Math.min(...bounds.map((b) => b.left));
    const right = Math.max(...bounds.map((b) => b.right));
    return { left, right, width: Math.max(0, right - left) };
};

const normalizeManualPriceChain = (group: any, cacheKey: string, integer: any, decimal: any, unit: any) => {
    if (!group || !integer || !decimal) return;
    const intBounds = getObjectHorizontalBoundsLocal(integer);
    const intX = intBounds ? intBounds.left : Number(integer?.left ?? 0);
    const intY = Number(integer?.top ?? 0);
    const decY = Number(decimal?.top ?? 0);
    const unitY = Number(unit?.top ?? decY);

    const gap = PRICE_INTEGER_DECIMAL_GAP_PX;
    (group as any)[cacheKey] = gap;

    layoutPrice({
        priceInteger: integer,
        priceDecimal: decimal,
        priceUnit: unit,
        intX,
        intY,
        decY,
        unitY,
        gapPx: gap,
        minGapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
        maxGapPx: PRICE_INTEGER_DECIMAL_GAP_PX
    });
};

const readSingleManualPriceAnchors = (priceGroup: any, opts: { force?: boolean } = {}) => {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return null;
    const cached = (priceGroup as any).__manualSingleAnchors;
    // Anchor cache can become stale if it was computed before webfonts loaded.
    // Allow callers to force a recompute (used by fitting code after price text changes).
    if (!opts.force && cached && typeof cached === 'object') return cached;

    const all = collectObjectsDeep(priceGroup);
    const priceBg = findByName(all, 'price_bg');
    const currencyCircle = findByName(all, 'price_currency_bg') || findByName(all, 'priceSymbolBg');
    const currency = findByName(all, 'price_currency_text') || findByName(all, 'priceSymbol') || findByName(all, 'price_currency');
    const integer = findByName(all, 'price_integer_text') || findByName(all, 'priceInteger') || findByName(all, 'price_integer');
    const decimal = findByName(all, 'price_decimal_text') || findByName(all, 'priceDecimal') || findByName(all, 'price_decimal');
    const unit = findByName(all, 'price_unit_text') || findByName(all, 'priceUnit') || findByName(all, 'price_unit');
    if (!priceBg || !integer || !decimal) return null;

    // Ensure text objects have up-to-date width/height before measuring bounds.
    [currency, integer, decimal, unit].forEach((obj: any) => {
        if (!obj) return;
        if (isTextLikeObject(obj) && typeof obj.initDimensions === 'function') obj.initDimensions();
    });

    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const bgBounds = getObjectHorizontalBoundsLocal(priceBg);
    const intBounds = getObjectHorizontalBoundsLocal(integer);
    const unitShown = isObjectShownForBounds(unit) && String(unit?.text || '').trim().length > 0;
    const chain = [integer, decimal, unitShown ? unit : null].filter(Boolean) as any[];
    const chainBounds = measureHorizontalBoundsLocal(chain);
    const curBounds = getObjectHorizontalBoundsLocal(currency);
    const full = [currency, ...chain].filter((o: any) => isObjectShownForBounds(o));
    const fullBounds = measureHorizontalBoundsLocal(full);

    // Anchor the chain start to the integer's authored left edge.
    // This prevents "R$ outside" glitches if centering cannot run due to missing bounds.
    const intX = intBounds ? intBounds.left : Number(integer?.left ?? 0);

    const fallbackPad = Math.max(8, (Math.abs(Number(priceBg.width || 0) * Number(priceBg.scaleX ?? 1)) || 120) * 0.08);
    const padLeft = bgBounds && fullBounds
        ? clamp(fullBounds.left - bgBounds.left, 4, 80)
        : fallbackPad;
    const padRight = bgBounds && fullBounds
        ? clamp(bgBounds.right - fullBounds.right, 4, 80)
        : fallbackPad;

    // Prefer the authored center of the full block, otherwise fall back to bg center.
    // Using bg center avoids "stuck at x=0" when text widths aren't measurable yet.
    const targetCenterX = fullBounds
        ? ((fullBounds.left + fullBounds.right) / 2)
        : (bgBounds
            ? ((bgBounds.left + bgBounds.right) / 2)
            : (chainBounds ? ((chainBounds.left + chainBounds.right) / 2) : 0));
    const intDecGap = PRICE_INTEGER_DECIMAL_GAP_PX;
    const currencyGap = (curBounds && chainBounds)
        ? clamp(chainBounds.left - curBounds.right, -8, 36)
        : 6;

    const anchors = {
        targetCenterX,
        intX,
        intY: Number(integer.top || 0),
        decY: Number(decimal.top || 0),
        unitY: Number(unit?.top || decimal.top || 0),
        currencyY: Number(currency?.top || integer.top || 0),
        intDecGap,
        currencyGap,
        padLeft,
        padRight
    };
    (priceGroup as any).__manualSingleAnchors = anchors;
    return anchors;
};

const fitManualSinglePriceValuesIntoTemplate = (priceGroup: any) => {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return;
    const preserveTemplateVisual = shouldPreserveManualTemplateVisual(priceGroup);
    if (!preserveTemplateVisual) return;

    const all = collectObjectsDeep(priceGroup);
    const hasAtacarejo = !!findByName(all, 'atac_retail_bg');
    if (hasAtacarejo) return;
    if (isRedBurstPriceGroup(priceGroup)) return;

    const priceBg = findByName(all, 'price_bg');
    const currencyCircle = findByName(all, 'price_currency_bg') || findByName(all, 'priceSymbolBg');
    const currency = findByName(all, 'price_currency_text') || findByName(all, 'priceSymbol') || findByName(all, 'price_currency');
    const integer = findByName(all, 'price_integer_text') || findByName(all, 'priceInteger') || findByName(all, 'price_integer');
    const decimal = findByName(all, 'price_decimal_text') || findByName(all, 'priceDecimal') || findByName(all, 'price_decimal');
    const unit = findByName(all, 'price_unit_text') || findByName(all, 'priceUnit') || findByName(all, 'price_unit');
    if (!priceBg || !integer || !decimal) return;

    // Keep the authored anchors from Mini Editor as source of truth.
    // Recompute only as a fallback when metadata is genuinely missing.
    const anchors =
        readSingleManualPriceAnchors(priceGroup) ||
        readSingleManualPriceAnchors(priceGroup, { force: true }) ||
        {};
    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const getW = (obj: any) => (obj && typeof obj.getScaledWidth === 'function') ? Number(obj.getScaledWidth()) : 0;

    const minScale = 0.34;
    const normalizeTemplateScale = (raw: any, fallback: any, min = 0.12, max = 3.2) => {
        const fallbackNum = Number(fallback);
        const safeFallback = Number.isFinite(fallbackNum) && Math.abs(fallbackNum) > 0 ? fallbackNum : 1;
        const parsed = Number(raw);
        if (!Number.isFinite(parsed) || parsed === 0) return safeFallback;
        const sign = parsed < 0 ? -1 : 1;
        const mag = Math.abs(parsed);
        const clamped = clamp(mag, min, max);
        return sign * clamped;
    };

    const restoreBaseScale = (obj: any) => {
        if (!obj || typeof obj.set !== 'function') return;
        const sx = Number((obj as any).__originalScaleX);
        const sy = Number((obj as any).__originalScaleY);
        const fallbackX = Number(obj.scaleX || 1);
        const fallbackY = Number(obj.scaleY || 1);
        obj.set({
            scaleX: normalizeTemplateScale(sx, fallbackX),
            scaleY: normalizeTemplateScale(sy, fallbackY)
        });
        obj.initDimensions?.();
    };
    const centerObjectsX = (objs: any[], centerX = 0) => {
        const shown = (objs || []).filter((o: any) => isObjectShownForBounds(o));
        const bounds = measureHorizontalBoundsLocal(shown);
        if (!bounds) return;
        const currentCenter = (bounds.left + bounds.right) / 2;
        const dx = centerX - currentCenter;
        if (Math.abs(dx) < 0.001) return;
        shown.forEach((obj: any) => obj?.set?.({ left: Number(obj.left || 0) + dx }));
    };
    const fitChainToWidth = (objs: any[], maxW: number, minScale: number) => {
        const shown = (objs || []).filter((o: any) => isObjectShownForBounds(o));
        if (!shown.length || !Number.isFinite(maxW) || maxW <= 0) return;
        const bounds = measureHorizontalBoundsLocal(shown);
        if (!bounds || bounds.width <= maxW) return;
        const s = clamp(maxW / bounds.width, minScale, 1);
        shown.forEach((obj: any) => obj?.set?.({
            scaleX: Number(obj.scaleX || 1) * s,
            scaleY: Number(obj.scaleY || 1) * s
        }));
    };

    restoreBaseScale(integer);
    restoreBaseScale(decimal);
    restoreBaseScale(unit);
    restoreBaseScale(currency);

    const bgBounds = getObjectHorizontalBoundsLocal(priceBg);
    const bgW = Math.max(1, Number(priceBg.width || 0) * Math.abs(Number(priceBg.scaleX ?? 1) || 1));
    const rawPadLeft = Number((anchors as any).padLeft);
    const rawPadRight = Number((anchors as any).padRight);
    const padLeft = clamp(
        Number.isFinite(rawPadLeft) ? rawPadLeft : Math.max(8, bgW * 0.08),
        4,
        Math.max(10, bgW * 0.25)
    );
    const padRight = clamp(
        Number.isFinite(rawPadRight) ? rawPadRight : Math.max(8, bgW * 0.08),
        4,
        Math.max(10, bgW * 0.25)
    );
    const maxTotalW = bgBounds
        ? Math.max(20, (bgBounds.right - bgBounds.left) - padLeft - padRight)
        : Math.max(20, bgW - padLeft - padRight);
    const intDecGap = PRICE_INTEGER_DECIMAL_GAP_PX;
    const intX = Number.isFinite(Number((anchors as any).intX)) ? Number((anchors as any).intX) : 0;
    const intY = Number.isFinite(Number((anchors as any).intY)) ? Number((anchors as any).intY) : Number(integer.top || 0);
    const decY = Number.isFinite(Number((anchors as any).decY)) ? Number((anchors as any).decY) : Number(decimal.top || intY);
    const unitY = Number.isFinite(Number((anchors as any).unitY)) ? Number((anchors as any).unitY) : Number(unit?.top || decY);
    const unitVisible = isObjectShownForBounds(unit) && String(unit?.text || '').trim().length > 0;

    let currencyGap = Number((anchors as any).currencyGap);
    if (!Number.isFinite(currencyGap)) currencyGap = Math.max(2, bgW * 0.018);

    layoutPrice({
        priceInteger: integer,
        priceDecimal: decimal,
        priceUnit: unitVisible ? unit : undefined,
        intX,
        intY,
        decY,
        unitY,
        // Manual templates (Mini Editor) must preserve the authored size hierarchy:
        // we don't shrink the integer alone here; if needed we uniformly scale the whole chain below.
        gapPx: intDecGap,
        minGapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
        maxGapPx: PRICE_INTEGER_DECIMAL_GAP_PX
    });

    const chain = [integer, decimal, unitVisible ? unit : null].filter(Boolean) as any[];
    const chainBounds = measureHorizontalBoundsLocal(chain);
    const hasCurrencyCircle = !!(currencyCircle && isObjectShownForBounds(currencyCircle));
    if (currency && chainBounds) {
        if (hasCurrencyCircle) {
            // Keep the "R$" locked to the yellow circle center from the authored template.
            currency.set?.({
                originX: 'center',
                originY: 'center',
                left: Number(currencyCircle?.left || 0),
                top: Number(currencyCircle?.top || 0)
            });
            currency.initDimensions?.();
        } else {
        currency.set?.({
            originX: 'left',
            originY: 'center',
            left: chainBounds.left - currencyGap - getW(currency),
            top: Number.isFinite(Number((anchors as any).currencyY))
                ? Number((anchors as any).currencyY)
                : Number(integer.top || intY)
        });
        }
    }

    const full = [currency, ...chain].filter((o: any) => isObjectShownForBounds(o));
    const targetCenterX = Number.isFinite(Number((anchors as any).targetCenterX))
        ? Number((anchors as any).targetCenterX)
        : 0;
    const fitTargets = hasCurrencyCircle ? chain : full;
    const maxFitW = hasCurrencyCircle && currency
        ? Math.max(12, maxTotalW - Math.max(0, getW(currency)) - Math.max(0, currencyGap))
        : maxTotalW;
    centerObjectsX(full, targetCenterX);
    fitChainToWidth(fitTargets, maxFitW, minScale);
    centerObjectsX(full, targetCenterX);

    if (bgBounds) {
        if (hasCurrencyCircle) {
            const rightLimit = bgBounds.right - padRight;
            const circleBounds = getObjectHorizontalBoundsLocal(currencyCircle);
            const circleRight = circleBounds ? circleBounds.right : (bgBounds.left + padLeft);
            const leftLimit = Math.max(bgBounds.left + padLeft, circleRight + Math.max(2, currencyGap));

            let chainFitBounds = measureHorizontalBoundsLocal(chain);
            const availableChainW = Math.max(8, rightLimit - leftLimit);
            if (chainFitBounds && chainFitBounds.width > availableChainW) {
                fitChainToWidth(chain, availableChainW, minScale);
                chainFitBounds = measureHorizontalBoundsLocal(chain);
            }
            if (chainFitBounds) {
                let dx = 0;
                if (chainFitBounds.left < leftLimit) dx += (leftLimit - chainFitBounds.left);
                if ((chainFitBounds.right + dx) > rightLimit) dx += (rightLimit - (chainFitBounds.right + dx));
                if (Math.abs(dx) > 0.001) {
                    chain.forEach((obj: any) => obj?.set?.({ left: Number(obj.left || 0) + dx }));
                }
            }
        } else {
            const bounds = measureHorizontalBoundsLocal(full);
            if (bounds) {
                const leftLimit = bgBounds.left + padLeft;
                const rightLimit = bgBounds.right - padRight;
                let dx = 0;
                if (bounds.left < leftLimit) dx += (leftLimit - bounds.left);
                if ((bounds.right + dx) > rightLimit) dx += (rightLimit - (bounds.right + dx));
                if (Math.abs(dx) > 0.001) {
                    full.forEach((obj: any) => obj?.set?.({ left: Number(obj.left || 0) + dx }));
                }
            }
        }
    }

    if (currency && hasCurrencyCircle) {
        // Final pin after any chain recenter/clamp.
        currency.set?.({
            originX: 'center',
            originY: 'center',
            left: Number(currencyCircle?.left || 0),
            top: Number(currencyCircle?.top || 0)
        });
        currency.initDimensions?.();
    }

    if (currency && hasCurrencyCircle) {
        const chainFitBounds = measureHorizontalBoundsLocal(chain);
        const circleBounds = getObjectHorizontalBoundsLocal(currencyCircle);
        if (chainFitBounds && circleBounds) {
            const minChainLeft = circleBounds.right + Math.max(2, currencyGap);
            if (chainFitBounds.left < minChainLeft) {
                const dx = minChainLeft - chainFitBounds.left;
                chain.forEach((obj: any) => obj?.set?.({ left: Number(obj.left || 0) + dx }));
            }
        }
    }

    const parts = priceGroup.getObjects?.() || [];
    parts.forEach((o: any) => o?.setCoords?.());
    priceGroup.dirty = true;
    priceGroup.setCoords?.();
};

const expandManualTemplateWidthForDynamicPrice = (priceGroup: any) => {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return;
    const preserveTemplateVisual = shouldPreserveManualTemplateVisual(priceGroup);
    if (!preserveTemplateVisual) return;

    const all = collectObjectsDeep(priceGroup);
    const retailBg = findByName(all, 'atac_retail_bg');
    const wholesaleBg = findByName(all, 'atac_wholesale_bg');
    const bannerBg = findByName(all, 'atac_banner_bg');
    const hasAtacarejo = !!retailBg;
    let widthChanged = false;

    const applyWidthToRect = (rect: any, width: number) => {
        if (!rect || !Number.isFinite(width) || width <= 0) return;
        const currentW = Number(rect.width || 0);
        if (!(width > currentW + 0.5)) return;
        rect.set({ width });
        widthChanged = true;
    };

    if (hasAtacarejo) {
        normalizeManualPriceChain(
            priceGroup,
            '__manualGapRetail',
            findByName(all, 'retail_integer_text'),
            findByName(all, 'retail_decimal_text'),
            findByName(all, 'retail_unit_text')
        );
        normalizeManualPriceChain(
            priceGroup,
            '__manualGapWholesale',
            findByName(all, 'wholesale_integer_text'),
            findByName(all, 'wholesale_decimal_text'),
            findByName(all, 'wholesale_unit_text')
        );

        const requiredWidthForTier = (bg: any, textObjects: any[]) => {
            if (!bg || !isObjectShownForBounds(bg)) return 0;
            const bgBounds = getObjectHorizontalBoundsLocal(bg);
            const textBounds = measureHorizontalBoundsLocal(textObjects.filter((o: any) => isObjectShownForBounds(o)));
            if (!bgBounds || !textBounds) return Number(bg.width || 0);
            const leftPad = Math.max(10, textBounds.left - bgBounds.left);
            const rightPad = Math.max(10, bgBounds.right - textBounds.right);
            return Math.max(Number(bg.width || 0), textBounds.width + leftPad + rightPad);
        };

        const retailRequired = requiredWidthForTier(retailBg, [
            findByName(all, 'retail_currency_text'),
            findByName(all, 'retail_integer_text'),
            findByName(all, 'retail_decimal_text'),
            findByName(all, 'retail_unit_text'),
            findByName(all, 'retail_pack_line_text')
        ]);
        const wholesaleRequired = requiredWidthForTier(wholesaleBg, [
            findByName(all, 'wholesale_currency_text'),
            findByName(all, 'wholesale_integer_text'),
            findByName(all, 'wholesale_decimal_text'),
            findByName(all, 'wholesale_unit_text'),
            findByName(all, 'wholesale_pack_line_text')
        ]);
        const bannerRequired = requiredWidthForTier(bannerBg, [
            findByName(all, 'wholesale_banner_text')
        ]);

        const currentWidths = [retailBg, wholesaleBg, bannerBg]
            .filter(Boolean)
            .map((o: any) => Number(o.width || 0));
        const targetW = Math.max(
            ...(currentWidths.length ? currentWidths : [0]),
            retailRequired,
            wholesaleRequired,
            bannerRequired
        );

        if (targetW > 0) {
            applyWidthToRect(retailBg, targetW);
            applyWidthToRect(wholesaleBg, targetW);
            applyWidthToRect(bannerBg, targetW);
        }
    } else {
        const integer = findByName(all, 'price_integer_text') || findByName(all, 'priceInteger') || findByName(all, 'price_integer');
        const decimal = findByName(all, 'price_decimal_text') || findByName(all, 'priceDecimal') || findByName(all, 'price_decimal');
        const unit = findByName(all, 'price_unit_text') || findByName(all, 'priceUnit') || findByName(all, 'price_unit');
        normalizeManualPriceChain(priceGroup, '__manualGapSingle', integer, decimal, unit);

        const priceBg = findByName(all, 'price_bg');
        const textBounds = measureHorizontalBoundsLocal([
            findByName(all, 'price_currency_text'),
            integer,
            decimal,
            unit,
            findByName(all, 'price_value_text'),
            findByName(all, 'smart_price')
        ].filter(Boolean));
        const bgBounds = getObjectHorizontalBoundsLocal(priceBg);
        if (priceBg && textBounds && bgBounds) {
            const leftPad = Math.max(8, textBounds.left - bgBounds.left);
            const rightPad = Math.max(8, bgBounds.right - textBounds.right);
            const requiredW = Math.max(Number(priceBg.width || 0), textBounds.width + leftPad + rightPad);
            if (requiredW > Number(priceBg.width || 0) + 0.5) {
                const roundness =
                    typeof (priceBg as any).__roundness === 'number'
                        ? Math.max(0, Math.min(1, Number((priceBg as any).__roundness)))
                        : null;
                const nextRadius = roundness !== null
                    ? ((Number(priceBg.height || 0) / 2) * roundness)
                    : Number(priceBg.rx || 0);
                priceBg.set({
                    width: requiredW,
                    rx: nextRadius,
                    ry: nextRadius
                });
                widthChanged = true;
            }
        }
    }

    if (widthChanged) {
        safeAddWithUpdate(priceGroup);
    } else {
        const parts = priceGroup.getObjects?.() || [];
        parts.forEach((o: any) => o?.setCoords?.());
        priceGroup.dirty = true;
        priceGroup.setCoords?.();
    }
};

const fitManualAtacarejoValuesIntoTemplate = (priceGroup: any) => {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return;
    // IMPORTANT:
    // Even when templates have independent `__atacVariantGroups`, we still must fit dynamic product
    // values into the CURRENT instance geometry. This does not mutate the stored snapshots; it only
    // adjusts the objects inside this card's `priceGroup` to avoid overlaps.

    const preserveTemplateVisual = shouldPreserveManualTemplateVisual(priceGroup);
    if (!preserveTemplateVisual) return;

    const all = collectObjectsDeep(priceGroup);
    const retailBg = findByName(all, 'atac_retail_bg');
    const wholesaleBg = findByName(all, 'atac_wholesale_bg');
    const bannerBg = findByName(all, 'atac_banner_bg');
    if (!retailBg) return;

    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const normalizeTemplateScale = (raw: any, fallback: any, min = 0.12, max = 3.2) => {
        const fallbackNum = Number(fallback);
        const safeFallback = Number.isFinite(fallbackNum) && Math.abs(fallbackNum) > 0 ? fallbackNum : 1;
        const parsed = Number(raw);
        if (!Number.isFinite(parsed) || parsed === 0) return safeFallback;
        const sign = parsed < 0 ? -1 : 1;
        const mag = Math.abs(parsed);
        const clamped = clamp(mag, min, max);
        return sign * clamped;
    };
    const getW = (obj: any) => (obj && typeof obj.getScaledWidth === 'function') ? Number(obj.getScaledWidth()) : 0;
    type AtacValueVariantKey = 'tiny' | 'normal' | 'large';
    type AtacValueVariantConfig = {
        chainWidthRatio: number;
        minScale: number;
        intDecimalGap: number;
        currencyGapRatio: number;
        packWidthRatio: number;
    };
    const DEFAULT_ATAC_VALUE_VARIANTS: Record<AtacValueVariantKey, AtacValueVariantConfig> = {
        // 1,99 / 0,33
        tiny: {
            chainWidthRatio: 0.48,
            minScale: 0.62,
            intDecimalGap: PRICE_INTEGER_DECIMAL_GAP_PX,
            currencyGapRatio: 0.02,
            packWidthRatio: 0.86
        },
        // 12,99
        normal: {
            chainWidthRatio: 0.64,
            minScale: 0.56,
            intDecimalGap: PRICE_INTEGER_DECIMAL_GAP_PX,
            currencyGapRatio: 0.024,
            packWidthRatio: 0.9
        },
        // 119,99 / 1.299,99+
        large: {
            chainWidthRatio: 0.82,
            minScale: 0.44,
            intDecimalGap: PRICE_INTEGER_DECIMAL_GAP_PX,
            currencyGapRatio: 0.03,
            packWidthRatio: 0.95
        }
    };
    const asFinite = (value: any, fallback: number) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : fallback;
    };
    const getIntegerDigitsCount = (obj: any) => {
        const raw = String(obj?.text ?? '').replace(/[^\d]/g, '');
        const normalized = raw.replace(/^0+(?=\d)/, '');
        return Math.max(1, normalized.length || raw.length || 1);
    };
    const resolveVariantKey = (digitsCount: number): AtacValueVariantKey => {
        if (digitsCount <= 1) return 'tiny';
        if (digitsCount === 2) return 'normal';
        // 3+ digits need the "large" fitting behavior (e.g. 119,99 / 129,99).
        return 'large';
    };
    const getMergedVariant = (key: AtacValueVariantKey): AtacValueVariantConfig => {
        const fromTemplate = ((priceGroup as any).__atacValueVariants || {})?.[key] || {};
        const base = DEFAULT_ATAC_VALUE_VARIANTS[key];
        return {
            chainWidthRatio: clamp(asFinite(fromTemplate.chainWidthRatio, base.chainWidthRatio), 0.35, 0.95),
            minScale: clamp(asFinite(fromTemplate.minScale, base.minScale), 0.30, 1),
            intDecimalGap: PRICE_INTEGER_DECIMAL_GAP_PX,
            currencyGapRatio: clamp(asFinite(fromTemplate.currencyGapRatio, base.currencyGapRatio), 0.005, 0.08),
            packWidthRatio: clamp(asFinite(fromTemplate.packWidthRatio, base.packWidthRatio), 0.55, 0.99),
        };
    };
    const getInnerWidth = (bg: any, padRatio: number, minPad: number, maxPad: number) => {
        if (!bg) return 0;
        const bw = Math.max(1, Number(bg.width || 0) * Math.abs(Number(bg.scaleX ?? 1) || 1));
        const pad = clamp(bw * padRatio, minPad, maxPad);
        return Math.max(8, bw - (pad * 2));
    };

    const restoreBaseScale = (obj: any) => {
        if (!obj || typeof obj.set !== 'function') return;
        const sx = Number((obj as any).__originalScaleX);
        const sy = Number((obj as any).__originalScaleY);
        const fallbackX = Number(obj.scaleX || 1);
        const fallbackY = Number(obj.scaleY || 1);
        obj.set({
            scaleX: normalizeTemplateScale(sx, fallbackX),
            scaleY: normalizeTemplateScale(sy, fallbackY)
        });
        obj.initDimensions?.();
    };

    const fitText = (obj: any, maxW: number, minScale: number) => {
        if (!obj || !Number.isFinite(maxW) || maxW <= 0) return;
        restoreBaseScale(obj);
        const w = getW(obj);
        if (!w || w <= maxW) return;
        const s = clamp(maxW / w, minScale, 1);
        obj.set?.({
            scaleX: Number(obj.scaleX || 1) * s,
            scaleY: Number(obj.scaleY || 1) * s
        });
    };

    const fitChain = (objs: any[], maxW: number, minScale: number) => {
        const shown = (objs || []).filter((o: any) => isObjectShownForBounds(o));
        if (!shown.length || !Number.isFinite(maxW) || maxW <= 0) return;
        shown.forEach((o: any) => restoreBaseScale(o));
        const bounds = measureHorizontalBoundsLocal(shown);
        if (!bounds || bounds.width <= maxW) return;
        const s = clamp(maxW / bounds.width, minScale, 1);
        shown.forEach((o: any) => o?.set?.({
            scaleX: Number(o.scaleX || 1) * s,
            scaleY: Number(o.scaleY || 1) * s
        }));
    };
    const centerObjectsX = (objs: any[], centerX = 0) => {
        if (!Array.isArray(objs) || !objs.length) return;
        const bounds = measureHorizontalBoundsLocal(objs);
        if (!bounds) return;
        const currentCenter = (bounds.left + bounds.right) / 2;
        const dx = centerX - currentCenter;
        if (Math.abs(dx) < 0.001) return;
        objs.forEach((obj: any) => obj?.set?.({ left: Number(obj.left || 0) + dx }));
    };
    const applyTierVariant = (opts: {
        bg: any;
        currency: any;
        integer: any;
        decimal: any;
        unit: any;
        pack: any;
    }) => {
        const { bg, currency, integer, decimal, unit, pack } = opts;
        if (!bg || !integer || !decimal) return;

        const digits = getIntegerDigitsCount(integer);
        const variant = getMergedVariant(resolveVariantKey(digits));
        const maxW = getInnerWidth(bg, 0.075, 12, 34);
        restoreBaseScale(integer);
        restoreBaseScale(decimal);
        restoreBaseScale(unit);
        restoreBaseScale(currency);

        const intY = Number(integer.top || 0);
        const decY = Number(decimal.top || intY);
        const unitY = Number(unit?.top || decY);
        const unitVisible = isObjectShownForBounds(unit);

        layoutPrice({
            priceInteger: integer,
            priceDecimal: decimal,
            priceUnit: unitVisible ? unit : undefined,
            intX: 0,
            intY,
            decY,
            unitY,
            // Manual templates (Mini Editor): keep authored hierarchy and avoid "integer-only shrink".
            // If values overflow, we uniformly scale the whole chain afterwards.
            gapPx: variant.intDecimalGap,
            minGapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
            maxGapPx: PRICE_INTEGER_DECIMAL_GAP_PX
        });

        const chain = [integer, decimal, unitVisible ? unit : null].filter(Boolean) as any[];
        const chainBounds = measureHorizontalBoundsLocal(chain);
        if (currency && chainBounds) {
            const curGap = Math.max(2, maxW * variant.currencyGapRatio);
            currency.set?.({
                originX: 'left',
                originY: 'center',
                left: chainBounds.left - curGap - getW(currency)
            });
        }

        const full = [currency, ...chain].filter((o: any) => isObjectShownForBounds(o));
        centerObjectsX(full, 0);
        fitChain(full, maxW, variant.minScale);
        centerObjectsX(full, 0);

        if (pack && isObjectShownForBounds(pack)) {
            fitText(pack, maxW * variant.packWidthRatio, 0.50);
        }
    };

    const retailCurrency = findByName(all, 'retail_currency_text');
    const retailInteger = findByName(all, 'retail_integer_text');
    const retailDecimal = findByName(all, 'retail_decimal_text');
    const retailUnit = findByName(all, 'retail_unit_text');
    const retailPack = findByName(all, 'retail_pack_line_text');

    const wholesaleCurrency = findByName(all, 'wholesale_currency_text');
    const wholesaleInteger = findByName(all, 'wholesale_integer_text');
    const wholesaleDecimal = findByName(all, 'wholesale_decimal_text');
    const wholesaleUnit = findByName(all, 'wholesale_unit_text');
    const wholesalePack = findByName(all, 'wholesale_pack_line_text');
    const bannerText = findByName(all, 'wholesale_banner_text');

    const retailInnerW = getInnerWidth(retailBg, 0.075, 12, 34);
    const wholesaleInnerW = getInnerWidth(wholesaleBg, 0.075, 12, 34);
    const bannerInnerW = getInnerWidth(bannerBg, 0.060, 8, 28);

    applyTierVariant({
        bg: retailBg,
        currency: retailCurrency,
        integer: retailInteger,
        decimal: retailDecimal,
        unit: retailUnit,
        pack: retailPack
    });
    applyTierVariant({
        bg: wholesaleBg,
        currency: wholesaleCurrency,
        integer: wholesaleInteger,
        decimal: wholesaleDecimal,
        unit: wholesaleUnit,
        pack: wholesalePack
    });

    fitText(retailPack, retailInnerW, 0.50);
    fitText(wholesalePack, wholesaleInnerW, 0.50);
    fitText(bannerText, bannerInnerW, 0.50);
};

const inferUnitLabelFromProduct = (product: any): 'KG' | 'UN' => {
    // Priority:
    // 1) explicit product.unit
    // 2) Detect based on name: if has NUMBER before weight unit → UN, else → KG
    // 3) packUnit if present
    // 4) default UN

    const unitRaw = String(product?.unit ?? '').trim();
    if (unitRaw) return normalizeUnitForLabel(unitRaw);

    const name = String(product?.name ?? '');
    const weight = String(product?.weight ?? '');
    const packageLabel = String(product?.packageLabel ?? '');
    const probe = `${name} ${weight} ${packageLabel}`.toUpperCase();

    // CRITICAL: Check if there's a NUMBER before the weight unit (KG, G, ML, L)
    // Pattern like "5KG", "500G", "2L" = sold by unit → use "UN"
    // Pattern like "KG", "G" without number = sold by kilo → use "KG"
    const hasNumberBeforeWeightUnit = /\d+\s*(?:KG|G|ML|L)\b/.test(probe);
    const hasWeightUnitWithoutNumber = /\b(?:KG|G|ML|L)\b/.test(probe) && !hasNumberBeforeWeightUnit;

    if (hasWeightUnitWithoutNumber) return 'KG'; // Vendido por quilo (ex: "ARROZ KG")
    if (hasNumberBeforeWeightUnit) return 'UN'; // Vendido por unidade (ex: "ARROZ 5KG")

    // Fallback to packUnit
    const packUnitRaw = String(product?.packUnit ?? '').trim();
    const packUnitNorm = packUnitRaw ? normalizeUnitForLabel(packUnitRaw) : '';
    if (packUnitNorm === 'KG') return 'KG';
    if (packUnitNorm === 'UN') return 'UN';

    return 'UN';
};

const computePackLine = (opts: { packageLabel?: any; packQuantity?: any; packUnit?: any; packPrice?: any; itemUnit?: any }): string | null => {
    const label = String(opts.packageLabel ?? '').trim().toUpperCase().replace(/\s+/g, '');
    const q = Number.parseInt(String(opts.packQuantity ?? '').replace(/[^\d]/g, ''), 10);
    const packUnitToken = String(opts.packUnit ?? '').trim().toUpperCase().replace(/\s+/g, '');
    const itemUnit = normalizeUnitForLabel(opts.itemUnit ?? '');
    const packagingTokens = new Set(['FD', 'FARDO', 'FARDOS', 'CX', 'CAIXA', 'CAIXAS', 'PCT', 'PACOTE', 'PACOTES', 'PC']);
    // If `packUnit` is actually another package token (e.g. FD/CX), use the product unit (UN/KG) on "C/X".
    const unit = (!packUnitToken || packUnitToken === label || packagingTokens.has(packUnitToken))
        ? itemUnit
        : normalizeUnitForLabel(packUnitToken);
    const price = String(opts.packPrice ?? '').trim();
    if (!label || !Number.isFinite(q) || q <= 0 || !unit || !price) return null;
    if (q === 1) return `1 ${unit}: R$ ${price}`;
    return `${label} C/${q}${unit}: R$ ${price}`;
};

const setText = (obj: any, text: string) => {
    if (!obj || typeof obj.set !== 'function') return;
    obj.set('text', text);
    if (typeof obj.initDimensions === 'function') obj.initDimensions();
};

const setVisible = (obj: any, visible: boolean) => {
    if (!obj || typeof obj.set !== 'function') return;
    const clampScale = (raw: any, fallback: any, min = 0.08, max = 3.2) => {
        const fb = Number(fallback);
        const safeFallback = Number.isFinite(fb) && Math.abs(fb) > 0 ? fb : 1;
        const n = Number(raw);
        if (!Number.isFinite(n) || n === 0) return safeFallback;
        const sign = n < 0 ? -1 : 1;
        const mag = Math.min(max, Math.max(min, Math.abs(n)));
        return sign * mag;
    };
    const toFinite = (v: any) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : undefined;
    };

    if (visible) {
        const fallbackX = (toFinite(obj.scaleX) && Math.abs(Number(obj.scaleX)) > 0) ? Number(obj.scaleX) : 1;
        const fallbackY = (toFinite(obj.scaleY) && Math.abs(Number(obj.scaleY)) > 0) ? Number(obj.scaleY) : 1;
        const restoreScaleX = clampScale(
            toFinite((obj as any).__visibleScaleX) ?? toFinite((obj as any).__originalScaleX),
            fallbackX
        );
        const restoreScaleY = clampScale(
            toFinite((obj as any).__visibleScaleY) ?? toFinite((obj as any).__originalScaleY),
            fallbackY
        );
        obj.set({ visible: true, scaleX: restoreScaleX, scaleY: restoreScaleY });
        return;
    }

    // Preserve the current visual scale so showing again does not reset manual edits.
    const sx = toFinite(obj.scaleX);
    const sy = toFinite(obj.scaleY);
    if (sx != null && Math.abs(sx) > 0) (obj as any).__visibleScaleX = sx;
    if (sy != null && Math.abs(sy) > 0) (obj as any).__visibleScaleY = sy;

    // `visible=false` can still affect group bounds in Fabric; scale-to-zero avoids giant selections.
    obj.set({ visible: false, scaleX: 0, scaleY: 0 });
};

const applyAtacarejoPricingToPriceGroup = (pg: any, data: any) => {
    if (!pg || typeof pg.getObjects !== 'function') return;
    const all = collectObjectsDeep(pg);
    const byName = (name: string) => all.filter((o: any) => o?.name === name);

    const retailBg = findByName(all, 'atac_retail_bg');
    const bannerBg = findByName(all, 'atac_banner_bg');
    const wholesaleBg = findByName(all, 'atac_wholesale_bg');
    // Not an atacarejo template
    if (!retailBg) return;

    const retailCurrency = findByName(all, 'retail_currency_text');
    const retailInteger = findByName(all, 'retail_integer_text');
    const retailDecimal = findByName(all, 'retail_decimal_text');
    const retailUnit = findByName(all, 'retail_unit_text');
    const retailPack = findByName(all, 'retail_pack_line_text');

    const bannerText = findByName(all, 'wholesale_banner_text');

    const wholesaleCurrency = findByName(all, 'wholesale_currency_text');
    const wholesaleInteger = findByName(all, 'wholesale_integer_text');
    const wholesaleDecimal = findByName(all, 'wholesale_decimal_text');
    const wholesaleUnit = findByName(all, 'wholesale_unit_text');
    const wholesalePack = findByName(all, 'wholesale_pack_line_text');

    // Hide legacy single-price artifacts that may exist in older/custom templates.
    // This prevents stray "UN" text from appearing when atacarejo collapses to one tier.
    const legacySinglePriceNames = [
        'price_unit_text',
        'priceUnit',
        'price_unit',
        'price_integer_text',
        'priceInteger',
        'price_integer',
        'price_decimal_text',
        'priceDecimal',
        'price_decimal',
        'price_currency_text',
        'price_currency',
        'priceSymbol',
        'price_value_text',
        'smart_price'
    ];
    legacySinglePriceNames.forEach((n) => {
        byName(n).forEach((obj: any) => setVisible(obj, false));
    });

    // ===== NOVO SISTEMA: Obter preços disponíveis dinamicamente =====
    const availablePrices = getAvailablePrices(data);
    const prices = availablePrices.prices;

    // DEBUG: Log para ver os preços disponíveis
    console.log('🔍 [applyAtacarejoPricing] Produto:', data?.name);
    console.log('🔍 [applyAtacarejoPricing] Preços disponíveis:', prices.map(p => ({ type: p.type, value: p.value, label: p.label })));
    console.log('🔍 [applyAtacarejoPricing] Dados brutos:', {
        priceUnit: data?.priceUnit,
        pricePack: data?.pricePack,
        priceSpecial: data?.priceSpecial,
        priceSpecialUnit: data?.priceSpecialUnit,
        priceWholesale: data?.priceWholesale,
        specialCondition: data?.specialCondition
    });

    // Determinar preço varejo (regular) e atacado (especial)
    let retailPrice = null;
    let wholesalePrice = null;
    let condition = null;

    // Buscar preço regular (varejo) e preço especial (atacado)
    // No atacarejo: special = preço menor (atacado), main/pack = preço maior (varejo)
    for (const p of prices) {
        if (p.type === 'main' || p.type === 'pack') {
            retailPrice = retailPrice || p.value;
        } else if (p.type === 'special') {
            wholesalePrice = wholesalePrice || p.value;
        }
    }

    // Se não encontrou, usar legado
    if (!retailPrice) {
        retailPrice = formatPriceValue(data?.priceUnit ?? data?.pricePack ?? data?.price);
    }
    if (!wholesalePrice) {
        wholesalePrice = formatPriceValue(data?.priceSpecialUnit ?? data?.priceSpecial ?? data?.priceWholesale);
    }
    condition = availablePrices.condition ?? getSpecialConditionFromProduct(data);

    console.log('🔍 [applyAtacarejoPricing] Resultado:', { retailPrice, wholesalePrice, condition, hasRetail: !!retailPrice, hasWholesale: !!wholesalePrice });

    // Se retail e wholesale são iguais, é produto simples — não mostrar duas faixas
    if (retailPrice && wholesalePrice && retailPrice === wholesalePrice && !condition) {
        wholesalePrice = null;
    }

    const hasRetail = !!retailPrice;
    const hasWholesale = !!wholesalePrice;

    // Mostrar banner também quando existe observação/condição, mesmo com 1 único preço.
    const hasCondition = !!condition;
    const showBanner = (hasRetail && hasWholesale) || (hasCondition && (hasRetail || hasWholesale));
    setVisible(bannerBg, showBanner);
    setVisible(bannerText, showBanner);
    setVisible(wholesaleBg, hasWholesale);
    setVisible(wholesaleCurrency, hasWholesale);
    setVisible(wholesaleInteger, hasWholesale);
    setVisible(wholesaleDecimal, hasWholesale);
    setVisible(wholesaleUnit, hasWholesale);
    setVisible(wholesalePack, hasWholesale);
    setVisible(retailBg, hasRetail || !hasWholesale);
    setVisible(retailCurrency, hasRetail || !hasWholesale);
    setVisible(retailInteger, hasRetail || !hasWholesale);
    setVisible(retailDecimal, hasRetail || !hasWholesale);
    setVisible(retailUnit, hasRetail || !hasWholesale);
    setVisible(retailPack, hasRetail || !hasWholesale);

    // Hard-sync tier visibility for duplicated/legacy nodes:
    // prevents orphan "UN" texts when only one tier exists.
    const hideWholesaleTier = !hasWholesale;
    const hideRetailTier = !(hasRetail || !hasWholesale);
    if (hideWholesaleTier) {
        all.forEach((obj: any) => {
            const n = String(obj?.name || '');
            if (!n) return;
            if (n.startsWith('wholesale_') && n !== 'wholesale_banner_text') {
                setVisible(obj, false);
            }
        });
    }
    if (hideRetailTier) {
        all.forEach((obj: any) => {
            const n = String(obj?.name || '');
            if (!n) return;
            if (n.startsWith('retail_')) {
                setVisible(obj, false);
            }
        });
    }

    if (retailCurrency && (!retailCurrency.text || String(retailCurrency.text).trim().length === 0)) setText(retailCurrency, 'R$');
    if (wholesaleCurrency && (!wholesaleCurrency.text || String(wholesaleCurrency.text).trim().length === 0)) setText(wholesaleCurrency, 'R$');

    if (hasRetail || !hasWholesale) {
        const parts = splitPriceParts(retailPrice);
        setText(retailInteger, parts.integer);
        setText(retailDecimal, `,${parts.dec}`);
    }

    if (hasWholesale) {
        const parts = splitPriceParts(wholesalePrice);
        setText(wholesaleInteger, parts.integer);
        setText(wholesaleDecimal, `,${parts.dec}`);
    }

    // Unit label: infer from product fields (never let a default "UN" override a clear "KG" in the name).
    const unitLabel = inferUnitLabelFromProduct(data);
    if (retailUnit) setText(retailUnit, unitLabel);
    if (wholesaleUnit) setText(wholesaleUnit, unitLabel);

    const packageLabel = String(data?.packageLabel ?? data?.wholesaleTriggerUnit ?? '').trim().toUpperCase().replace(/\s+/g, '');
    const packQuantity = Number.parseInt(String(data?.packQuantity ?? '').replace(/[^\d]/g, ''), 10);
    const packUnit = String(data?.packUnit ?? '').trim().toUpperCase().replace(/\s+/g, '');

    const retailCents = parsePriceToCents(retailPrice);
    const wholesaleCents = parsePriceToCents(wholesalePrice);
    const retailPackPrice = (retailCents !== null && Number.isFinite(packQuantity) && packQuantity > 0)
        ? formatCentsToPrice(retailCents * packQuantity)
        : null;
    const wholesalePackPrice = (wholesaleCents !== null && Number.isFinite(packQuantity) && packQuantity > 0)
        ? formatCentsToPrice(wholesaleCents * packQuantity)
        : null;

    const retailPackLine = computePackLine({ packageLabel, packQuantity, packUnit, packPrice: retailPackPrice, itemUnit: unitLabel });
    const wholesalePackLine = computePackLine({ packageLabel, packQuantity, packUnit, packPrice: wholesalePackPrice, itemUnit: unitLabel });

    if (retailPack) {
        const txt = retailPackLine || '';
        setText(retailPack, txt);
        setVisible(retailPack, !!txt);
    }
    if (wholesalePack) {
        const txt = wholesalePackLine || '';
        setText(wholesalePack, txt);
        setVisible(wholesalePack, !!txt);
    }

    if (bannerText) {
        // Usar condição especial se disponível, senão usar lógica legada
        let bannerLabel = 'ATACADO';
        if (condition) {
            // Limpar e formatar a condição para caber no banner
            let cleanCondition = condition.toUpperCase().trim();
            // Remover pontuação final desnecessária
            cleanCondition = cleanCondition.replace(/[.;,]+$/, '').trim();
            // Se é "ACIMA DE X UN/FD/CX" — formato compacto para o banner
            const condMatch = cleanCondition.match(/(?:ACIMA\s+DE\s+|A\s+PARTIR\s+DE\s+|MIN\.?\s*)(\d+)\s*(.+)/i);
            if (condMatch) {
                const qty = condMatch[1];
                let unit = (condMatch[2] ?? '').trim().replace(/\.+$/, '');
                // Normalizar unidade para abreviatura
                const unitNorm: Record<string, string> = {
                    'UNIDADES': 'UN', 'UNIDADE': 'UN', 'UND': 'UN', 'UN': 'UN',
                    'FARDOS': 'FD', 'FARDO': 'FD', 'FD': 'FD',
                    'CAIXAS': 'CX', 'CAIXA': 'CX', 'CX': 'CX',
                    'PACOTES': 'PCT', 'PACOTE': 'PCT', 'PCT': 'PCT',
                };
                unit = unitNorm[unit.toUpperCase()] || unit;
                bannerLabel = `ACIMA ${qty} ${unit}`;
            } else {
                bannerLabel = cleanCondition;
            }
        } else {
            const trig = data?.wholesaleTrigger;
            const trigN = typeof trig === 'number' ? trig : Number.parseInt(String(trig ?? '').replace(/[^\d]/g, ''), 10);
            const unitTok = String(data?.wholesaleTriggerUnit ?? packageLabel ?? '').trim().toUpperCase().replace(/\s+/g, '');
            if (Number.isFinite(trigN) && trigN > 0 && unitTok) {
                bannerLabel = `ACIMA ${trigN} ${unitTok}`;
            }
        }
        setText(bannerText, `\u2605 ${bannerLabel} \u2605`);
    }

    const preserveTemplateVisual = shouldPreserveManualTemplateVisual(pg);
    const forceCanonicalAtac = (pg as any)?.__forceAtacarejoCanonical === true;
    // Canonical layout: runtime layout function will place/fit values. Do not pre-fit here.
    if (preserveTemplateVisual && !forceCanonicalAtac) {
        // Use Etiquetas template geometry as source-of-truth and only fit dynamic values.
        fitManualAtacarejoValuesIntoTemplate(pg);
        const parts = typeof pg.getObjects === 'function' ? (pg.getObjects() || []) : [];
        parts.forEach((o: any) => o?.setCoords?.());
        pg.dirty = true;
        pg.setCoords?.();
    } else {
        safeAddWithUpdate(pg);
    }
};

const layoutAtacarejoPriceGroup = (priceGroup: any, cardW: number, cardH: number) => {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return null;
    const all = collectObjectsDeep(priceGroup);

    const retailBg = findByName(all, 'atac_retail_bg');
    if (!retailBg) return null;

    const bannerBg = findByName(all, 'atac_banner_bg');
    const wholesaleBg = findByName(all, 'atac_wholesale_bg');

    const retailCurrency = findByName(all, 'retail_currency_text');
    const retailInteger = findByName(all, 'retail_integer_text');
    const retailDecimal = findByName(all, 'retail_decimal_text');
    const retailUnit = findByName(all, 'retail_unit_text');
    const retailPack = findByName(all, 'retail_pack_line_text');

    const bannerText = findByName(all, 'wholesale_banner_text');

    const wholesaleCurrency = findByName(all, 'wholesale_currency_text');
    const wholesaleInteger = findByName(all, 'wholesale_integer_text');
    const wholesaleDecimal = findByName(all, 'wholesale_decimal_text');
    const wholesaleUnit = findByName(all, 'wholesale_unit_text');
    const wholesalePack = findByName(all, 'wholesale_pack_line_text');

    const isShown = (o: any) => !!(o && o.visible !== false && (o.scaleX ?? 1) !== 0 && (o.scaleY ?? 1) !== 0);
    let showRetail = isShown(retailBg);
    let showWholesale = isShown(wholesaleBg);
    const bannerHasText = String((bannerText as any)?.text || '').trim().length > 0;
    const showBanner = bannerHasText || isShown(bannerBg) || isShown(bannerText);
    if (showBanner) {
        setVisible(bannerBg, true);
        setVisible(bannerText, true);
    }

    // Never leave an empty tag block: if both tiers are hidden, show retail as fallback.
    if (!showRetail && !showWholesale) {
        showRetail = true;
        setVisible(retailBg, true);
        setVisible(retailCurrency, true);
        setVisible(retailInteger, true);
        setVisible(retailDecimal, true);
        setVisible(retailUnit, true);
    }

    // Guarantee collapsed tiers stay fully hidden (including duplicated text nodes).
    if (!showWholesale) {
        all.forEach((obj: any) => {
            const n = String(obj?.name || '');
            if (!n) return;
            if (n.startsWith('wholesale_') && n !== 'wholesale_banner_text') {
                setVisible(obj, false);
            }
        });
    }
    if (!showRetail) {
        all.forEach((obj: any) => {
            const n = String(obj?.name || '');
            if (!n) return;
            if (n.startsWith('retail_')) {
                setVisible(obj, false);
            }
        });
    }

    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));

    // Canonical Atacarejo style (fixed visual language, dynamic values).
    // Values can vary, but geometry/font hierarchy stays consistent.
    // Requested: slightly narrower blocks, and taller red/yellow tiers so prices like 7,24 / 7,18
    // stay inside their rectangles without invading the banner area.
    const totalW = clamp(cardW * 0.88, 170, cardW * 0.94);
    const totalH = clamp(cardH * 0.52, 160, cardH * 0.74);
    const padX = clamp(totalW * 0.045, 10, 22);
    const sectionGap = clamp(totalH * 0.016, 4, 8);

    const sections: Array<'retail' | 'banner' | 'wholesale'> = [];
    if (showRetail) sections.push('retail');
    if (showBanner) sections.push('banner');
    if (showWholesale) sections.push('wholesale');
    const gapCount = Math.max(0, sections.length - 1);
    const usableH = Math.max(24, totalH - (sectionGap * gapCount));

    let retailH = 0;
    let bannerH = 0;
    let wholesaleH = 0;
    if (showRetail && showWholesale) {
        if (showBanner) {
            // Keep each tier clearly separated:
            // red = top price, white = condition, yellow = highlighted cheapest price.
            retailH = clamp(usableH * 0.32, 44, 86);
            bannerH = clamp(usableH * 0.16, 22, 40);
            wholesaleH = usableH - retailH - bannerH;
            if (wholesaleH < 68) {
                const need = 68 - wholesaleH;
                const giveFromBanner = Math.min(need, Math.max(0, bannerH - 20));
                bannerH -= giveFromBanner;
                const rest1 = need - giveFromBanner;
                const giveFromRetail = Math.min(rest1, Math.max(0, retailH - 40));
                retailH -= giveFromRetail;
                wholesaleH = usableH - retailH - bannerH;
            }
        } else {
            retailH = usableH * 0.36;
            wholesaleH = usableH - retailH;
        }
    } else if (showRetail || showWholesale) {
        if (showBanner) {
            bannerH = clamp(usableH * 0.22, 22, 40);
            if (showRetail) retailH = usableH - bannerH;
            if (showWholesale) wholesaleH = usableH - bannerH;
        } else {
            if (showRetail) retailH = usableH;
            if (showWholesale) wholesaleH = usableH;
        }
    }

    const centers: { retail: number; banner: number; wholesale: number } = {
        retail: 0,
        banner: 0,
        wholesale: 0
    };
    let y = -totalH / 2;
    sections.forEach((section, idx) => {
        const h = section === 'retail' ? retailH : section === 'banner' ? bannerH : wholesaleH;
        centers[section] = y + (h / 2);
        y += h;
        if (idx < sections.length - 1) y += sectionGap;
    });

    const setBg = (bg: any, h: number, cy: number, rx: number, color?: string) => {
        if (!bg || typeof bg.set !== 'function') return;
        bg.set({
            width: totalW,
            height: h,
            rx,
            ry: rx,
            originX: 'center',
            originY: 'center',
            left: 0,
            top: cy,
            ...(color ? { fill: color } : {})
        });
    };

    const setTextSizing = (txt: any, defaultScale: number, baseH: number, color?: string) => {
        if (!txt || !String(txt.type || '').includes('text')) return;
        txt.set({
            fontFamily: 'Inter',
            fontWeight: '900',
            fill: color ?? txt.fill,
            fontSize: Math.max(8, baseH * defaultScale),
            scaleX: 1,
            scaleY: 1
        });
        if (typeof txt.initDimensions === 'function') txt.initDimensions();
    };
    const getW = (t: any) => (t && typeof t.getScaledWidth === 'function' ? t.getScaledWidth() : 0);
    const getH = (t: any) => (t && typeof t.getScaledHeight === 'function' ? t.getScaledHeight() : 0);
    const getVerticalBounds = (obj: any) => {
        if (!obj) return null;
        const h = getH(obj);
        if (!h || !Number.isFinite(h)) return null;
        const y0 = Number(obj.top || 0);
        const oy = String(obj.originY || 'top');
        if (oy === 'center') return { min: y0 - (h / 2), max: y0 + (h / 2) };
        if (oy === 'bottom') return { min: y0 - h, max: y0 };
        return { min: y0, max: y0 + h };
    };

    const fitTextWidth = (txt: any, maxW: number, minScale: number = 0.6) => {
        if (!txt || !Number.isFinite(maxW) || maxW <= 0) return;
        const w = getW(txt);
        if (!w || w <= maxW) return;
        const s = clamp(maxW / w, minScale, 1);
        txt.set?.({ scaleX: s, scaleY: s });
    };

    if (showRetail) setBg(retailBg, retailH, centers.retail, clamp(retailH * 0.22, 10, 28), '#EF4444');
    if (showBanner && bannerBg) setBg(bannerBg, bannerH, centers.banner, clamp(bannerH * 0.48, 8, 20), '#FFFFFF');
    if (showWholesale) setBg(wholesaleBg, wholesaleH, centers.wholesale, clamp(wholesaleH * 0.22, 10, 28), '#FDE047');

    const layoutTier = (tier: {
        blockH: number;
        blockCY: number;
        currency: any;
        integer: any;
        decimal: any;
        unit: any;
        pack: any;
        color: string;
        emphasis?: 'normal' | 'high';
    }) => {
        const { blockH, blockCY, currency, integer, decimal, unit, pack, color, emphasis } = tier;
        if (!blockH || !Number.isFinite(blockH)) return;

        const maxPriceW = totalW - (padX * 2);
        const currencyGap = clamp(blockH * 0.045, 2, 9);
        const integerDecimalGap = PRICE_INTEGER_DECIMAL_GAP_PX;

        const isHigh = emphasis === 'high';
        const integerScale = isHigh ? 0.72 : 0.60;
        const decimalScale = isHigh ? 0.38 : 0.31;
        const currencyScale = isHigh ? 0.26 : 0.21;
        const unitScale = isHigh ? 0.27 : 0.22;
        const packScale = isHigh ? 0.17 : 0.155;

        setTextSizing(integer, integerScale, blockH, color);
        setTextSizing(decimal, decimalScale, blockH, color);
        setTextSizing(currency, currencyScale, blockH, color);
        setTextSizing(unit, unitScale, blockH, color);
        setTextSizing(pack, packScale, blockH, color);

        const packVisible = isShown(pack) && String(pack?.text || '').trim().length > 0;
        const unitVisible = isShown(unit) && String(unit?.text || '').trim().length > 0;
        let centsBlockW = unitVisible ? Math.max(getW(decimal), getW(unit)) : getW(decimal);
        let priceW = getW(currency) + currencyGap + getW(integer) + integerDecimalGap + centsBlockW;
        if (priceW > maxPriceW && priceW > 0) {
            const s = Math.max(isHigh ? 0.65 : 0.58, maxPriceW / priceW);
            [currency, integer, decimal, unit].forEach((t: any) => t?.set?.({ scaleX: s, scaleY: s }));
            centsBlockW = unitVisible ? Math.max(getW(decimal), getW(unit)) : getW(decimal);
            priceW = getW(currency) + currencyGap + getW(integer) + integerDecimalGap + centsBlockW;
        }

        const blockTop = blockCY - (blockH / 2);
        const blockBottom = blockCY + (blockH / 2);
        const innerTop = blockTop + (blockH * 0.10);
        const innerBottom = blockBottom - (blockH * 0.10);

        const maxPackW = totalW - (padX * 2);
        let chainBottomLimit = innerBottom;
        if (pack && packVisible) {
            // Keep pack/observacao near the footer of each tier.
            const pw = getW(pack);
            if (pw > maxPackW && pw > 0) {
                const s = maxPackW / pw;
                pack.set({ scaleX: s, scaleY: s });
            } else {
                pack.set({ scaleX: 1, scaleY: 1 });
            }
            fitTextWidth(pack, maxPackW, isHigh ? 0.6 : 0.55);
            const packH = Math.max(8, getH(pack));
            const packCenterY = Math.min(innerBottom - (packH / 2), blockBottom - (packH / 2) - 2);
            pack.set({ originX: 'center', originY: 'center', left: 0, top: packCenterY });
            chainBottomLimit = Math.max(innerTop + 6, packCenterY - (packH / 2) - (blockH * 0.08));
        }

        const chainCenterY = (innerTop + chainBottomLimit) / 2;
        const startX = -priceW / 2;
        const intY = chainCenterY + (isHigh ? (blockH * 0.02) : (blockH * 0.01));
        const decY = intY - (blockH * (isHigh ? 0.18 : 0.16));
        const curY = intY + (blockH * (isHigh ? 0.02 : 0.01));

        const curW = getW(currency);
        currency?.set?.({ originX: 'left', originY: 'center', left: startX, top: curY });

        const intX = startX + curW + currencyGap;
        layoutPrice({
            priceInteger: integer,
            priceDecimal: decimal,
            priceUnit: unitVisible ? unit : undefined,
            intX,
            intY,
            decY,
            unitY: intY + (blockH * (isHigh ? 0.26 : 0.22)),
            maxWidth: Math.max(20, maxPriceW - (curW + currencyGap)),
            gapPx: integerDecimalGap,
            minGapPx: integerDecimalGap,
            maxGapPx: integerDecimalGap
        });

        // Keep the whole chain (currency + integer + decimal + unit) centered as a block.
        const chainBounds = measureHorizontalBoundsLocal(
            [currency, integer, decimal, unitVisible ? unit : null].filter(Boolean) as any[]
        );
        if (chainBounds) {
            const chainCenterX = (chainBounds.left + chainBounds.right) / 2;
            const dx = -chainCenterX;
            if (Math.abs(dx) > 0.001) {
                [currency, integer, decimal, unitVisible ? unit : null].forEach((obj: any) => {
                    if (!obj || typeof obj.set !== 'function') return;
                    obj.set({ left: Number(obj.left || 0) + dx });
                });
            }
        }

        // Hard clamp: price chain must stay inside its own block (never invade banner/other tiers).
        const chainObjects = [currency, integer, decimal, unitVisible ? unit : null].filter(Boolean);
        const yBounds = chainObjects
            .map((obj: any) => getVerticalBounds(obj))
            .filter(Boolean) as Array<{ min: number; max: number }>;
        if (yBounds.length > 0) {
            const minY = Math.min(...yBounds.map((b) => b.min));
            const maxY = Math.max(...yBounds.map((b) => b.max));
            const topLimit = innerTop;
            const bottomLimit = chainBottomLimit;
            let dy = 0;
            if (minY < topLimit) dy += (topLimit - minY);
            if ((maxY + dy) > bottomLimit) dy += (bottomLimit - (maxY + dy));
            if (Math.abs(dy) > 0.001) {
                chainObjects.forEach((obj: any) => {
                    obj?.set?.({ top: Number(obj.top || 0) + dy });
                });
            }
        }
    };

    if (showRetail) layoutTier({ blockH: retailH, blockCY: centers.retail, currency: retailCurrency, integer: retailInteger, decimal: retailDecimal, unit: retailUnit, pack: retailPack, color: '#FFFFFF', emphasis: 'normal' });
    if (showWholesale) layoutTier({ blockH: wholesaleH, blockCY: centers.wholesale, currency: wholesaleCurrency, integer: wholesaleInteger, decimal: wholesaleDecimal, unit: wholesaleUnit, pack: wholesalePack, color: '#000000', emphasis: 'high' });

    if (showBanner && bannerText) {
        setTextSizing(bannerText, 0.58, bannerH, '#000000');
        fitTextWidth(bannerText, totalW - (padX * 0.9), 0.56);
        const bannerTop = centers.banner - (bannerH / 2);
        const bannerBottom = centers.banner + (bannerH / 2);
        bannerText.set({ originX: 'center', originY: 'center', left: 0, top: centers.banner });
        const bannerBounds = getVerticalBounds(bannerText);
        if (bannerBounds) {
            let dy = 0;
            if (bannerBounds.min < (bannerTop + 2)) dy += ((bannerTop + 2) - bannerBounds.min);
            if ((bannerBounds.max + dy) > (bannerBottom - 2)) dy += ((bannerBottom - 2) - (bannerBounds.max + dy));
            if (Math.abs(dy) > 0.001) {
                bannerText.set({ top: Number(bannerText.top || 0) + dy });
            }
        }
    }

    // Freeze to canonical size (style stays identical even with value variations).
    priceGroup.set({ width: totalW, height: totalH });
    const _apgParts = priceGroup.getObjects?.() || [];
    _apgParts.forEach((o: any) => { if (o && typeof o.setCoords === 'function') o.setCoords(); });
    priceGroup.dirty = true;
    if (typeof priceGroup.setCoords === 'function') priceGroup.setCoords();
    return { pillW: totalW, pillH: totalH };
};

function isRedBurstPriceGroup(priceGroup: any): boolean {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return false;
    const all = collectObjectsDeep(priceGroup);
    return !!(
        findByName(all, 'price_bg') &&
        findByName(all, 'price_header_bg') &&
        findByName(all, 'price_header_text') &&
        findByName(all, 'price_burst_line_a') &&
        findByName(all, 'price_integer_text') &&
        findByName(all, 'price_decimal_text')
    );
}

function shouldPreserveManualTemplateVisual(priceGroup: any): boolean {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return false;
    if ((priceGroup as any).__preserveManualLayout === true || (priceGroup as any).__isCustomTemplate === true) return true;
    if ((priceGroup as any).__forceAtacarejoCanonical === true) return false;

    if (isRedBurstPriceGroup(priceGroup)) return true;

    const all = collectObjectsDeep(priceGroup);
    if (!all.length) return false;

    const hasAtacStructure = !!findByName(all, 'atac_retail_bg');
    if (hasAtacStructure) return false;

    if (findByName(all, 'price_header_bg') || findByName(all, 'price_header_text')) return true;

    const hasTemplateMetrics = all.some((obj: any) => (
        Number.isFinite(Number((obj as any)?.__originalLeft)) ||
        Number.isFinite(Number((obj as any)?.__originalTop)) ||
        Number.isFinite(Number((obj as any)?.__originalFontSize)) ||
        Number.isFinite(Number((obj as any)?.__originalWidth)) ||
        Number.isFinite(Number((obj as any)?.__originalHeight))
    ));
    return hasTemplateMetrics;
}

const restoreMissingManualTemplateFlags = (priceGroup: any): boolean => {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return false;
    if (!shouldPreserveManualTemplateVisual(priceGroup)) return false;

    let changed = false;
    if ((priceGroup as any).__preserveManualLayout !== true) {
        (priceGroup as any).__preserveManualLayout = true;
        changed = true;
    }
    if ((priceGroup as any).__isCustomTemplate !== true) {
        (priceGroup as any).__isCustomTemplate = true;
        changed = true;
    }

    const hasBaseW = Number.isFinite(Number((priceGroup as any).__manualTemplateBaseW));
    const hasBaseH = Number.isFinite(Number((priceGroup as any).__manualTemplateBaseH));
    if (!hasBaseW || !hasBaseH) {
        const rawW = Number(priceGroup.width || 0);
        const rawH = Number(priceGroup.height || 0);
        const sx = Math.abs(Number(priceGroup.scaleX ?? 1)) || 1;
        const sy = Math.abs(Number(priceGroup.scaleY ?? 1)) || 1;
        const scaledW = Number(priceGroup.getScaledWidth?.() || 0);
        const scaledH = Number(priceGroup.getScaledHeight?.() || 0);
        const baseW = rawW > 0 ? rawW : (scaledW > 0 ? (scaledW / sx) : 0);
        const baseH = rawH > 0 ? rawH : (scaledH > 0 ? (scaledH / sy) : 0);
        if (!hasBaseW && Number.isFinite(baseW) && baseW > 0) {
            (priceGroup as any).__manualTemplateBaseW = baseW;
            changed = true;
        }
        if (!hasBaseH && Number.isFinite(baseH) && baseH > 0) {
            (priceGroup as any).__manualTemplateBaseH = baseH;
            changed = true;
        }
    }

    return changed;
};

const restoreMissingManualTemplateFlagsInCanvas = (canvasInstance: any, reason: string = 'unknown') => {
    if (!canvasInstance || typeof canvasInstance.getObjects !== 'function') return 0;

    const roots = canvasInstance.getObjects() || [];
    const stack = [...roots];
    let restored = 0;
    while (stack.length) {
        const obj = stack.pop();
        if (!obj) continue;
        if (isLikelyPriceGroupObject(obj) && restoreMissingManualTemplateFlags(obj)) {
            restored += 1;
        }
        if (typeof obj.getObjects === 'function') {
            (obj.getObjects() || []).forEach((child: any) => stack.push(child));
        }
    }

    if (restored > 0) {
        console.log(`[price-template] Restauradas flags de template manual em ${restored} etiqueta(s) (${reason})`);
    }
    return restored;
};

function tuneRedBurstPriceGroupLayout(priceGroup: any) {
    if (!isRedBurstPriceGroup(priceGroup)) return false;
    // Mini Editor templates must keep authored header geometry (width/position/font size).
    // Red burst tuning should only auto-fit header text for non-manual/legacy groups.
    const preserveManualHeaderGeometry =
        shouldPreserveManualTemplateVisual(priceGroup) &&
        (priceGroup as any)?.__allowRedBurstHeaderAutofit !== true;
    const all = collectObjectsDeep(priceGroup);
    const priceBg = findByName(all, 'price_bg');
    const headerBg = findByName(all, 'price_header_bg');
    const headerText = findByName(all, 'price_header_text');
    const headerUnitText = findByName(all, 'price_header_unit_text');
    const currencyText = findByName(all, 'price_currency_text');
    const priceInteger = findByName(all, 'price_integer_text');
    const priceDecimal = findByName(all, 'price_decimal_text');
    if (!priceBg || !headerBg || !headerText || !currencyText || !priceInteger || !priceDecimal) return false;

    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const bgW = Math.max(1, Number(priceBg.width || 0));
    const bgH = Math.max(1, Number(priceBg.height || 0));
    const headerW = Math.max(1, Number(headerBg.width || (bgW * 0.92)));
    const headerH = Math.max(1, Number(headerBg.height || (bgH * 0.27)));
    const headerY = Number(headerBg.top || (-(bgH / 2) + headerH * 0.72));
    const ensureTextDims = (obj: any) => {
        if (!isTextLikeObject(obj)) return;
        if (typeof obj.initDimensions === 'function') obj.initDimensions();
    };

    if (headerUnitText && isTextLikeObject(headerUnitText)) {
        headerUnitText.set({ text: '', visible: false });
        ensureTextDims(headerUnitText);
    }

    if (isTextLikeObject(headerText)) {
        const originalHeaderFont = Number((headerText as any).__originalFontSize || headerText.fontSize || Math.max(16, headerH * 0.56));
        if (!preserveManualHeaderGeometry) {
            headerText.set({
                originX: 'center',
                originY: 'center',
                left: 0,
                top: headerY + (headerH * 0.01),
                width: headerW * 0.9,
                fontSize: originalHeaderFont,
                scaleX: 1,
                scaleY: 1
            });
            ensureTextDims(headerText);
            const headerMaxW = headerW * 0.9;
            const measuredHeaderW = Number(headerText.getScaledWidth?.() || 0);
            if (measuredHeaderW > headerMaxW && measuredHeaderW > 0) {
                const ratio = clamp(headerMaxW / measuredHeaderW, 0.55, 1);
                headerText.set({ fontSize: Math.max(12, originalHeaderFont * ratio) });
                ensureTextDims(headerText);
            }
        } else {
            // Keep exactly what was authored in Mini Editor (only refresh text metrics).
            ensureTextDims(headerText);
        }
    }

    if (!isTextLikeObject(currencyText) || !isTextLikeObject(priceInteger) || !isTextLikeObject(priceDecimal)) {
        return false;
    }

    const originalCurrencyFont = Number((currencyText as any).__originalFontSize || currencyText.fontSize || Math.max(20, bgH * 0.2));
    const originalIntegerFont = Number((priceInteger as any).__originalFontSize || priceInteger.fontSize || Math.max(56, bgH * 0.78));
    const originalDecimalFont = Number((priceDecimal as any).__originalFontSize || priceDecimal.fontSize || Math.max(28, bgH * 0.44));

    const priceBaselineY = bgH * 0.2;
    const innerLeftPad = bgW * 0.08;
    const innerRightPad = bgW * 0.06;
    const textGap = Math.max(2, bgW * 0.008);
    const currencyGap = Math.max(4, bgW * 0.02);

    currencyText.set({
        originX: 'center',
        originY: 'center',
        fontSize: originalCurrencyFont,
        scaleX: 1,
        scaleY: 1,
        top: priceBaselineY + (bgH * 0.01)
    });
    priceInteger.set({
        originX: 'left',
        originY: 'center',
        fontSize: originalIntegerFont,
        scaleX: 1,
        scaleY: 1,
        top: priceBaselineY + (bgH * 0.01)
    });
    priceDecimal.set({
        originX: 'left',
        originY: 'center',
        fontSize: originalDecimalFont,
        scaleX: 1,
        scaleY: 1,
        top: priceBaselineY - (bgH * 0.145)
    });

    ensureTextDims(currencyText);
    ensureTextDims(priceInteger);
    ensureTextDims(priceDecimal);

    const currencyX = -(bgW / 2) + innerLeftPad + (Number(currencyText.getScaledWidth?.() || 0) / 2);
    currencyText.set({ left: currencyX });
    ensureTextDims(currencyText);

    const layoutPriceTexts = () => {
        const currencyW = Number(currencyText.getScaledWidth?.() || 0);
        const intW = Number(priceInteger.getScaledWidth?.() || 0);
        const decW = Number(priceDecimal.getScaledWidth?.() || 0);
        const textStartX = currencyX + (currencyW / 2) + currencyGap;
        const maxRight = (bgW / 2) - innerRightPad;
        const availableW = Math.max(1, maxRight - textStartX);
        const totalW = intW + textGap + decW;
        return { textStartX, totalW, availableW };
    };

    let integerFont = originalIntegerFont;
    let decimalFont = originalDecimalFont;
    for (let i = 0; i < 4; i++) {
        const layout = layoutPriceTexts();
        if (layout.totalW <= layout.availableW) break;
        const ratio = clamp(layout.availableW / layout.totalW, 0.7, 1);
        integerFont = Math.max(36, integerFont * ratio);
        decimalFont = Math.max(20, decimalFont * ratio);
        priceInteger.set({ fontSize: integerFont, scaleX: 1, scaleY: 1 });
        priceDecimal.set({ fontSize: decimalFont, scaleX: 1, scaleY: 1 });
        ensureTextDims(priceInteger);
        ensureTextDims(priceDecimal);
    }

    const finalLayout = layoutPriceTexts();
    priceInteger.set({ left: finalLayout.textStartX });
    ensureTextDims(priceInteger);
    const intWFinal = Number(priceInteger.getScaledWidth?.() || 0);
    priceDecimal.set({ left: finalLayout.textStartX + intWFinal + textGap });
    ensureTextDims(priceDecimal);
    return true;
}

/**
 * Preserve manual layout edits from mini editor:
 * scales the entire template proportionally without reflowing text blocks.
 */
const layoutManualTemplateGroup = (priceGroup: any, cardW: number, cardH: number) => {
    if (!priceGroup) return null;

    const all = collectObjectsDeep(priceGroup);
    if (isRedBurstPriceGroup(priceGroup)) {
        tuneRedBurstPriceGroupLayout(priceGroup);
    }
    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const toFinite = (v: any, fb: number) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : fb;
    };

    // Keep the exact Mini Editor geometry. We only apply a UNIFORM scale to fit card bounds.
    // Never recalculate child text/object positions here.
    let baseW = Number((priceGroup as any).__manualTemplateBaseW);
    let baseH = Number((priceGroup as any).__manualTemplateBaseH);
    const sx = Math.abs(toFinite(priceGroup.scaleX, 1)) || 1;
    const sy = Math.abs(toFinite(priceGroup.scaleY, 1)) || 1;
    const rawW = toFinite(priceGroup.width, 0);
    const rawH = toFinite(priceGroup.height, 0);
    const scaledW = toFinite(priceGroup.getScaledWidth?.(), rawW * sx);
    const scaledH = toFinite(priceGroup.getScaledHeight?.(), rawH * sy);
    const inferredBaseW = rawW > 0 ? rawW : (scaledW > 0 ? scaledW / sx : 1);
    const inferredBaseH = rawH > 0 ? rawH : (scaledH > 0 ? scaledH / sy : 1);
    const shouldRefreshBase =
        !Number.isFinite(baseW) || baseW <= 0 ||
        !Number.isFinite(baseH) || baseH <= 0 ||
        inferredBaseW > (baseW * 1.001) ||
        inferredBaseH > (baseH * 1.001);
    if (shouldRefreshBase) {
        baseW = inferredBaseW;
        baseH = inferredBaseH;
        baseW = Math.max(1, baseW);
        baseH = Math.max(1, baseH);
        (priceGroup as any).__manualTemplateBaseW = baseW;
        (priceGroup as any).__manualTemplateBaseH = baseH;
    }

    const getSize = (obj: any, axis: 'x' | 'y') => {
        if (!obj) return 0;
        const fallback = axis === 'x'
            ? (Number(obj.width || 0) * Math.abs(Number(obj.scaleX ?? 1) || 1))
            : (Number(obj.height || 0) * Math.abs(Number(obj.scaleY ?? 1) || 1));
        const measured = axis === 'x'
            ? Number(obj.getScaledWidth?.() || 0)
            : Number(obj.getScaledHeight?.() || 0);
        const size = Number.isFinite(measured) && measured > 0 ? measured : fallback;
        return Number.isFinite(size) && size > 0 ? size : 0;
    };
    const edgeX = (obj: any) => {
        if (!obj) return null;
        const w = getSize(obj, 'x');
        if (!w) return null;
        const x = Number(obj.left || 0);
        const ox = String(obj.originX || 'left');
        if (ox === 'center') return { min: x - (w / 2), max: x + (w / 2) };
        if (ox === 'right') return { min: x - w, max: x };
        return { min: x, max: x + w };
    };
    const edgeY = (obj: any) => {
        if (!obj) return null;
        const h = getSize(obj, 'y');
        if (!h) return null;
        const y = Number(obj.top || 0);
        const oy = String(obj.originY || 'top');
        if (oy === 'center') return { min: y - (h / 2), max: y + (h / 2) };
        if (oy === 'bottom') return { min: y - h, max: y };
        return { min: y, max: y + h };
    };
    const isShown = (obj: any) => !!(obj && obj.visible !== false && Number(obj.scaleX ?? 1) !== 0 && Number(obj.scaleY ?? 1) !== 0);
    const visibleBounds = (objects: any[]) => {
        const xs: Array<{ min: number; max: number }> = [];
        const ys: Array<{ min: number; max: number }> = [];
        (objects || []).forEach((obj: any) => {
            if (!isShown(obj)) return;
            if (isTextLikeObject(obj) && typeof obj.initDimensions === 'function') obj.initDimensions();
            const ex = edgeX(obj);
            const ey = edgeY(obj);
            if (ex) xs.push(ex);
            if (ey) ys.push(ey);
        });
        if (!xs.length || !ys.length) return null;
        const minX = Math.min(...xs.map((e) => e.min));
        const maxX = Math.max(...xs.map((e) => e.max));
        const minY = Math.min(...ys.map((e) => e.min));
        const maxY = Math.max(...ys.map((e) => e.max));
        return {
            minX,
            maxX,
            minY,
            maxY,
            width: Math.max(1, maxX - minX),
            height: Math.max(1, maxY - minY),
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    };

    // Reserve enough space for Atacarejo manual templates so the visual hierarchy is preserved,
    // but collapse unused vertical tiers when only one price is present.
    const hasAtacarejoStructure = !!findByName(all, 'atac_retail_bg');
    const directChildren = typeof priceGroup.getObjects === 'function' ? (priceGroup.getObjects() || []) : [];
    const findNamedTarget = (name: string) => {
        const direct = directChildren.find((obj: any) => String(obj?.name || '') === name);
        return direct || findByName(all, name);
    };
    const atacAnchors = [
        findNamedTarget('atac_retail_bg'),
        findNamedTarget('atac_banner_bg'),
        findNamedTarget('atac_wholesale_bg')
    ].filter((obj: any) => isShown(obj));
    const singleAnchors = [
        findNamedTarget('price_bg'),
        findNamedTarget('price_bg_image'),
        findNamedTarget('splash_image')
    ].filter((obj: any) => isShown(obj));
    const fitTargets = atacAnchors.length > 0
        ? atacAnchors
        : (singleAnchors.length > 0 ? singleAnchors : directChildren);
    const directChildrenVisibleBounds = visibleBounds(directChildren);
    const hasSaneBounds = (bounds: any, referenceBounds?: any) => {
        if (!bounds) return false;
        if (!Number.isFinite(bounds.width) || !Number.isFinite(bounds.height)) return false;
        if (bounds.width <= 0 || bounds.height <= 0) return false;
        if (bounds.width < 14 || bounds.height < 10) return false;
        if (bounds.width > 10000 || bounds.height > 10000) return false;
        if (referenceBounds && Number.isFinite(referenceBounds.width) && referenceBounds.width > 0) {
            if (bounds.width < (referenceBounds.width * 0.45)) return false;
        }
        if (referenceBounds && Number.isFinite(referenceBounds.height) && referenceBounds.height > 0) {
            if (bounds.height < (referenceBounds.height * 0.45)) return false;
        }
        return true;
    };
    const shouldUseVisibleBoundsFallback = (bounds: any, referenceBounds?: any) => {
        if (!hasSaneBounds(bounds, referenceBounds)) return false;
        if (!Number.isFinite(baseW) || !Number.isFinite(baseH) || baseW <= 0 || baseH <= 0) return true;
        const ratioW = baseW / Math.max(1, bounds.width);
        const ratioH = baseH / Math.max(1, bounds.height);
        // Legacy/corrupted templates may persist oversized base dimensions, shrinking the card label.
        return ratioW > 1.35 || ratioW < 0.62 || ratioH > 1.35 || ratioH < 0.62;
    };

    let effectiveW = baseW;
    let effectiveH = baseH;
    if (hasAtacarejoStructure) {
        let bounds = visibleBounds(directChildren);
        if (bounds && (Math.abs(bounds.centerX) > 0.001 || Math.abs(bounds.centerY) > 0.001)) {
            directChildren.forEach((obj: any) => {
                if (!obj || typeof obj.set !== 'function') return;
                obj.set({
                    left: Number(obj.left || 0) - bounds!.centerX,
                    top: Number(obj.top || 0) - bounds!.centerY
                });
                obj.setCoords?.();
            });
            bounds = visibleBounds(directChildren);
        }
        if (bounds && hasSaneBounds(bounds, directChildrenVisibleBounds)) {
            effectiveW = Math.max(1, bounds.width);
            effectiveH = Math.max(1, bounds.height);
        }
    } else {
        let bounds = visibleBounds(fitTargets);
        if (!bounds && fitTargets !== directChildren) bounds = directChildrenVisibleBounds;
        if (!hasSaneBounds(bounds, directChildrenVisibleBounds) && hasSaneBounds(directChildrenVisibleBounds, directChildrenVisibleBounds)) {
            bounds = directChildrenVisibleBounds;
        }
        if (bounds && shouldUseVisibleBoundsFallback(bounds, directChildrenVisibleBounds)) {
            effectiveW = Math.max(1, Number(bounds.width || baseW || 1));
            effectiveH = Math.max(1, Number(bounds.height || baseH || 1));
            // Self-heal the template metadata so future card renders stay consistent.
            (priceGroup as any).__manualTemplateBaseW = effectiveW;
            (priceGroup as any).__manualTemplateBaseH = effectiveH;
        }
    }

    const wholesaleBg = findByName(all, 'atac_wholesale_bg');
    const bannerBg = findByName(all, 'atac_banner_bg');
    const bannerText = findByName(all, 'wholesale_banner_text');
    const atacHeightRatio = hasAtacarejoStructure
        ? (isShown(wholesaleBg) ? 0.62 : ((isShown(bannerBg) && isShown(bannerText)) ? 0.5 : 0.44))
        : 0.44;
    const maxW = Math.max(120, cardW * 0.98);
    const maxH = Math.max(42, cardH * atacHeightRatio);
    const fitScale = clamp(Math.min(maxW / Math.max(1, effectiveW), maxH / Math.max(1, effectiveH)), 0.2, 4);

    priceGroup.set({
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        angle: 0,
        width: Math.max(1, effectiveW),
        height: Math.max(1, effectiveH),
        scaleX: fitScale,
        scaleY: fitScale
    });

    priceGroup.dirty = true;
    priceGroup.setCoords?.();
    return { pillW: Math.max(1, effectiveW) * fitScale, pillH: Math.max(1, effectiveH) * fitScale };
};


/**
 * Layout function for custom user-created templates.
 * Preserves the original proportions and scales everything proportionally.
 */
function layoutCustomPriceGroup(priceGroup: any, cardW: number, cardH: number) {
    if (!priceGroup || typeof priceGroup.getObjects !== 'function') return null;

    const all = priceGroup.getObjects();
    const priceBg = all.find((o: any) => o.name === 'price_bg');
    const priceBgImage = all.find((o: any) => o.name === 'price_bg_image' || o.name === 'splash_image');

    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));

    // Get original template dimensions from priceBg metadata
    const originalW = typeof (priceBg as any)?.__originalWidth === 'number'
        ? (priceBg as any).__originalWidth
        : (priceBg?.width || 200);
    const originalH = typeof (priceBg as any)?.__originalHeight === 'number'
        ? (priceBg as any).__originalHeight
        : (priceBg?.height || 46);

    // Calculate target size based on card dimensions
    const maxPillW = cardW * 0.96;
    const maxPillH = cardH * 0.28;
    const minPillH = Math.max(36, cardH * 0.12);

    // Calculate scale factors to fit within bounds
    const scaleByWidth = maxPillW / originalW;
    const scaleByHeight = maxPillH / originalH;
    let scale = Math.min(scaleByWidth, scaleByHeight);

    // Ensure minimum height
    const scaledH = originalH * scale;
    if (scaledH < minPillH) {
        scale = minPillH / originalH;
    }

    // Clamp scale to reasonable limits
    scale = clamp(scale, 0.3, 3);

    // Apply scale to priceBg
    const newW = originalW * scale;
    const newH = originalH * scale;

    // Get roundness from metadata or default to 1 (fully rounded)
    const roundness = clamp(
        typeof (priceBg as any)?.__roundness === 'number' ? (priceBg as any).__roundness : 1,
        0,
        1
    );
    const radius = (newH / 2) * roundness;

    priceBg.set({
        width: newW,
        height: newH,
        rx: radius,
        ry: radius,
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0
    });

    // Scale stroke proportionally
    const originalStrokeW = typeof (priceBg as any)?.__strokeWidth === 'number'
        ? (priceBg as any).__strokeWidth
        : null;
    if (originalStrokeW !== null) {
        priceBg.set({ strokeWidth: originalStrokeW * scale });
    }

    // Scale shadow blur proportionally
    if (fabric?.Shadow && priceBg.shadow) {
        const originalBlur = typeof (priceBg as any)?.__shadowBlur === 'number'
            ? (priceBg as any).____shadowBlur
            : 15;
        const shadow = priceBg.shadow;
        shadow.blur = Math.max(2, originalBlur * scale);
    }

    // Handle background image
    if (priceBgImage && priceBgImage.type === 'image') {
        const img: any = priceBgImage;
        img.set({
            originX: 'center',
            originY: 'center',
            left: 0,
            top: 0
        });

        const el: any = img._originalElement || img._element;
        const iw = el?.naturalWidth || el?.width || img.width || 0;
        const ih = el?.naturalHeight || el?.height || img.height || 0;

        if (iw > 0 && ih > 0) {
            img.set({ cropX: 0, cropY: 0, width: iw, height: ih });
            const imgScale = Math.max(newW / iw, newH / ih);
            if (Number.isFinite(imgScale) && imgScale > 0) {
                const cropW = Math.min(iw, newW / imgScale);
                const cropH = Math.min(ih, newH / imgScale);
                const cropX = Math.max(0, (iw - cropW) / 2);
                const cropY = Math.max(0, (ih - cropH) / 2);
                img.set({ cropX, cropY, width: cropW, height: cropH, scaleX: imgScale, scaleY: imgScale });
            }
        }

        // Clip to pill shape
        if (fabric?.Rect) {
            const clip = new fabric.Rect({
                width: newW,
                height: newH,
                rx: radius,
                ry: radius,
                originX: 'center',
                originY: 'center',
                left: 0,
                top: 0
            });
            img.set({ clipPath: clip });
        }

        if (typeof priceBg.fill === 'string' && priceBg.fill !== 'transparent') {
            priceBg.set('fill', 'transparent');
        }
        if (typeof img.sendToBack === 'function') img.sendToBack();
    }

    // Identify price-related text elements for dynamic positioning
    const priceInteger = all.find((o: any) => o.name === 'price_integer_text' || o.name === 'priceInteger' || o.name === 'price_integer');
    const priceDecimal = all.find((o: any) => o.name === 'price_decimal_text' || o.name === 'priceDecimal' || o.name === 'price_decimal');
    const priceUnit = all.find((o: any) => o.name === 'price_unit_text' || o.name === 'priceUnit' || o.name === 'price_unit');
    const currencyText = all.find((o: any) => o.name === 'price_currency_text');
    const currencyCircle = all.find((o: any) => o.name === 'price_currency_bg' || o.name === 'priceSymbolBg');
    const priceText = all.find((o: any) => o.name === 'price_value_text' || o.name === 'smart_price');

    // Check if we have split price elements (integer + decimal)
    const hasSplitPrice = !!(priceInteger && priceDecimal);
    const hasPriceStructure = hasSplitPrice || priceText;

    // First pass: scale all text elements
    all.forEach((obj: any) => {
        if (!isTextLikeObject(obj)) return;

        // Get original font size from metadata or current value
        const originalFontSize = typeof obj.__originalFontSize === 'number'
            ? obj.__originalFontSize
            : (obj.fontSize || 14);

        // Get original fontFamily from metadata or current value
        const originalFontFamily = typeof obj.__originalFontFamily === 'string'
            ? obj.__originalFontFamily
            : obj.fontFamily;

        // Apply scaled font size and preserve fontFamily
        // Position will be set later for price elements
        obj.set({
            fontFamily: originalFontFamily || undefined,
            fontSize: originalFontSize * scale,
            scaleX: 1,
            scaleY: 1,
            strokeWidth: (obj.strokeWidth || 0) * scale
        });

        if (typeof obj.initDimensions === 'function') obj.initDimensions();
    });

    // Second pass: set non-price text positions proportionally
    all.forEach((obj: any) => {
        if (!isTextLikeObject(obj)) return;
        // Skip price elements - they will be positioned dynamically
        if (hasPriceStructure && (
            obj === priceInteger || obj === priceDecimal || obj === priceUnit ||
            obj === priceText || obj === currencyText
        )) {
            return;
        }

        const originalLeft = typeof obj.__originalLeft === 'number' ? obj.__originalLeft : obj.left;
        const originalTop = typeof obj.__originalTop === 'number' ? obj.__originalTop : obj.top;
        const originalOriginX = obj.__originalOriginX || obj.originX || 'center';
        const originalOriginY = obj.__originalOriginY || obj.originY || 'center';

        obj.set({
            left: (typeof originalLeft === 'number' ? originalLeft * scale : originalLeft),
            top: (typeof originalTop === 'number' ? originalTop * scale : originalTop),
            originX: originalOriginX,
            originY: originalOriginY
        });
    });

    // Dynamic positioning for price elements (same logic as layoutPriceGroup)
    if (hasPriceStructure) {
        const getW = (t: any) => (t && typeof t.getScaledWidth === 'function' ? t.getScaledWidth() : 0);

        // Calculate starting X position for price text
        let textStartX = -(newW / 2) + (newH * 0.35 * 0.85); // Similar to circleCenterX + circleSize/2

        // If we have a currency circle, adjust textStartX
        if (currencyCircle) {
            const circleSize = newH * 0.72;
            const circleCenterX = -(newW / 2) + (circleSize * 0.35);
            textStartX = circleCenterX + (circleSize / 2) + (newH * 0.18);
        } else if (currencyText) {
            // Use currency text width to determine start position
            const currencyW = getW(currencyText);
            textStartX = -(newW / 2) + currencyW + (newH * 0.1);
        }

        if (hasSplitPrice) {
            // Position integer and decimal dynamically
        const intY = (typeof priceInteger.__yOffsetRatio === 'number' ? priceInteger.__yOffsetRatio : 0) * newH;
        const decY = (typeof priceDecimal.__yOffsetRatio === 'number' ? priceDecimal.__yOffsetRatio : -0.18) * newH;
            const unitY = (typeof priceUnit?.__yOffsetRatio === 'number' ? priceUnit.__yOffsetRatio : 0.22) * newH;
            const rightPad = newH * 0.35;
            const maxTextW = Math.max(20, (newW / 2) - rightPad - textStartX);
            layoutPrice({
                priceInteger,
                priceDecimal,
                priceUnit,
                intX: textStartX,
                intY,
                decY,
                unitY,
                maxWidth: maxTextW,
                gapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
                minGapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
                maxGapPx: PRICE_INTEGER_DECIMAL_GAP_PX
            });
        } else if (priceText) {
            // Single price text
            const priceY = (typeof priceText.__yOffsetRatio === 'number' ? priceText.__yOffsetRatio : 0) * newH;
            priceText.set({ originX: 'left', originY: 'center', left: textStartX, top: priceY });
        }
    }

    // Scale all other objects (circles, rects, etc.)
    all.forEach((obj: any) => {
        if (!obj || isTextLikeObject(obj)) return;
        if (obj.name === 'price_bg' || obj.name === 'price_bg_image' || obj.name === 'splash_image') return;

        // Get original dimensions
        const originalLeft = typeof obj.__originalLeft === 'number' ? obj.__originalLeft : obj.left;
        const originalTop = typeof obj.__originalTop === 'number' ? obj.__originalTop : obj.top;
        const originalScaleX = typeof obj.__originalScaleX === 'number' ? obj.__originalScaleX : 1;
        const originalScaleY = typeof obj.__originalScaleY === 'number' ? obj.__originalScaleY : 1;

        obj.set({
            left: (typeof originalLeft === 'number' ? originalLeft * scale : originalLeft),
            top: (typeof originalTop === 'number' ? originalTop * scale : originalTop),
            scaleX: originalScaleX * scale,
            scaleY: originalScaleY * scale
        });

        // For circles, also scale radius
        if (obj.type === 'circle' && typeof obj.__originalRadius === 'number') {
            obj.set({ radius: obj.__originalRadius * scale });
        }
        // For rects, also scale width/height if they have original values stored
        if (obj.type === 'rect') {
            if (typeof obj.__originalWidth === 'number') {
                obj.set({ width: obj.__originalWidth * scale });
            }
            if (typeof obj.__originalHeight === 'number') {
                obj.set({ height: obj.__originalHeight * scale });
            }
            if (typeof obj.__originalRx === 'number') {
                obj.set({ rx: obj.__originalRx * scale });
            }
            if (typeof obj.__originalRy === 'number') {
                obj.set({ ry: obj.__originalRy * scale });
            }
        }
    });

    // CRITICAL: Freeze priceGroup to intended pill dimensions (no auto-expand).
    priceGroup.set({ width: newW, height: newH });
    const _cpgParts = priceGroup.getObjects?.() || [];
    _cpgParts.forEach((o: any) => { if (o && typeof o.setCoords === 'function') o.setCoords(); });
    priceGroup.dirty = true;
    if (typeof priceGroup.setCoords === 'function') priceGroup.setCoords();
    return { pillW: newW, pillH: newH };
}

const priceGroupAtacarejoProbeCache = new WeakMap<any, { childCount: number; hasAtacarejo: boolean }>();

const PRICE_LAYOUT_NODE_PREFIXES = ['price_', 'retail_', 'wholesale_', 'atac_'];
const PRICE_LAYOUT_NODE_EXACT = new Set([
    'priceGroup',
    'priceSymbol',
    'price_currency',
    'priceInteger',
    'priceDecimal',
    'priceUnit',
    'smart_price',
    'price_value_text'
]);

const isPriceLayoutNode = (obj: any) => {
    if (!obj || typeof obj !== 'object') return false;
    const name = String(obj?.name || '').trim();
    if (!name) return false;
    if (PRICE_LAYOUT_NODE_EXACT.has(name)) return true;
    return PRICE_LAYOUT_NODE_PREFIXES.some((prefix) => name.startsWith(prefix));
};

const isCardContainerLikeGroup = (group: any) => {
    if (!group || String(group?.type || '').toLowerCase() !== 'group') return false;
    if (group?.isSmartObject || group?.isProductCard) return true;
    if (String(group?.name || '').startsWith('product-card')) return true;
    if (String((group as any)?.parentZoneId || '').trim()) return true;
    if (String((group as any)?.smartGridId || '').trim()) return true;
    if (typeof group.getObjects !== 'function') return false;
    const children = group.getObjects() || [];
    if (!children.length) return false;
    return children.some((child: any) => {
        const n = String(child?.name || '');
        return n === 'offerBackground' || n === 'smart_title' || n === 'smart_limit' || n === 'smart_image' || n === 'product_image' || n === 'productImage';
    });
};

const isMisnamedProductCardGroup = (group: any) => {
    if (!group || String(group?.type || '').toLowerCase() !== 'group') return false;
    if (String(group?.name || '') !== 'priceGroup') return false;
    return isCardContainerLikeGroup(group);
};

const isLikelyPriceGroupObject = (group: any) => {
    if (!group || String(group?.type || '').toLowerCase() !== 'group') return false;
    if (isMisnamedProductCardGroup(group)) return false;
    if (String(group?.name || '') === 'priceGroup') return true;
    if (isCardContainerLikeGroup(group)) return false;
    if (shouldPreserveManualTemplateVisual(group)) return true;
    if (typeof group.getObjects !== 'function') return false;
    return (group.getObjects() || []).some((child: any) => isPriceLayoutNode(child));
};

const makePriceLayoutKeyBuilder = () => {
    const counters = new Map<string, number>();
    return (obj: any) => {
        const base = String(obj?.name || obj?.type || 'node');
        const idx = counters.get(base) ?? 0;
        counters.set(base, idx + 1);
        return `${base}#${idx}`;
    };
};

const isFiniteLayoutNumber = (value: any) => {
    const n = Number(value);
    return Number.isFinite(n);
};

const getCardHostForPriceGroup = (group: any): any | null => {
    let cur: any = group?.group || null;
    while (cur) {
        const name = String(cur?.name || '');
        const isCardLike =
            (String(cur?.type || '').toLowerCase() === 'group') &&
            (
                !!cur?.isSmartObject ||
                !!cur?.isProductCard ||
                name.startsWith('product-card') ||
                (typeof cur.getObjects === 'function' && (cur.getObjects() || []).some((o: any) => String(o?.name || '') === 'offerBackground'))
            );
        if (isCardLike) return cur;
        cur = cur.group || null;
    }
    return null;
};

const getCardSizeForPriceGroup = (group: any) => {
    const host = getCardHostForPriceGroup(group);
    if (!host) return null;
    const width = Math.abs(Number(host?._cardWidth ?? host?.width ?? host?.getScaledWidth?.() ?? 0) || 0);
    const height = Math.abs(Number(host?._cardHeight ?? host?.height ?? host?.getScaledHeight?.() ?? 0) || 0);
    if (!Number.isFinite(width) || !Number.isFinite(height) || width < 20 || height < 20) return null;
    return { width, height };
};

const hasCorruptedPriceLayout = (group: any) => {
    if (!group || typeof group.getObjects !== 'function') return false;
    if (!isFiniteLayoutNumber(group?.scaleX) || !isFiniteLayoutNumber(group?.scaleY)) return true;
    if (Math.abs(Number(group?.scaleX || 0)) < 0.0001 || Math.abs(Number(group?.scaleY || 0)) < 0.0001) return true;

    const nodes = collectObjectsDeep(group).filter((o: any) => isPriceLayoutNode(o));
    if (!nodes.length) return false;

    for (const node of nodes) {
        if (!isFiniteLayoutNumber(node?.left) || !isFiniteLayoutNumber(node?.top)) return true;
        if (!isFiniteLayoutNumber(node?.scaleX) || !isFiniteLayoutNumber(node?.scaleY)) return true;
        if (Math.abs(Number(node?.left || 0)) > 100000 || Math.abs(Number(node?.top || 0)) > 100000) return true;

        const hidden = node?.visible === false;
        if (!hidden) {
            if (Math.abs(Number(node?.scaleX || 0)) < 0.0001 || Math.abs(Number(node?.scaleY || 0)) < 0.0001) return true;
        }

        const tt = String(node?.type || '').toLowerCase();
        const isText = tt === 'text' || tt === 'i-text' || tt === 'itext' || tt === 'textbox';
        if (isText && !hidden) {
            if (!isFiniteLayoutNumber(node?.fontSize) || Number(node?.fontSize || 0) <= 0) return true;
        }
    }

    return false;
};

const rememberPriceLayoutSnapshot = (group: any) => {
    if (!group || typeof group.getObjects !== 'function') return false;
    if (!isLikelyPriceGroupObject(group)) return false;
    if (hasCorruptedPriceLayout(group)) return false;

    const nodes = collectObjectsDeep(group).filter((o: any) => isPriceLayoutNode(o));
    if (!nodes.length) return false;

    const makeKey = makePriceLayoutKeyBuilder();
    const snapshot = {
        version: 1,
        group: {
            width: Number(group?.width || 0),
            height: Number(group?.height || 0),
            scaleX: Number(group?.scaleX || 1),
            scaleY: Number(group?.scaleY || 1)
        },
        nodes: nodes.map((node: any) => ({
            key: makeKey(node),
            name: String(node?.name || ''),
            left: Number(node?.left || 0),
            top: Number(node?.top || 0),
            scaleX: Number(node?.scaleX || 1),
            scaleY: Number(node?.scaleY || 1),
            originX: String(node?.originX || 'left'),
            originY: String(node?.originY || 'top'),
            visible: node?.visible !== false,
            fontSize: Number(node?.fontSize || 0),
            width: Number(node?.width || 0),
            height: Number(node?.height || 0),
            text: typeof node?.text === 'string' ? node.text : undefined
        }))
    };

    (group as any).__priceLayoutSnapshot = snapshot;
    (group as any).__priceLayoutSnapshotAt = Date.now();
    return true;
};

const restorePriceLayoutSnapshot = (group: any) => {
    if (!group || typeof group.getObjects !== 'function') return false;
    const snapshot = (group as any).__priceLayoutSnapshot;
    if (!snapshot || !Array.isArray(snapshot?.nodes)) return false;

    const nodes = collectObjectsDeep(group).filter((o: any) => isPriceLayoutNode(o));
    if (!nodes.length) return false;

    const makeKey = makePriceLayoutKeyBuilder();
    const nodeByKey = new Map<string, any>();
    nodes.forEach((node: any) => nodeByKey.set(makeKey(node), node));

    let restoredAny = false;
    snapshot.nodes.forEach((snap: any) => {
        const node = nodeByKey.get(String(snap?.key || ''));
        if (!node) return;
        if (!isFiniteLayoutNumber(snap?.left) || !isFiniteLayoutNumber(snap?.top)) return;

        node.set?.({
            left: Number(snap.left),
            top: Number(snap.top),
            scaleX: isFiniteLayoutNumber(snap?.scaleX) ? Number(snap.scaleX) : 1,
            scaleY: isFiniteLayoutNumber(snap?.scaleY) ? Number(snap.scaleY) : 1,
            originX: String(snap?.originX || node.originX || 'left'),
            originY: String(snap?.originY || node.originY || 'top'),
            visible: snap?.visible !== false
        });

        const tt = String(node?.type || '').toLowerCase();
        const isText = tt === 'text' || tt === 'i-text' || tt === 'itext' || tt === 'textbox';
        if (isText) {
            if (isFiniteLayoutNumber(snap?.fontSize) && Number(snap.fontSize) > 0) node.set?.('fontSize', Number(snap.fontSize));
            if (typeof snap?.text === 'string' && typeof node?.text === 'string') node.set?.('text', snap.text);
            node.initDimensions?.();
        }
        node.setCoords?.();
        restoredAny = true;
    });

    if (snapshot?.group && typeof snapshot.group === 'object') {
        const nextW = Number(snapshot.group.width || 0);
        const nextH = Number(snapshot.group.height || 0);
        const nextScaleX = Number(snapshot.group.scaleX || 1);
        const nextScaleY = Number(snapshot.group.scaleY || 1);
        if (nextW > 0 && nextH > 0) {
            group.set?.({ width: nextW, height: nextH });
        }
        if (Number.isFinite(nextScaleX) && Number.isFinite(nextScaleY)) {
            group.set?.({ scaleX: nextScaleX, scaleY: nextScaleY });
        }
    }

    if (restoredAny) {
        group.dirty = true;
        group.setCoords?.();
    }

    return restoredAny;
};

const stabilizeSinglePriceGroupForPersistence = (group: any) => {
    if (!group || typeof group.getObjects !== 'function') return { fixed: false, captured: false };
    if (!isLikelyPriceGroupObject(group)) return { fixed: false, captured: false };

    const wasCorrupted = hasCorruptedPriceLayout(group);
    let fixed = false;

    if (wasCorrupted) {
        const restored = restorePriceLayoutSnapshot(group);
        if (restored) {
            fixed = !hasCorruptedPriceLayout(group);
        }

        if (!fixed) {
            const size = getCardSizeForPriceGroup(group);
            if (size) {
                try {
                    const result = layoutPriceGroup(group, size.width, size.height);
                    fixed = !!result && !hasCorruptedPriceLayout(group);
                } catch {
                    fixed = false;
                }
            }
        }
    }

    const captured = rememberPriceLayoutSnapshot(group);
    return { fixed, captured };
};

const stabilizePriceGroupsForPersistence = (canvasInstance: any, reason: string = 'unknown') => {
    if (!canvasInstance || typeof canvasInstance.getObjects !== 'function') return { fixed: 0, captured: 0 };
    const roots = canvasInstance.getObjects() || [];
    const candidates: any[] = [];
    const seen = new Set<any>();

    const visit = (node: any) => {
        if (!node || seen.has(node)) return;
        seen.add(node);
        if (isLikelyPriceGroupObject(node)) candidates.push(node);
        if (typeof node.getObjects === 'function') {
            (node.getObjects() || []).forEach((child: any) => visit(child));
        }
    };
    roots.forEach((root: any) => visit(root));

    let fixed = 0;
    let captured = 0;
    candidates.forEach((group: any) => {
        const result = stabilizeSinglePriceGroupForPersistence(group);
        if (result.fixed) fixed += 1;
        if (result.captured) captured += 1;
    });

    if (fixed > 0) {
        console.warn(`[price-layout] ${fixed} etiqueta(s) recuperada(s) antes de persistir (${reason})`);
    }
    return { fixed, captured };
};


function layoutPriceGroup(priceGroup: any, cardW: number, cardH: number) {
    if (!priceGroup || !priceGroup.getObjects) {
        return null;
    }
    const preferManualTemplateLayout = shouldPreserveManualTemplateVisual(priceGroup);
    const forceCanonicalAtacarejoLayout = (priceGroup as any).__forceAtacarejoCanonical === true;

    // Atacarejo template (2-tier label)
    try {
        let deep: any[] | null = null;
        let hasAtacarejo = false;
        const childCount = Array.isArray((priceGroup as any)._objects)
            ? (priceGroup as any)._objects.length
            : (priceGroup.getObjects?.() || []).length;
        const cachedProbe = priceGroupAtacarejoProbeCache.get(priceGroup);
        if (cachedProbe && cachedProbe.childCount === childCount) {
            hasAtacarejo = cachedProbe.hasAtacarejo;
        } else {
            deep = collectObjectsDeep(priceGroup);
            hasAtacarejo = !!findByName(deep, 'atac_retail_bg');
            priceGroupAtacarejoProbeCache.set(priceGroup, { childCount, hasAtacarejo });
        }

        if (hasAtacarejo) {
            if (!deep) deep = collectObjectsDeep(priceGroup);
            if (!forceCanonicalAtacarejoLayout && preferManualTemplateLayout) {
                // Manual templates from Mini Editor must keep authored geometry
                // (font weight, sizes and object positions). Do not collapse/reflow.
                const manual = layoutManualTemplateGroup(priceGroup, cardW, cardH);
                if (manual) {
                    rememberPriceLayoutSnapshot(priceGroup);
                    return manual;
                }
            }
            const atac = layoutAtacarejoPriceGroup(priceGroup, cardW, cardH);
            if (atac) rememberPriceLayoutSnapshot(priceGroup);
            return atac;
        }
    } catch {
        // fall through to legacy layout
    }

    const all = priceGroup.getObjects();

    const priceBg = all.find((o: any) => o.name === 'price_bg');
    const priceBgImage = all.find((o: any) => o.name === 'price_bg_image' || o.name === 'splash_image');
    const currencyCircle = all.find((o: any) => o.name === 'price_currency_bg' || o.name === 'priceSymbolBg');
    const currencyTextPrimary = all.find((o: any) => o.name === 'price_currency_text');
    const currencyTextLegacy = all.find((o: any) => o.name === 'priceSymbol' || o.name === 'price_currency');
    const currencyText = currencyTextPrimary || currencyTextLegacy;
    const priceText = all.find((o: any) => o.name === 'price_value_text' || o.name === 'smart_price');
    const priceInteger = all.find((o: any) => o.name === 'price_integer_text' || o.name === 'priceInteger' || o.name === 'price_integer');
    const priceDecimal = all.find((o: any) => o.name === 'price_decimal_text' || o.name === 'priceDecimal' || o.name === 'price_decimal');
    const priceUnit = all.find((o: any) => o.name === 'price_unit_text' || o.name === 'priceUnit' || o.name === 'price_unit');

    // Check if this has the standard template structure (price_bg + currencyCircle + currencyText + price texts)
    const hasStandardStructure = !!(priceBg && currencyCircle && currencyText &&
                                   (priceText || (priceInteger && priceDecimal)));

    // Check if this is a custom template:
    // - Explicitly marked as custom, OR
    // - Does NOT have standard structure BUT has __originalWidth metadata
    const isCustomTemplate = (priceGroup as any).__isCustomTemplate === true ||
                            (!hasStandardStructure && priceBg && typeof (priceBg as any).__originalWidth === 'number');

    // For custom templates, use proportional scaling to preserve original design
    if (isCustomTemplate && priceBg) {
        if (preferManualTemplateLayout) {
            const manual = layoutManualTemplateGroup(priceGroup, cardW, cardH);
            if (manual) {
                rememberPriceLayoutSnapshot(priceGroup);
                return manual;
            }
        }
        const custom = layoutCustomPriceGroup(priceGroup, cardW, cardH);
        if (custom) rememberPriceLayoutSnapshot(priceGroup);
        return custom;
    }
    
    if (!priceBg || !currencyCircle || !currencyText) {
        return null;
    }
    
    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));

    // Scale label by overall card size (avoid "stretch wide" when cards are wide).
    const base = Math.min(cardW, cardH);
    const pillH = clamp(base * 0.18, 46, Math.max(46, cardH * 0.24));
    const circleSize = pillH * 0.72; // Slightly smaller "R$" area
    const textGap = pillH * 0.18;
    const rightPad = pillH * 0.35;

    // If we have split parts, use them; otherwise fall back to `smart_price`.
    const hasSplit = !!(priceInteger && priceDecimal);
    const anyText = (hasSplit ? priceInteger : priceText);
    if (!anyText) return null;

    // Remove legacy duplicates that would inflate the group bounds (common after template edits).
    const recognized = new Set<any>([
        priceBg,
        priceBgImage,
        currencyCircle,
        currencyText,
        priceText,
        priceInteger,
        priceDecimal,
        priceUnit
    ]);
    const cleanupNames = new Set([
        'priceSymbol',
        'price_currency',
        'price_currency_text',
        'priceInteger',
        'priceDecimal',
        'priceUnit',
        'smart_price',
        'price_value_text'
    ]);
    all.forEach((o: any) => {
        if (!o || recognized.has(o)) return;
        if (!cleanupNames.has(String(o.name || ''))) return;
        // Drop duplicates from instances (keep templates clean via mini editor).
        if (typeof priceGroup.remove === 'function') priceGroup.remove(o);
    });

    const setTextSizing = (txt: any, defaultScale: number) => {
        if (!txt || !txt.type || !String(txt.type).includes('text')) return;
        const scale = typeof txt.__fontScale === 'number' ? txt.__fontScale : defaultScale;
        txt.set({ fontSize: pillH * scale, scaleX: 1, scaleY: 1 });
        if (typeof txt.initDimensions === 'function') txt.initDimensions();
    };

    if (hasSplit) {
        setTextSizing(priceInteger, 0.72);
        setTextSizing(priceDecimal, 0.42);
        setTextSizing(priceUnit, 0.26);
    } else {
        setTextSizing(priceText, 0.7);
    }

    // Normalize the unit label so we never show gramatura (e.g. "500ML") in the tag.
    if (priceUnit && priceUnit.visible !== false) {
        const cur = String(priceUnit.text || '').trim();
        if (cur) {
            const normalized = normalizeUnitForLabel(cur);
            if (normalized !== cur.toUpperCase().replace(/\s+/g, '')) {
                priceUnit.set?.('text', normalized);
                if (typeof priceUnit.initDimensions === 'function') priceUnit.initDimensions();
            }
        }
    }

    const getW = (t: any) => (t && typeof t.getScaledWidth === 'function' ? t.getScaledWidth() : 0);
    const calcTextWidth = () =>
        hasSplit
            ? (getW(priceInteger) + getW(priceDecimal))
            : getW(priceText);

    let textWidth = calcTextWidth();
    const maxPillW = cardW * 0.96;
    const minPillW = textWidth + (circleSize * 0.85) + textGap + rightPad;
    const minVisualW = Math.max(120, pillH * 2.6);
    let pillW = clamp(minPillW, minVisualW, maxPillW);
    
    if (minPillW > maxPillW && textWidth > 0) {
        const availableTextWidth = maxPillW - (circleSize * 0.85) - textGap - rightPad;
        if (availableTextWidth > 0) {
            const scale = availableTextWidth / textWidth;
            if (hasSplit) {
                if (priceInteger) priceInteger.set({ scaleX: scale, scaleY: scale });
                if (priceDecimal) priceDecimal.set({ scaleX: scale, scaleY: scale });
                if (priceUnit) priceUnit.set({ scaleX: scale, scaleY: scale });
            } else if (priceText) {
                priceText.set({ scaleX: scale, scaleY: scale });
            }
            textWidth = calcTextWidth();
        }
        pillW = maxPillW;
    }
    
    const roundness = clamp(
        typeof (priceBg as any).__roundness === 'number' ? (priceBg as any).__roundness : 1,
        0,
        1
    );
    const radius = (pillH / 2) * roundness;

    priceBg.set({
        width: pillW,
        height: pillH,
        rx: radius,
        ry: radius,
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0
    });

    // Keep the "neon" border/glow proportional to the pill size (prevents losing the pattern on resize).
    const customStrokeW = Number((priceBg as any).__strokeWidth);
    const strokeW = Number.isFinite(customStrokeW) ? clamp(customStrokeW, 0, Math.max(0, pillH * 0.2)) : Math.max(1, Math.min(4, pillH * 0.04));
    const accentColor = typeof priceBg.stroke === 'string' ? priceBg.stroke : '#ff0000';
    priceBg.set({ strokeWidth: strokeW });
    if (fabric?.Shadow) {
        const blur = Math.max(6, Math.min(26, pillH * 0.22));
        priceBg.set('shadow', new fabric.Shadow({ color: accentColor, blur, offsetX: 0, offsetY: 0 }));
    }

    // Optional: image as splash background (inside the pill)
    if (priceBgImage && priceBgImage.type === 'image') {
        const img: any = priceBgImage;
        img.set({
            originX: 'center',
            originY: 'center',
            left: 0,
            top: 0
        });
        // Use natural dimensions when available to avoid massive bounds.
        // Also: crop the image so its *actual bounds* match the pill (clipPath does not affect selection bounds).
        const el: any = img._originalElement || img._element;
        const iw = el?.naturalWidth || el?.width || img.width || 0;
        const ih = el?.naturalHeight || el?.height || img.height || 0;
        if (iw > 0 && ih > 0) {
            // Reset any previous crop so we can compute from the full image.
            img.set({ cropX: 0, cropY: 0, width: iw, height: ih });

            // Cover (no empty areas)
            let scale = Math.max(pillW / iw, pillH / ih);
            if (!Number.isFinite(scale) || scale <= 0) scale = 1;
            // Clamp (safety)
            scale = Math.min(scale, 20);

            // Crop window in source pixels so that, after scaling, bounds == pillW x pillH.
            const cropW = Math.min(iw, pillW / scale);
            const cropH = Math.min(ih, pillH / scale);
            const cropX = Math.max(0, (iw - cropW) / 2);
            const cropY = Math.max(0, (ih - cropH) / 2);

            img.set({ cropX, cropY, width: cropW, height: cropH, scaleX: scale, scaleY: scale });
        } else {
            // If the image hasn't reported dimensions yet, force its bounds to the pill.
            // This prevents a giant selection box until the real image dimensions are available.
            img.set({ cropX: 0, cropY: 0, width: pillW, height: pillH, scaleX: 1, scaleY: 1 });
        }
        // Clip to pill shape
        if (fabric?.Rect) {
            const clip = new fabric.Rect({
                width: pillW,
                height: pillH,
                rx: radius,
                ry: radius,
                originX: 'center',
                originY: 'center',
                left: 0,
                top: 0
            });
            img.set({ clipPath: clip });
        }
        // Ensure the rect doesn't hide the image (rect can still keep stroke/glow)
        if (typeof priceBg.fill === 'string' && priceBg.fill !== 'transparent') {
            priceBg.set('fill', 'transparent');
        }
        if (typeof (img as any).sendToBack === 'function') (img as any).sendToBack();
    }
    
    const circleCenterX = -(pillW / 2) + (circleSize * 0.35);
    currencyCircle.set({
        radius: circleSize / 2,
        originX: 'center',
        originY: 'center',
        left: circleCenterX,
        top: 0
    });
    
    currencyText.set({
        fontSize: circleSize * 0.32,
        originX: 'center',
        originY: 'center',
        left: circleCenterX,
        top: 0,
        scaleX: 1,
        scaleY: 1
    });

    const textStartX = circleCenterX + (circleSize / 2) + textGap;
    if (hasSplit) {
        const intY = (typeof priceInteger.__yOffsetRatio === 'number' ? priceInteger.__yOffsetRatio : 0) * pillH;
        const decY = (typeof priceDecimal.__yOffsetRatio === 'number' ? priceDecimal.__yOffsetRatio : -0.18) * pillH;
        const unitY = (typeof priceUnit?.__yOffsetRatio === 'number' ? priceUnit.__yOffsetRatio : 0.22) * pillH;
        const maxTextW = Math.max(20, (pillW / 2) - rightPad - textStartX);
        layoutPrice({
            priceInteger,
            priceDecimal,
            priceUnit,
            intX: textStartX,
            intY,
            decY,
            unitY,
            maxWidth: maxTextW,
            gapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
            minGapPx: PRICE_INTEGER_DECIMAL_GAP_PX,
            maxGapPx: PRICE_INTEGER_DECIMAL_GAP_PX
        });
    } else if (priceText) {
        const scaledTextWidth = priceText.getScaledWidth();
        const textCenterX = textStartX + (scaledTextWidth / 2);
        priceText.set({ originX: 'center', originY: 'center', left: textCenterX, top: 0 });
    }

    // CRITICAL: Do NOT call safeAddWithUpdate — it recalculates priceGroup bounds from
    // children (including shadows/strokes), expanding beyond pillW×pillH and causing the
    // card group to also expand when its bounds are recalculated.
    priceGroup.set({ width: pillW, height: pillH });
    const _pgParts = priceGroup.getObjects?.() || [];
    _pgParts.forEach((o: any) => { if (o && typeof o.setCoords === 'function') o.setCoords(); });
    priceGroup.dirty = true;
    if (typeof priceGroup.setCoords === 'function') priceGroup.setCoords();
    rememberPriceLayoutSnapshot(priceGroup);
    return { pillW, pillH };
}

function getPriceGroupFromAny(obj: any): any | null {
    if (!obj) return null;

    // Helper: Check if a group looks like a priceGroup by its structure (heuristic).
    // PriceGroups typically contain: a rect (pill background), 1-4 text elements (price digits),
    // and optionally a circle/ellipse (currency symbol).
    const looksLikePriceGroup = (g: any): boolean => {
        if (!g || g.type !== 'group' || typeof g.getObjects !== 'function') return false;
        if (isCardContainerLikeGroup(g)) return false;
        const kids = g.getObjects() || [];
        if (kids.length < 2 || kids.length > 10) return false;

        // Prefer deterministic signals from named template nodes when available.
        if (kids.some((k: any) => isPriceLayoutNode(k))) return true;
        
        let hasRect = false;
        let textCount = 0;
        let hasCircleOrEllipse = false;
        
        for (const k of kids) {
            const t = String(k?.type || '').toLowerCase();
            if (t === 'rect') hasRect = true;
            if (t === 'text' || t === 'i-text' || t === 'itext' || t === 'textbox') textCount++;
            if (t === 'circle' || t === 'ellipse') hasCircleOrEllipse = true;
        }
        
        // Heuristic: a priceGroup has at least a rect and some text, or circle/ellipse for currency
        return hasRect && (textCount >= 1 || hasCircleOrEllipse);
    };

    // Direct selection (group by name)
    if (obj.type === 'group' && obj.name === 'priceGroup') {
        if (!isMisnamedProductCardGroup(obj)) return obj;
    }
    
    // Heuristic fallback for direct selection when name is missing
    if (obj.type === 'group' && !obj.name && looksLikePriceGroup(obj)) {
        // Repair the name for future operations
        obj.name = 'priceGroup';
        return obj;
    }

    // If user selected a child inside the price group, walk up the group chain.
    let cur: any = obj;
    while (cur && cur.group) {
        if (cur.group.type === 'group' && cur.group.name === 'priceGroup') {
            if (!isMisnamedProductCardGroup(cur.group)) return cur.group;
        }
        // Heuristic fallback
        if (cur.group.type === 'group' && !cur.group.name && looksLikePriceGroup(cur.group)) {
            cur.group.name = 'priceGroup';
            return cur.group;
        }
        cur = cur.group;
    }

    // If a full card (or any group) is selected, grab its internal price group (deep).
    if (obj.type === 'group' && typeof obj.getObjects === 'function') {
        const queue: any[] = [...(obj.getObjects() || [])];
        while (queue.length) {
            const cur = queue.shift();
            if (!cur) continue;
            if (cur.type === 'group' && cur.name === 'priceGroup') {
                if (!isMisnamedProductCardGroup(cur)) return cur;
            }
            // Heuristic fallback for nested groups
            if (cur.type === 'group' && !cur.name && looksLikePriceGroup(cur)) {
                cur.name = 'priceGroup';
                return cur;
            }
            if (cur.type === 'group' && typeof cur.getObjects === 'function') {
                const kids = cur.getObjects() || [];
                for (const k of kids) queue.push(k);
            }
        }
    }

    return null;
}

function getCardGroupFromAny(obj: any): any | null {
    if (!obj) return null;
    if (obj.type === 'group' && (obj.isSmartObject || obj.isProductCard)) return obj;
    let cur: any = obj;
    while (cur && cur.group) {
        if (cur.group.type === 'group' && (cur.group.isSmartObject || cur.group.isProductCard)) return cur.group;
        cur = cur.group;
    }
    return null;
}

const enlivenObjectsAsync = (objectsJson: any[]) => {
    if (!fabric?.util?.enlivenObjects) return Promise.resolve([]);
    const fn = fabric.util.enlivenObjects;
    try {
        const maybe = fn(objectsJson);
        if (maybe && typeof maybe.then === 'function') return maybe;
    } catch (_) {
        // fall back to callback form below
    }
    return new Promise<any[]>((resolve, reject) => {
        try {
            fn(objectsJson, (enlivened: any[]) => resolve(enlivened));
        } catch (err) {
            reject(err);
        }
    });
};

const seedManualTemplateOriginalMetrics = (group: any) => {
    if (!group || typeof group.getObjects !== 'function') return;
    const all = collectObjectsDeep(group);
    const clampScale = (raw: any, fallback: any, min = 0.08, max = 3.2) => {
        const fb = Number(fallback);
        const safeFallback = Number.isFinite(fb) && Math.abs(fb) > 0 ? fb : 1;
        const n = Number(raw);
        if (!Number.isFinite(n) || n === 0) return safeFallback;
        const sign = n < 0 ? -1 : 1;
        const mag = Math.min(max, Math.max(min, Math.abs(n)));
        return sign * mag;
    };
    all.forEach((obj: any) => {
        if (!obj) return;

        const asNum = (v: any) => {
            const n = Number(v);
            return Number.isFinite(n) ? n : undefined;
        };

        if (asNum(obj.__originalLeft) == null) obj.__originalLeft = asNum(obj.left) ?? 0;
        if (asNum(obj.__originalTop) == null) obj.__originalTop = asNum(obj.top) ?? 0;
        if (!obj.__originalOriginX) obj.__originalOriginX = obj.originX ?? 'center';
        if (!obj.__originalOriginY) obj.__originalOriginY = obj.originY ?? 'center';
        obj.__originalScaleX = clampScale(
            asNum(obj.__originalScaleX),
            asNum(obj.scaleX) ?? 1
        );
        obj.__originalScaleY = clampScale(
            asNum(obj.__originalScaleY),
            asNum(obj.scaleY) ?? 1
        );
        if (asNum(obj.__originalStrokeWidth) == null) obj.__originalStrokeWidth = asNum(obj.strokeWidth) ?? 0;

        if (isTextLikeObject(obj)) {
            if (typeof obj.initDimensions === 'function') obj.initDimensions();
            if (asNum(obj.__originalFontSize) == null) obj.__originalFontSize = asNum(obj.fontSize) ?? 14;
            if (typeof obj.__originalFontFamily !== 'string' && typeof obj.fontFamily === 'string') {
                obj.__originalFontFamily = obj.fontFamily;
            }
            if (asNum(obj.__originalWidth) == null) {
                const w = asNum(obj.width) ?? asNum(obj.getScaledWidth?.());
                obj.__originalWidth = Math.max(1, w ?? 1);
            }
            if (asNum(obj.__originalHeight) == null) {
                const h = asNum(obj.height) ?? asNum(obj.getScaledHeight?.());
                obj.__originalHeight = Math.max(1, h ?? (asNum(obj.fontSize) ?? 14));
            }
            return;
        }

        if (obj.type === 'rect') {
            if (asNum(obj.__originalWidth) == null) obj.__originalWidth = Math.max(1, asNum(obj.width) ?? 1);
            if (asNum(obj.__originalHeight) == null) obj.__originalHeight = Math.max(1, asNum(obj.height) ?? 1);
            if (asNum(obj.__originalRx) == null) obj.__originalRx = asNum(obj.rx) ?? 0;
            if (asNum(obj.__originalRy) == null) obj.__originalRy = asNum(obj.ry) ?? 0;
            return;
        }

        if (obj.type === 'circle' && asNum(obj.__originalRadius) == null) {
            obj.__originalRadius = Math.max(1, asNum(obj.radius) ?? 1);
        }
    });
};

const collectTemplateJsonNodes = (root: any): any[] => {
    const out: any[] = [];
    const stack: any[] = Array.isArray(root?.objects) ? [...root.objects] : [];
    while (stack.length) {
        const cur = stack.pop();
        if (!cur || typeof cur !== 'object') continue;
        out.push(cur);
        if (Array.isArray(cur.objects)) {
            for (const child of cur.objects) stack.push(child);
        }
    }
    return out;
};

const isTemplateGroupJsonRenderable = (groupJson: any): boolean => {
    if (!groupJson || typeof groupJson !== 'object') return false;
    const objects = collectTemplateJsonNodes(groupJson);
    if (!objects.length) return false;

    const hasName = (name: string) => objects.some((o: any) => String(o?.name || '') === name);
    const hasAtac =
        hasName('atac_retail_bg') &&
        hasName('atac_banner_bg') &&
        hasName('atac_wholesale_bg');
    if (hasAtac) return true;

    const hasSinglePriceCore =
        hasName('price_bg') &&
        (
            hasName('price_integer_text') ||
            hasName('price_value_text') ||
            hasName('smart_price')
        );
    if (hasSinglePriceCore) return true;

    // Generic fallback: at least one rect and one text-like node.
    let hasRect = false;
    let hasText = false;
    for (const node of objects) {
        const t = String(node?.type || '').toLowerCase();
        if (t === 'rect') hasRect = true;
        if (t === 'text' || t === 'i-text' || t === 'itext' || t === 'textbox') hasText = true;
        if (hasRect && hasText) return true;
    }
    return false;
};

const isAtacarejoTemplateGroupJson = (groupJson: any): boolean => {
    if (!groupJson || typeof groupJson !== 'object') return false;
    const nodes = collectTemplateJsonNodes(groupJson);
    return nodes.some((o: any) => String(o?.name || '') === 'atac_retail_bg');
};

const pickRenderableTemplateGroupJson = (tpl: LabelTemplate, preferredVariantKey?: AtacVariantKey) => {
    const baseGroupJson: any = (tpl as any)?.group;
    const variantMap = ((baseGroupJson as any)?.__atacVariantGroups || {}) as Record<string, any>;
    const useVariantSnapshots = shouldUseAtacVariantSnapshotsForTemplate(baseGroupJson);

    const hasAnyObjects = (groupJson: any): boolean => {
        const objs = Array.isArray(groupJson?.objects) ? groupJson.objects : [];
        return objs.length > 0;
    };

    if (!useVariantSnapshots) {
        if (isTemplateGroupJsonRenderable(baseGroupJson) || hasAnyObjects(baseGroupJson)) return baseGroupJson;
        const orderedRecoveryKeys = ['normal', 'tiny', 'large'];
        for (const k of orderedRecoveryKeys) {
            const snap = (variantMap as any)?.[k];
            if (isTemplateGroupJsonRenderable(snap) || hasAnyObjects(snap)) return snap;
        }
        for (const snap of Object.values(variantMap || {})) {
            if (isTemplateGroupJsonRenderable(snap) || hasAnyObjects(snap)) return snap;
        }
        return null;
    }

    const preferredVariant =
        preferredVariantKey && variantMap && typeof variantMap === 'object'
            ? variantMap[String(preferredVariantKey)]
            : null;

    if (isTemplateGroupJsonRenderable(preferredVariant) || hasAnyObjects(preferredVariant)) {
        return preferredVariant;
    }
    if (isTemplateGroupJsonRenderable(baseGroupJson) || hasAnyObjects(baseGroupJson)) {
        return baseGroupJson;
    }

    // Recovery path: pick first valid variation snapshot.
    if (variantMap && typeof variantMap === 'object') {
        const orderedKeys = preferredVariantKey
            ? [String(preferredVariantKey), 'normal', 'tiny', 'large']
            : ['normal', 'tiny', 'large'];
        for (const k of orderedKeys) {
            const snap = (variantMap as any)?.[k];
            if (isTemplateGroupJsonRenderable(snap) || hasAnyObjects(snap)) return snap;
        }
        for (const snap of Object.values(variantMap || {})) {
            if (isTemplateGroupJsonRenderable(snap) || hasAnyObjects(snap)) return snap;
        }
    }

    return null;
};

const templateSnapshotHasAtacStructure = (snapshot: any) => {
    if (!snapshot || typeof snapshot !== 'object') return false;
    if (String((snapshot as any).name || '') === 'atac_retail_bg') return true;
    const stack: any[] = [];
    const rootJsonChildren = Array.isArray((snapshot as any).objects) ? (snapshot as any).objects : [];
    const rootFabricChildren = Array.isArray((snapshot as any)._objects)
        ? (snapshot as any)._objects
        : (typeof (snapshot as any).getObjects === 'function' ? (snapshot as any).getObjects() : []);
    if (rootJsonChildren.length) stack.push(...rootJsonChildren);
    if (rootFabricChildren.length) stack.push(...rootFabricChildren);
    while (stack.length) {
        const obj = stack.pop();
        if (!obj || typeof obj !== 'object') continue;
        if (String((obj as any).name || '') === 'atac_retail_bg') return true;
        const nestedJson = Array.isArray((obj as any).objects) ? (obj as any).objects : [];
        const nestedFabric = Array.isArray((obj as any)._objects)
            ? (obj as any)._objects
            : (typeof (obj as any).getObjects === 'function' ? (obj as any).getObjects() : []);
        if (nestedJson.length) stack.push(...nestedJson);
        if (nestedFabric.length) stack.push(...nestedFabric);
    }
    return false;
};

const shouldForceCanonicalAtacForTemplateJson = (snapshot: any) => {
    // Only honor the explicit flag. Atacarejo structure alone should NOT force code-driven reflow,
    // otherwise Mini Editor templates won't persist exactly as authored.
    return !!(snapshot && typeof snapshot === 'object' && (snapshot as any).__forceAtacarejoCanonical === true);
};

const shouldUseAtacVariantSnapshotsForTemplate = (_snapshot: any) => {
    // Fixed Atacarejo layout: do not select per-variant snapshots in runtime.
    return false;
};

async function instantiatePriceGroupFromTemplate(tpl: LabelTemplate, opts?: { atacVariantKey?: AtacVariantKey }): Promise<any> {
    const preferredVariantKey = opts?.atacVariantKey;
    const baseGroupJson: any = tpl?.group;
    const groupJson: any = pickRenderableTemplateGroupJson(tpl, preferredVariantKey);
    if (!fabric || !groupJson) throw new Error('Template missing group JSON');
    const objectsJson = Array.isArray(groupJson.objects) ? groupJson.objects : [];
    if (objectsJson.length === 0) throw new Error('Template group JSON has no objects');
    const groupOpts = { ...groupJson };
    delete (groupOpts as any).objects;
    // Fabric objects have a fixed `type` based on the class; restoring `type` from JSON is ignored and warns.
    delete (groupOpts as any).type;
    // Never restore layoutManager from plain JSON (Fabric v7 expects class instance).
    delete (groupOpts as any).layoutManager;
    delete (groupOpts as any).layout;
    const enlivened = await enlivenObjectsAsync(objectsJson);
    if (!Array.isArray(enlivened) || enlivened.length === 0) throw new Error('Template group failed to enliven objects');
    const g = new fabric.Group(enlivened, groupOpts);
    const cloneSafe = <T>(value: T): T => {
        try {
            return typeof structuredClone === 'function'
                ? structuredClone(value)
                : JSON.parse(JSON.stringify(value));
        } catch {
            return value;
        }
    };
    // IMPORTANT: Any label template coming from the template system must preserve
    // the geometry authored in Mini Editor. Automatic reflow is only for legacy/default
    // programmatic groups, not for user template instances.
    const preserveManualLayout = typeof (groupOpts as any).__preserveManualLayout === 'boolean'
        ? !!(groupOpts as any).__preserveManualLayout
        : true;
    // Ensure templates always start from a normalized transform.
    g.set({ name: 'priceGroup', originX: 'center', originY: 'center', left: 0, top: 0, scaleX: 1, scaleY: 1, angle: 0 });
    (g as any).__preserveManualLayout = preserveManualLayout;
    (g as any).__isCustomTemplate = true;
    // Keep Atacarejo templates on canonical layout across all value variants.
    (g as any).__forceAtacarejoCanonical = shouldForceCanonicalAtacForTemplateJson(baseGroupJson);
    const useVariantSnapshots = shouldUseAtacVariantSnapshotsForTemplate(baseGroupJson);
    if (baseGroupJson && typeof baseGroupJson === 'object') {
        const rehydrateKeys = [
            '__manualTemplateBaseW',
            '__manualTemplateBaseH',
            '__manualGapSingle',
            '__manualGapRetail',
            '__manualGapWholesale',
            '__manualSingleAnchors'
        ] as const;
        for (const key of rehydrateKeys) {
            if (key in (baseGroupJson as any)) {
                (g as any)[key] = cloneSafe((baseGroupJson as any)[key]);
            }
        }
        if (typeof (baseGroupJson as any).__atacValueVariants === 'object') {
            (g as any).__atacValueVariants = cloneSafe((baseGroupJson as any).__atacValueVariants);
        }
        if (useVariantSnapshots && typeof (baseGroupJson as any).__atacVariantGroups === 'object') {
            (g as any).__atacVariantGroups = cloneSafe((baseGroupJson as any).__atacVariantGroups);
        } else {
            (g as any).__atacVariantGroups = {};
        }
    }
    if (preserveManualLayout) seedManualTemplateOriginalMetrics(g);
    return g;
}

function normalizePriceGroupForPreview(pg: any) {
    if (!pg || typeof pg.getObjects !== 'function') return;
    pg.set({ originX: 'center', originY: 'center', left: 0, top: 0, scaleX: 1, scaleY: 1, angle: 0 });

    const all: any[] = pg.getObjects();

    // ===== ATACAREJO TEMPLATE SUPPORT =====
    // Check if this is an atacarejo (2-price) template by looking for the retail background
    const retailBg = all.find(o => o?.name === 'atac_retail_bg');
    const isAtacarejo = !!retailBg;

    if (isAtacarejo) {
        // Keep preview exactly aligned with runtime layout.
        layoutAtacarejoPriceGroup(pg, 320, 450);
        safeAddWithUpdate(pg);
        return;
    }

    // ===== STANDARD SINGLE-PRICE TEMPLATE =====
    const priceBg = all.find(o => o?.name === 'price_bg');
    const priceBgImage = all.find(o => o?.name === 'price_bg_image' || o?.name === 'splash_image');
    const currencyCircle = all.find(o => o?.name === 'price_currency_bg' || o?.name === 'priceSymbolBg');
    const currencyTextPrimary = all.find(o => o?.name === 'price_currency_text');
    const currencyTextLegacy = all.find(o => o?.name === 'priceSymbol' || o?.name === 'price_currency');
    const currencyText = currencyTextPrimary || currencyTextLegacy;
    const priceText = all.find(o => o?.name === 'smart_price' || o?.name === 'price_value_text');
    const priceInteger = all.find(o => o?.name === 'price_integer_text' || o?.name === 'priceInteger');
    const priceDecimal = all.find(o => o?.name === 'price_decimal_text' || o?.name === 'priceDecimal');
    const priceUnit = all.find(o => o?.name === 'price_unit_text' || o?.name === 'priceUnit');

    // Drop legacy duplicates that inflate bounds (causes tiny/offset previews).
    const recognized = new Set<any>([
        priceBg,
        priceBgImage,
        currencyCircle,
        currencyText,
        priceText,
        priceInteger,
        priceDecimal,
        priceUnit
    ]);
    const cleanupNames = new Set([
        'priceSymbol',
        'price_currency',
        'price_currency_text',
        'priceInteger',
        'priceDecimal',
        'priceUnit',
        'smart_price',
        'price_value_text'
    ]);
    all.forEach((o) => {
        if (!o || recognized.has(o)) return;
        if (!cleanupNames.has(String(o.name || ''))) return;
        pg.remove(o);
    });

    // If there's a splash image, crop it so its real bounds match the pill.
    if (priceBgImage && priceBg && priceBgImage.type === 'image' && priceBg.type === 'rect') {
        const img: any = priceBgImage;
        const pillW = priceBg.width || 1;
        const pillH = priceBg.height || 1;
        img.set({ originX: 'center', originY: 'center', left: 0, top: 0 });

        const el: any = img._originalElement || img._element;
        const iw = el?.naturalWidth || el?.width || img.width || 0;
        const ih = el?.naturalHeight || el?.height || img.height || 0;
        if (iw > 0 && ih > 0) {
            img.set({ cropX: 0, cropY: 0, width: iw, height: ih });
            let scale = Math.max(pillW / iw, pillH / ih);
            if (!Number.isFinite(scale) || scale <= 0) scale = 1;
            scale = Math.min(scale, 20);
            const cropW = Math.min(iw, pillW / scale);
            const cropH = Math.min(ih, pillH / scale);
            const cropX = Math.max(0, (iw - cropW) / 2);
            const cropY = Math.max(0, (ih - cropH) / 2);
            img.set({ cropX, cropY, width: cropW, height: cropH, scaleX: scale, scaleY: scale });
        } else {
            img.set({ cropX: 0, cropY: 0, width: pillW, height: pillH, scaleX: 1, scaleY: 1 });
        }
    }

    safeAddWithUpdate(pg);
}

function serializePriceGroupForTemplate(pg: any) {
    if (!pg || typeof pg.toObject !== 'function') return null;

    const prev = {
        left: pg.left,
        top: pg.top,
        scaleX: pg.scaleX,
        scaleY: pg.scaleY,
        angle: pg.angle,
        originX: pg.originX,
        originY: pg.originY
    };

    // Normalize so saved templates are position/scale-independent.
    pg.set({ left: 0, top: 0, scaleX: 1, scaleY: 1, angle: 0, originX: 'center', originY: 'center' });
    safeAddWithUpdate(pg);
    const j: any = pg.toObject(LABEL_TEMPLATE_EXTRA_PROPS);
    const useVariantSnapshots = shouldUseAtacVariantSnapshotsForTemplate(pg);
    if (typeof (pg as any).__atacValueVariants === 'object') {
        j.__atacValueVariants = (pg as any).__atacValueVariants;
    }
    if (useVariantSnapshots && typeof (pg as any).__atacVariantGroups === 'object') {
        j.__atacVariantGroups = (pg as any).__atacVariantGroups;
    } else {
        delete j.__atacVariantGroups;
    }
    pg.set(prev);
    safeAddWithUpdate(pg);
    delete j.layoutManager;
    delete j.layout;

    // Mark this as a custom template and store original dimensions for proportional scaling
    (j as any).__isCustomTemplate = true;

    // Store original values on each object for proportional scaling
    if (Array.isArray(j.objects)) {
        j.objects.forEach((obj: any) => {
            if (!obj) return;

            // Store original position
            obj.__originalLeft = obj.left;
            obj.__originalTop = obj.top;
            obj.__originalOriginX = obj.originX;
            obj.__originalOriginY = obj.originY;
            obj.__originalScaleX = obj.scaleX || 1;
            obj.__originalScaleY = obj.scaleY || 1;

            // For text objects, store original font size and font family
            if (isTextLikeObject(obj)) {
                if (typeof obj.fontSize === 'number') {
                    obj.__originalFontSize = obj.fontSize;
                }
                if (typeof obj.fontFamily === 'string') {
                    obj.__originalFontFamily = obj.fontFamily;
                }
                if (typeof obj.width === 'number') {
                    obj.__originalWidth = obj.width;
                }
                if (typeof obj.height === 'number') {
                    obj.__originalHeight = obj.height;
                }
            }

            // For circles, store original radius
            if (obj.type === 'circle' && typeof obj.radius === 'number') {
                obj.__originalRadius = obj.radius;
            }

            // For rects, store original dimensions and radius
            if (obj.type === 'rect') {
                if (typeof obj.width === 'number') obj.__originalWidth = obj.width;
                if (typeof obj.height === 'number') obj.__originalHeight = obj.height;
                if (typeof obj.rx === 'number') obj.__originalRx = obj.rx;
                if (typeof obj.ry === 'number') obj.__originalRy = obj.ry;

                // For price_bg, store special metadata
                if (obj.name === 'price_bg') {
                    obj.__originalWidth = obj.width;
                    obj.__originalHeight = obj.height;
                    obj.__roundness = typeof obj.rx === 'number' && obj.height > 0
                        ? (obj.rx * 2) / obj.height
                        : 1;
                    if (typeof obj.strokeWidth === 'number') {
                        obj.__strokeWidth = obj.strokeWidth;
                    }
                    if (obj.shadow && typeof obj.shadow.blur === 'number') {
                        obj.__shadowBlur = obj.shadow.blur;
                    }
                }
            }

            // Store original stroke width
            if (typeof obj.strokeWidth === 'number') {
                obj.__originalStrokeWidth = obj.strokeWidth;
            }
        });
    }

    return j;
}

function setPriceOnPriceGroup(pg: any, rawPrice: string, unitText?: string) {
    if (!pg || typeof pg.getObjects !== 'function') return;
    const parts = collectObjectsDeep(pg);
    const preserveTemplateVisual = shouldPreserveManualTemplateVisual(pg);
    const isVisibleNode = (obj: any): boolean => {
        if (!obj) return false;
        if (obj.visible === false) return false;
        const sx = Number(obj.scaleX ?? 1);
        const sy = Number(obj.scaleY ?? 1);
        if (!Number.isFinite(sx) || !Number.isFinite(sy)) return true;
        return sx !== 0 && sy !== 0;
    };

    const currency = parts.find((o: any) => o?.name === 'price_currency_text');
    if (currency && (!currency.text || String(currency.text).trim().length === 0)) currency.set?.('text', 'R$');

    const intTxt = parts.find((o: any) => o?.name === 'price_integer_text');
    const decTxt = parts.find((o: any) => o?.name === 'price_decimal_text');
    const unitTxt = parts.find((o: any) => o?.name === 'price_unit_text');
    const legacy = parts.find((o: any) => o?.name === 'smart_price' || o?.name === 'price_value_text');

    const priceParts = splitPriceParts(rawPrice);
    const integer = priceParts.integer;
    const decimalText = `,${priceParts.dec}`;
    const hasSplitPair = !!(intTxt && decTxt);
    const hasLegacy = !!legacy;
    const splitLooksLikeMainPrice = !!(
        hasSplitPair && (
            isVisibleNode(currency) ||
            !hasLegacy ||
            !isVisibleNode(legacy)
        )
    );

    if (hasSplitPair && splitLooksLikeMainPrice) {
        // Capture authored Mini Editor anchors BEFORE changing text,
        // so dynamic values keep the exact original spacing.
        if (preserveTemplateVisual && !(pg as any).__manualSingleAnchors) {
            readSingleManualPriceAnchors(pg, { force: true });
        }
        intTxt.set?.('text', integer);
        decTxt.set?.('text', decimalText);
        if (typeof intTxt.initDimensions === 'function') intTxt.initDimensions();
        if (typeof decTxt.initDimensions === 'function') decTxt.initDimensions();

        if (unitTxt) {
            const raw = (typeof unitText === 'string' && unitText.trim().length) ? unitText : String(unitTxt.text || '').trim();
            const u = raw ? normalizeUnitForLabel(raw) : '';
            unitTxt.set?.('text', u);
            if (typeof unitTxt.initDimensions === 'function') unitTxt.initDimensions();
        }
        // Keep Mini Editor templates visually identical and only fit dynamic values.
        if (preserveTemplateVisual) {
            fitManualSinglePriceValuesIntoTemplate(pg);
        } else {
            expandManualTemplateWidthForDynamicPrice(pg);
        }
        return;
    }

    if (legacy) {
        legacy.set?.('text', `${integer}${decimalText}`);
        if (typeof legacy.initDimensions === 'function') legacy.initDimensions();
    } else if (hasSplitPair) {
        // Fallback: if no legacy field exists, still update split fields.
        if (preserveTemplateVisual && !(pg as any).__manualSingleAnchors) {
            readSingleManualPriceAnchors(pg, { force: true });
        }
        intTxt.set?.('text', integer);
        decTxt.set?.('text', decimalText);
        if (typeof intTxt.initDimensions === 'function') intTxt.initDimensions();
        if (typeof decTxt.initDimensions === 'function') decTxt.initDimensions();
        if (unitTxt) {
            const raw = (typeof unitText === 'string' && unitText.trim().length) ? unitText : String(unitTxt.text || '').trim();
            const u = raw ? normalizeUnitForLabel(raw) : '';
            unitTxt.set?.('text', u);
            if (typeof unitTxt.initDimensions === 'function') unitTxt.initDimensions();
        }
    }
    // Keep Mini Editor templates visually identical and only fit dynamic values.
    if (preserveTemplateVisual) {
        fitManualSinglePriceValuesIntoTemplate(pg);
    } else {
        expandManualTemplateWidthForDynamicPrice(pg);
    }
}

function extractWeightTokenForHeader(product: any): string {
    const nameRaw = String(product?.name || '').toUpperCase();
    const weightRaw = String(product?.weight || '').toUpperCase();
    const probe = `${nameRaw} ${weightRaw}`;
    const match = probe.match(/(\d+\s*[Xx×]\s*\d+(?:[.,]\d+)?\s*(?:KG|KGS|G|GR|GRS|MG|ML|MLS|L|LT|LTS|UN)\b|\d+(?:[.,]\d+)?\s*(?:KG|KGS|G|GR|GRS|MG|ML|MLS|L|LT|LTS|UN)\b)/i);
    if (!match) return '';
    return String(match[1] || '')
        .toUpperCase()
        .replace(/\s*[Xx×]\s*/g, 'X')
        .replace(/\s+/g, '')
        .replace(/GRS?\b/g, 'G')
        .replace(/KGS\b/g, 'KG')
        .replace(/MLS\b/g, 'ML')
        .replace(/LTS\b/g, 'L');
}

function normalizeHeaderWeightToken(value: string): string {
    return String(value || '')
        .toUpperCase()
        .replace(/\s+/g, '')
        .replace(/GRS?\b/g, 'G')
        .replace(/KGS\b/g, 'KG')
        .replace(/MLS\b/g, 'ML')
        .replace(/LTS\b/g, 'L');
}

function inferHeaderPartsFromProduct(
    product: any,
    fallback?: string,
    opts: { preferFullNameWithWeight?: boolean; splitUnitIntoDedicatedField?: boolean } = {}
): { title: string; unit: string } {
    const fallbackText = String(fallback || 'OFERTA').trim() || 'OFERTA';
    const rawName = String(product?.name || '').replace(/\s+/g, ' ').trim();
    const { cleanedName } = extractLimitFromName(rawName);
    const inferredUnit = inferUnitLabelFromProduct(product);
    const unit = inferredUnit === 'KG' ? 'KG' : (inferredUnit === 'UN' ? 'UN' : '');
    const splitUnitIntoDedicatedField = opts.splitUnitIntoDedicatedField !== false;

    let title = String(cleanedName || fallbackText).toUpperCase();
    title = title
        .replace(/\bR\$\s*[\d\.,]+\b/g, '')
        .replace(/\s+/g, ' ')
        .trim();

    const weightToken = extractWeightTokenForHeader(product);
    if (opts.preferFullNameWithWeight && weightToken && !normalizeHeaderWeightToken(title).includes(normalizeHeaderWeightToken(weightToken))) {
        title = `${title} ${weightToken}`.replace(/\s+/g, ' ').trim();
    }
    if (opts.preferFullNameWithWeight && !weightToken && unit === 'KG' && !/\bKG\b/i.test(title)) {
        title = `${title} KG`.replace(/\s+/g, ' ').trim();
    }

    // If the template uses a dedicated unit field, avoid duplicate unit suffix in title.
    if (splitUnitIntoDedicatedField && unit && new RegExp(`\\b${unit}\\b$`, 'i').test(title)) {
        title = title.replace(new RegExp(`\\b${unit}\\b$`, 'i'), '').trim();
    }

    if (!title) title = fallbackText.toUpperCase();
    const maxLen = opts.preferFullNameWithWeight ? 36 : 26;
    if (title.length > maxLen) {
        if (opts.preferFullNameWithWeight && weightToken && maxLen > weightToken.length + 6) {
            const prefixMax = maxLen - (weightToken.length + 1);
            const withoutWeight = title.replace(weightToken, '').replace(/\s+/g, ' ').trim();
            title = `${withoutWeight.slice(0, prefixMax).trim()} ${weightToken}`.trim();
        } else {
            title = `${title.slice(0, maxLen).trim()}...`;
        }
    }
    return { title, unit: splitUnitIntoDedicatedField ? unit : '' };
}

function inferUnitFromCard(card: any): string | undefined {
    if (!card) return 'UN';
    // Prefer explicit metadata (new cards store it on the group).
    const meta = (card as any).unitLabel ?? (card as any).unit ?? (card as any).packUnit ?? '';
    if (String(meta || '').trim().length) return normalizeUnitForLabel(meta);

    // Fallback: if the title mentions KG anywhere, treat as KG (gramatura stays in the name).
    if (typeof card.getObjects === 'function') {
        const title = card.getObjects().find((o: any) => o?.name === 'smart_title' || o?.name === 'title');
        const text = String(title?.text || '');
        if (/\bkg\b/i.test(text)) return 'KG';
    }
    return 'UN';
}

function inferHeaderPartsForPriceTemplate(
    card: any,
    fallback?: string,
    opts: { preferFullNameWithWeight?: boolean; splitUnitIntoDedicatedField?: boolean } = {}
): { title: string; unit: string } {
    const fallbackText = String(fallback || 'OFERTA').trim() || 'OFERTA';
    const productData = (card as any)?._productData || {};
    const titleObj = getCardTitleText(card);
    const rawFromCard = String(titleObj?.text || '').replace(/\s+/g, ' ').trim();
    const titleRaw = String(productData?.name || rawFromCard).replace(/\s+/g, ' ').trim();

    const inferredUnit = inferUnitFromCard(card);
    const unit = inferredUnit === 'KG' ? 'KG' : (inferredUnit === 'UN' ? 'UN' : '');
    const splitUnitIntoDedicatedField = opts.splitUnitIntoDedicatedField !== false;
    const weightToken = extractWeightTokenForHeader({
        name: productData?.name || titleRaw,
        weight: productData?.weight || ''
    });

    let title = titleRaw ? titleRaw.toUpperCase() : fallbackText.toUpperCase();
    title = title
        .replace(/\bR\$\s*[\d\.,]+\b/g, '')
        .replace(/\s+/g, ' ')
        .trim();

    if (opts.preferFullNameWithWeight && weightToken && !normalizeHeaderWeightToken(title).includes(normalizeHeaderWeightToken(weightToken))) {
        title = `${title} ${weightToken}`.replace(/\s+/g, ' ').trim();
    }
    if (opts.preferFullNameWithWeight && !weightToken && unit === 'KG' && !/\bKG\b/i.test(title)) {
        title = `${title} KG`.replace(/\s+/g, ' ').trim();
    }
    if (splitUnitIntoDedicatedField) {
        title = title.replace(/\b(KG|UN)\b$/i, '').trim();
    }

    if (!title) title = fallbackText.toUpperCase();
    const maxLen = opts.preferFullNameWithWeight ? 36 : 22;
    if (title.length > maxLen) {
        if (opts.preferFullNameWithWeight && weightToken && maxLen > weightToken.length + 6) {
            const prefixMax = maxLen - (weightToken.length + 1);
            const withoutWeight = title.replace(weightToken, '').replace(/\s+/g, ' ').trim();
            title = `${withoutWeight.slice(0, prefixMax).trim()} ${weightToken}`.trim();
        } else {
            title = `${title.slice(0, maxLen).trim()}...`;
        }
    }

    return { title, unit: splitUnitIntoDedicatedField ? unit : '' };
}

async function renderLabelTemplatePreview(tpl: LabelTemplate): Promise<string | undefined> {
    if (!fabric) return undefined;
    try {
        const el = document.createElement('canvas');
        el.width = 280;
        el.height = 110;
        const sc = new fabric.StaticCanvas(el, { backgroundColor: 'transparent' });
        const g = await instantiatePriceGroupFromTemplate(tpl);
        const preserveTemplateVisual = shouldPreserveManualTemplateVisual(g);
        // Legacy/basic templates may need a preview normalization pass.
        if (!preserveTemplateVisual) {
            normalizePriceGroupForPreview(g);
        }
        // Always run runtime layout in the preview instance so thumbnails stay stable
        // after reload (manual templates use layoutManualTemplateGroup here).
        layoutPriceGroup(g, 320, 220);
        g.set({ left: sc.getWidth() / 2, top: sc.getHeight() / 2 });
        // Fit with a bit of padding
        const bw = g.getScaledWidth?.() ?? g.width ?? 1;
        const bh = g.getScaledHeight?.() ?? g.height ?? 1;
        // Allow upscaling so the label fills the thumbnail area (prevents tiny previews).
        const scale = Math.min((sc.getWidth() * 0.95) / bw, (sc.getHeight() * 0.9) / bh, 3);
        g.set({ scaleX: scale, scaleY: scale });
        sc.add(g);
        try {
            sc.renderAll();
        } catch (e) {
            // Ignore render errors on static canvas
        }
        const url = sc.toDataURL({ format: 'png', multiplier: 1 });
        try {
            sc.dispose();
        } catch (e) {
            // Ignore dispose errors
        }
        return url;
    } catch (err) {
        console.warn('[labelTemplates] Failed to render preview', err);
        return undefined;
    }
}

async function createLabelTemplateFromSelection(name: string) {
    if (!canvas.value) return;
    const pg = getPriceGroupFromAny(canvas.value.getActiveObject());
    if (!pg) return;

    const now = new Date().toISOString();
    const tpl: LabelTemplate = {
        id: Math.random().toString(36).substr(2, 9),
        name: (name || 'Etiqueta').trim() || 'Etiqueta',
        kind: 'priceGroup-v1',
        group: serializePriceGroupForTemplate(pg),
        createdAt: now,
        updatedAt: now
    };
    tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
    labelTemplates.value = [...labelTemplates.value, tpl];
    saveCurrentState();
    const saved = await upsertLabelTemplateToDb(tpl);
    if (!saved) {
        console.warn('[labelTemplates] Modelo criado localmente, mas não foi persistido no banco');
    }
}

async function createDefaultLabelTemplate(name: string) {
    if (!fabric) return;
    const now = new Date().toISOString();
    try {
        const pg = buildDefaultPriceGroupForCard('22,99', 320, 450, 0);
        // Make sure nested editing works if inserted later.
        pg.set({ name: 'priceGroup', subTargetCheck: true, interactive: true });
        if (typeof pg.getObjects === 'function') {
            pg.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
        }

        const tpl: LabelTemplate = {
            id: Math.random().toString(36).substr(2, 9),
            name: (name || 'Etiqueta Padrao').trim() || 'Etiqueta Padrao',
            kind: 'priceGroup-v1',
            group: serializePriceGroupForTemplate(pg),
            createdAt: now,
            updatedAt: now
        };
        tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
        labelTemplates.value = [...labelTemplates.value, tpl];
        saveCurrentState();
        const saved = await upsertLabelTemplateToDb(tpl);
        if (!saved) {
            console.warn('[labelTemplates] Modelo padrão criado localmente, mas não foi persistido no banco');
        }
    } catch (err) {
        console.warn('[labelTemplates] Failed to create default template', err);
    }
}

async function ensureBuiltInDefaultLabelTemplate() {
    // Seed a "Padrão" template so it appears in the list and can be edited/duplicated.
    if (!fabric) return;
    const exists = (labelTemplates.value || []).some(t => t.id === BUILTIN_DEFAULT_LABEL_TEMPLATE_ID);
    if (exists) return;

    const now = new Date().toISOString();
    const pg = buildDefaultPriceGroupForCard('22,99', 320, 450, 0);
    pg.set({ name: 'priceGroup', subTargetCheck: true, interactive: true });
    if (typeof pg.getObjects === 'function') {
        pg.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
    }

    const tpl: LabelTemplate = {
        id: BUILTIN_DEFAULT_LABEL_TEMPLATE_ID,
        name: 'Padrão',
        kind: 'priceGroup-v1',
        group: serializePriceGroupForTemplate(pg),
        isBuiltIn: true,
        createdAt: now,
        updatedAt: now
    };
    tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
    labelTemplates.value = [tpl, ...(labelTemplates.value || [])];
    saveCurrentState();
}

async function ensureBuiltInAtacarejoLabelTemplate() {
    // Seed an "Atacarejo" 2-tier template (regular + wholesale) for CSV/Excel-like price tables.
    if (!fabric) return;
    const existingIdx = (labelTemplates.value || []).findIndex(t => t.id === BUILTIN_ATACAREJO_LABEL_TEMPLATE_ID);
    const existingTpl = existingIdx >= 0 ? (labelTemplates.value || [])[existingIdx] : null;
    const existingGroup: any = existingTpl ? (existingTpl as any).group : null;
    const existingHasAtac = isAtacarejoTemplateGroupJson(existingGroup);
    const existingVariantGroups = existingGroup && typeof existingGroup === 'object' ? (existingGroup as any).__atacVariantGroups : null;
    // Upgrade only when missing Atacarejo structure (we no longer use per-variant snapshots).
    const existingSeed = Number((existingTpl as any)?.__seedVersionAtacarejo ?? 0);
    if (existingTpl && existingHasAtac && existingSeed >= BUILTIN_ATACAREJO_SEED_VERSION) return;

    const now = new Date().toISOString();
    const common = {
        wholesaleTrigger: 10,
        wholesaleTriggerUnit: 'FD',
        packQuantity: 12,
        packUnit: 'UN',
        packageLabel: 'FD'
    };
    const buildVariant = (prices: { price: string; priceWholesale?: string }) => {
        const pg = buildAtacarejoPriceGroupForCard({ ...common, ...prices }, 320, 450, 0);
        // Templates should preserve this authored geometry.
        (pg as any).__preserveManualLayout = true;
        (pg as any).__forceAtacarejoCanonical = false;
        return pg;
    };

    // Base template uses the "tiny" look (matches the reference screenshot).
    const pg = buildVariant({ price: '1,95', priceWholesale: '1,92' });
    pg.set({ name: 'priceGroup', subTargetCheck: true, interactive: true });
    if (typeof pg.getObjects === 'function') {
        pg.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
    }

    const baseJson: any = serializePriceGroupForTemplate(pg);
    // Built-in: fixed style, fully runtime-driven fitting.
    baseJson.__preserveManualLayout = false;
    baseJson.__forceAtacarejoCanonical = true;
    // No variations: keep a single fixed layout, values are fit dynamically at runtime.
    delete baseJson.__atacVariantGroups;

    const tpl: LabelTemplate = {
        id: BUILTIN_ATACAREJO_LABEL_TEMPLATE_ID,
        name: 'Atacarejo (2 precos)',
        kind: 'priceGroup-v1',
        group: baseJson,
        isBuiltIn: true,
        createdAt: now,
        updatedAt: now
    };
    (tpl as any).__seedVersionAtacarejo = BUILTIN_ATACAREJO_SEED_VERSION;
    tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
    if (existingIdx >= 0) {
        const list = [...(labelTemplates.value || [])];
        list[existingIdx] = tpl;
        labelTemplates.value = list;
    } else {
        labelTemplates.value = [tpl, ...(labelTemplates.value || [])];
    }
    saveCurrentState();
}

async function ensureBuiltInBlackYellowLabelTemplate() {
    // Seed a "Preto/Amarelo" template similar to the reference (black pill + yellow text).
    if (!fabric) return;
    const exists = (labelTemplates.value || []).some(t => t.id === BUILTIN_BLACK_YELLOW_LABEL_TEMPLATE_ID);
    if (exists) return;

    const now = new Date().toISOString();
    const pg = buildBlackYellowPriceGroupForCard('26,99', 320, 450, 0);
    pg.set({ name: 'priceGroup', subTargetCheck: true, interactive: true });
    if (typeof pg.getObjects === 'function') {
        pg.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
    }

    const tpl: LabelTemplate = {
        id: BUILTIN_BLACK_YELLOW_LABEL_TEMPLATE_ID,
        name: 'Preto/Amarelo',
        kind: 'priceGroup-v1',
        group: serializePriceGroupForTemplate(pg),
        isBuiltIn: true,
        createdAt: now,
        updatedAt: now
    };
    tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
    labelTemplates.value = [tpl, ...(labelTemplates.value || [])];
    saveCurrentState();
}

async function ensureBuiltInOfertaAmarelaLabelTemplate() {
    // Seed a "Oferta (amarela)" template inspired by common market tags (yellow bg + red border + top strip).
    // Dynamic fitting for values like 1,99 / 12,99 / 124,99 is handled by setPriceOnPriceGroup().
    if (!fabric) return;
    const exists = (labelTemplates.value || []).some(t => t.id === BUILTIN_OFER_AMARELA_LABEL_TEMPLATE_ID);
    if (exists) return;

    const now = new Date().toISOString();
    const pg = buildOfertaAmarelaPriceGroupForCard('12,99', 320, 450, 0, 'UN');
    pg.set({ name: 'priceGroup', subTargetCheck: true, interactive: true });
    if (typeof pg.getObjects === 'function') {
        pg.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
    }

    const tpl: LabelTemplate = {
        id: BUILTIN_OFER_AMARELA_LABEL_TEMPLATE_ID,
        name: 'Oferta (amarela)',
        kind: 'priceGroup-v1',
        group: serializePriceGroupForTemplate(pg),
        isBuiltIn: true,
        createdAt: now,
        updatedAt: now
    };
    tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
    labelTemplates.value = [tpl, ...(labelTemplates.value || [])];
    saveCurrentState();
}

async function ensureBuiltInRedBurstLabelTemplate() {
    // Seed a red "burst" premium template inspired by market spotlight labels.
    if (!fabric) return;
    const exists = (labelTemplates.value || []).some(t => t.id === BUILTIN_RED_BURST_LABEL_TEMPLATE_ID);
    if (exists) return;

    const now = new Date().toISOString();
    const pg = buildRedBurstPriceGroupForCard('39,99', 320, 450, 0, 'KG');
    pg.set({ name: 'priceGroup', subTargetCheck: true, interactive: true });
    if (typeof pg.getObjects === 'function') {
        pg.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
    }

    const tpl: LabelTemplate = {
        id: BUILTIN_RED_BURST_LABEL_TEMPLATE_ID,
        name: 'Vermelho Explosao',
        kind: 'priceGroup-v1',
        group: serializePriceGroupForTemplate(pg),
        isBuiltIn: true,
        createdAt: now,
        updatedAt: now
    };
    tpl.previewDataUrl = await renderLabelTemplatePreview(tpl);
    labelTemplates.value = [tpl, ...(labelTemplates.value || [])];
    saveCurrentState();
}

async function updateLabelTemplateFromSelection(templateId: string) {
    if (!canvas.value) return;
    const pg = getPriceGroupFromAny(canvas.value.getActiveObject());
    if (!pg) return;

    const idx = labelTemplates.value.findIndex(t => t.id === templateId);
    if (idx === -1) return;

    const prev = labelTemplates.value[idx]!;
    const next: LabelTemplate = {
        ...prev,
        group: serializePriceGroupForTemplate(pg),
        updatedAt: new Date().toISOString()
    };
    (next as any).__fromDb = false;
    (next as any).__localOverride = true;
    next.previewDataUrl = await renderLabelTemplatePreview(next);
    const copy = [...labelTemplates.value];
    copy[idx] = next;
    labelTemplates.value = copy;
    syncLabelTemplatesIntoProjectPages('user');
    saveCurrentState();
    const saved = await upsertLabelTemplateToDb(next);
    if (!saved) {
        console.warn('[labelTemplates] Atualização salva localmente, mas não foi persistida no banco');
    }
}

function deleteLabelTemplateById(templateId: string) {
    const t = labelTemplates.value.find(x => x.id === templateId);
    if (t?.isBuiltIn) return;
    labelTemplates.value = (labelTemplates.value || []).filter(x => x.id !== templateId);
    syncLabelTemplatesIntoProjectPages('user');
    saveCurrentState();
    void deleteLabelTemplateFromDb(templateId);
}

async function duplicateLabelTemplateById(templateId: string) {
    const src = labelTemplates.value.find(t => t.id === templateId);
    if (!src) return;
    const now = new Date().toISOString();
    const copy: LabelTemplate = {
        ...src,
        id: Math.random().toString(36).substr(2, 9),
        name: `${src.name} (Copia)`,
        createdAt: now,
        updatedAt: now
    };
    (copy as any).__fromDb = false;
    (copy as any).__localOverride = true;
    if (!copy.previewDataUrl) copy.previewDataUrl = await renderLabelTemplatePreview(copy);
    labelTemplates.value = [...labelTemplates.value, copy];
    syncLabelTemplatesIntoProjectPages('user');
    saveCurrentState();
    const saved = await upsertLabelTemplateToDb(copy);
    if (!saved) {
        console.warn('[labelTemplates] Cópia criada localmente, mas não foi persistida no banco');
    }
}

async function applyLabelTemplateToCard(card: any, templateId: string) {
    if (!card || card.type !== 'group' || typeof card.getObjects !== 'function') return;
    let tpl = labelTemplates.value.find(t => t.id === templateId);
    if (!tpl) {
        // Fallback for reload/race conditions: use the immutable snapshot already
        // stored on the zone so cards always follow the Mini Editor template.
        const zoneId = String((card as any)?.parentZoneId || '').trim();
        const zone = zoneId && canvas.value
            ? canvas.value.getObjects().find((o: any) => isLikelyProductZone(o) && String((o as any)?._customId || '').trim() === zoneId)
            : null;
        const snapshotGroup = zone ? (zone as any)?._zoneTemplateSnapshot : null;
        if (snapshotGroup && typeof snapshotGroup === 'object') {
            tpl = {
                id: String(templateId || (zone as any)?._zoneTemplateSnapshotId || 'zone-template-snapshot'),
                name: 'Zone Template Snapshot',
                kind: 'priceGroup-v1',
                group: snapshotGroup
            } as any as LabelTemplate;
        }
    }
    if (!tpl) return;

    const objs = card.getObjects();
    const oldPg = objs.find((o: any) => o && o.type === 'group' && o.name === 'priceGroup');
    if (!oldPg) return;

    const oldParts = typeof oldPg.getObjects === 'function' ? oldPg.getObjects() : [];
    const oldPrice = oldParts.find((o: any) => o.name === 'smart_price' || o.name === 'price_value_text');
    const oldInt = oldParts.find((o: any) => o.name === 'price_integer_text');
    const oldDec = oldParts.find((o: any) => o.name === 'price_decimal_text');
    const oldUnit = oldParts.find((o: any) => o.name === 'price_unit_text');
    const oldCurrency = oldParts.find((o: any) => o.name === 'price_currency_text');
    const isVisibleNode = (obj: any): boolean => {
        if (!obj) return false;
        if (obj.visible === false) return false;
        const sx = Number(obj.scaleX ?? 1);
        const sy = Number(obj.scaleY ?? 1);
        if (!Number.isFinite(sx) || !Number.isFinite(sy)) return true;
        return sx !== 0 && sy !== 0;
    };
    const shouldReadSplitPrice = !!(
        oldInt && oldDec && (
            isVisibleNode(oldCurrency) ||
            !oldPrice ||
            !isVisibleNode(oldPrice)
        )
    );
    const oldPriceText = shouldReadSplitPrice
        ? `${oldInt.text || '0'}${oldDec.text || ',00'}`
        : oldPrice?.text;
    const oldCurrencyText = oldCurrency?.text;
    const oldUnitText = oldUnit?.text;
    const inferredUnit = (typeof oldUnitText === 'string' && oldUnitText.trim().length)
        ? normalizeUnitForLabel(oldUnitText)
        : inferUnitFromCard(card);

    let newPg: any = null;
    try {
        newPg = await instantiatePriceGroupFromTemplate(tpl, {
            atacVariantKey: resolveAtacVariantKeyFromPrice(oldPriceText)
        });
    } catch (err) {
        console.warn('[labelTemplates] Template inválido ao aplicar no card, fallback para padrão', err);
        await resetCardPriceGroupToDefault(card);
        return;
    }
    const preserveManualTemplateLayout = shouldPreserveManualTemplateVisual(newPg);
    if (typeof oldPriceText === 'string') setPriceOnPriceGroup(newPg, oldPriceText, typeof inferredUnit === 'string' ? inferredUnit : undefined);
    if (typeof oldCurrencyText === 'string') {
        const c = newPg.getObjects?.().find((o: any) => o.name === 'price_currency_text');
        if (c && typeof c.set === 'function') c.set('text', oldCurrencyText);
    }
    const isRedBurst = isRedBurstPriceGroup(newPg) || String(templateId || '') === BUILTIN_RED_BURST_LABEL_TEMPLATE_ID;
    const headerParts = inferHeaderPartsForPriceTemplate(card, 'OFERTA', {
        preferFullNameWithWeight: isRedBurst,
        splitUnitIntoDedicatedField: !isRedBurst
    });
    const headerTextObj = newPg.getObjects?.().find((o: any) => o.name === 'price_header_text');
    if (headerTextObj && isTextLikeObject(headerTextObj)) {
        const defaultHeader = String(headerTextObj.text || '').trim() || 'OFERTA';
        headerTextObj.set('text', headerParts.title || defaultHeader);
        if (typeof headerTextObj.initDimensions === 'function') headerTextObj.initDimensions();
    }
    const headerUnitObj = newPg.getObjects?.().find((o: any) => o.name === 'price_header_unit_text');
    if (headerUnitObj && isTextLikeObject(headerUnitObj)) {
        headerUnitObj.set('text', isRedBurst ? '' : (headerParts.unit || ''));
        headerUnitObj.set('visible', !isRedBurst && !!headerParts.unit);
        if (typeof headerUnitObj.initDimensions === 'function') headerUnitObj.initDimensions();
    }
    if (isRedBurst) tuneRedBurstPriceGroupLayout(newPg);
    // Apply wholesale/pack metadata when the template supports it (no-op otherwise).
    applyAtacarejoPricingToPriceGroup(newPg, {
        price: typeof oldPriceText === 'string' ? oldPriceText : null,
        priceWholesale: (card as any).priceWholesale ?? null,
        wholesaleTrigger: (card as any).wholesaleTrigger ?? null,
        wholesaleTriggerUnit: (card as any).wholesaleTriggerUnit ?? null,
        packQuantity: (card as any).packQuantity ?? null,
        packUnit: (card as any).packUnit ?? null,
        packageLabel: (card as any).packageLabel ?? null,
        weight: typeof inferredUnit === 'string' ? inferredUnit : null
    });

    const desiredLeft = oldPg.left ?? 0;
    const desiredTop = oldPg.top ?? 0;
    newPg.set({
        left: desiredLeft,
        top: desiredTop,
        originX: oldPg.originX ?? 'center',
        originY: oldPg.originY ?? 'center',
        angle: oldPg.angle ?? 0,
        scaleX: 1,
        scaleY: 1,
        name: 'priceGroup',
        subTargetCheck: true,
        interactive: true
    });
    if (typeof newPg.getObjects === 'function') {
        newPg.getObjects().forEach((child: any) => {
            const isBgImage = child?.name === 'price_bg_image' || child?.name === 'splash_image';
            child.set({
                selectable: !isBgImage,
                evented: !isBgImage,
                hasControls: !isBgImage,
                hasBorders: !isBgImage
            });
        });
    }

    card.remove(oldPg);
    safeAddWithUpdate(card, newPg);

    const cardW = card._cardWidth ?? card.width ?? card.getScaledWidth?.() ?? 0;
    const cardH = card._cardHeight ?? card.height ?? card.getScaledHeight?.() ?? 0;
    if (cardW && cardH) {
        const layout = layoutPriceGroup(newPg, cardW, cardH);
        if (preserveManualTemplateLayout) {
            // layoutManualTemplateGroup normalizes local origin to (0,0); keep authored card anchor.
            newPg.set({ left: desiredLeft, top: desiredTop });
        } else {
            const marginBottom = cardH * 0.05;
            const halfH = cardH / 2;
            const hForAnchor = layout?.pillH ?? (newPg.getScaledHeight?.() ?? newPg.height ?? (cardH * 0.18));
            newPg.set({ top: halfH - (hForAnchor / 2) - marginBottom });
        }
    }

    const titleObj = getCardTitleText(card);
    if (titleObj && typeof titleObj.set === 'function') {
        titleObj.set({
            visible: !isRedBurst,
            selectable: !isRedBurst,
            evented: !isRedBurst
        });
        if (typeof titleObj.initDimensions === 'function') titleObj.initDimensions();
    }

    // Freeze card dimensions (do NOT call safeAddWithUpdate which expands bounds)
    if (cardW && cardH) card.set({ width: cardW, height: cardH });
    card.dirty = true;
    card.setCoords();
}

function buildDefaultPriceGroupForCard(priceStr: string, cardW: number, cardH: number, top: number, unitText?: string) {
    const pillH = cardH * 0.18;
    const pillW = Math.min(cardW * 0.6, cardW - 10);
    const priceBg = new fabric.Rect({
        width: pillW,
        height: pillH,
        rx: pillH / 2,
        ry: pillH / 2,
        fill: '#000000',
        stroke: '#ff0000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_bg',
        shadow: new fabric.Shadow({ color: '#ff0000', blur: 12, offsetX: 0, offsetY: 0 })
    });

    const circleSize = pillH * 0.72;
    const circleCenterX = -(pillW / 2) + (circleSize * 0.35);
    const currencyCircle = new fabric.Circle({
        radius: circleSize / 2,
        fill: '#FFFF00',
        originX: 'center',
        originY: 'center',
        left: circleCenterX,
        top: 0,
        name: 'price_currency_bg'
    });

    const currencyText = new fabric.Text('R$', {
        fontSize: circleSize * 0.32,
        fontFamily: 'Inter',
        fontWeight: 'bold',
        fill: '#000000',
        originX: 'center',
        originY: 'center',
        left: circleCenterX,
        top: 0,
        name: 'price_currency_text'
    });

    const parts = splitPriceParts(priceStr);
    const integer = parts.integer;
    const dec = parts.dec;

    const priceInteger = new fabric.IText(integer, {
        fontSize: pillH * 0.72,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#ffffff',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_integer_text',
        __fontScale: 0.72,
        __yOffsetRatio: 0
    });

    const priceDecimal = new fabric.IText(`,${dec}`, {
        fontSize: pillH * 0.42,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#ffffff',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_decimal_text',
        __fontScale: 0.42,
        __yOffsetRatio: -0.18
    });

    const u = normalizeUnitForLabel(unitText);
    const priceUnit = new fabric.IText(u, {
        fontSize: pillH * 0.26,
        fontFamily: 'Inter',
        fontWeight: '800',
        fill: '#ffffff',
        originX: 'right',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_unit_text',
        __fontScale: 0.26,
        __yOffsetRatio: 0.22,
        visible: !!u
    });

    const pg = new fabric.Group([priceBg, currencyCircle, currencyText, priceInteger, priceDecimal, priceUnit], {
        originX: 'center',
        originY: 'center',
        left: 0,
        top,
        name: 'priceGroup'
    });
    layoutPriceGroup(pg, cardW, cardH);
    return pg;
}

function buildBlackYellowPriceGroupForCard(priceStr: string, cardW: number, cardH: number, top: number, unitText?: string) {
    const pillH = cardH * 0.18;
    const pillW = Math.min(cardW * 0.6, cardW - 10);
    const yellow = '#FDE047'; // close to the reference

    const priceBg = new fabric.Rect({
        width: pillW,
        height: pillH,
        rx: pillH / 2,
        ry: pillH / 2,
        fill: '#000000',
        stroke: 'rgba(0,0,0,0)', // prevent red glow fallback in layoutPriceGroup
        strokeWidth: 0,
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_bg',
        // layoutPriceGroup reads these:
        __roundness: 1,
        __strokeWidth: 0
    });

    // Keep a (hidden-in-plain-sight) circle so layoutPriceGroup can position "R$" consistently.
    const circleSize = pillH * 0.72;
    const circleCenterX = -(pillW / 2) + (circleSize * 0.35);
    const currencyCircle = new fabric.Circle({
        radius: circleSize / 2,
        fill: '#000000',
        originX: 'center',
        originY: 'center',
        left: circleCenterX,
        top: 0,
        name: 'price_currency_bg'
    });

    const currencyText = new fabric.Text('R$', {
        fontSize: circleSize * 0.30,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: yellow,
        originX: 'center',
        originY: 'center',
        left: circleCenterX,
        top: 0,
        name: 'price_currency_text'
    });

    const parts = splitPriceParts(priceStr);
    const integer = parts.integer;
    const dec = parts.dec;

    const priceInteger = new fabric.IText(integer, {
        fontSize: pillH * 0.86,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: yellow,
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_integer_text',
        __fontScale: 0.86,
        __yOffsetRatio: 0
    });

    const priceDecimal = new fabric.IText(`,${dec}`, {
        fontSize: pillH * 0.55,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: yellow,
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_decimal_text',
        __fontScale: 0.55,
        __yOffsetRatio: -0.30
    });

    // This template matches the reference (no KG/UN shown). Users can enable it via the mini editor if needed.
    const priceUnit = new fabric.IText('', {
        fontSize: pillH * 0.26,
        fontFamily: 'Inter',
        fontWeight: '800',
        fill: yellow,
        originX: 'right',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_unit_text',
        __fontScale: 0.26,
        __yOffsetRatio: 0.22,
        visible: false
    });

    const pg = new fabric.Group([priceBg, currencyCircle, currencyText, priceInteger, priceDecimal, priceUnit], {
        originX: 'center',
        originY: 'center',
        left: 0,
        top,
        name: 'priceGroup'
    });
    layoutPriceGroup(pg, cardW, cardH);
    return pg;
}

function buildOfertaAmarelaPriceGroupForCard(priceStr: string, _cardW: number, _cardH: number, top: number, unitText?: string) {
    // Base geometry for the built-in template; runtime uses layoutManualTemplateGroup (uniform scale)
    // and setPriceOnPriceGroup() (dynamic text fitting).
    const labelW = 300;
    const labelH = 140;
    const corner = 18;

    const priceBg = new fabric.Rect({
        width: labelW,
        height: labelH,
        rx: corner,
        ry: corner,
        fill: '#FDE047',
        stroke: '#B91C1C',
        strokeWidth: 10,
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_bg',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.22)', blur: 10, offsetX: 0, offsetY: 6 }),
        __roundness: (corner * 2) / labelH,
        __strokeWidth: 10
    });

    const headerW = labelW * 0.86;
    const headerH = labelH * 0.26;
    const headerY = -(labelH / 2) + (headerH / 2) + 12;

    const offerHeaderBg = new fabric.Rect({
        width: headerW,
        height: headerH,
        rx: headerH * 0.28,
        ry: headerH * 0.28,
        fill: '#DC2626',
        stroke: '#7F1D1D',
        strokeWidth: Math.max(2, headerH * 0.10),
        originX: 'center',
        originY: 'center',
        left: 0,
        top: headerY,
        selectable: false,
        evented: false,
        name: 'offer_header_bg'
    });

    const offerHeaderText = new fabric.Text('OFERTA!', {
        fontSize: Math.max(18, headerH * 0.62),
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#FDE047',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: headerY + 1,
        selectable: true,
        evented: true,
        name: 'offer_header_text',
        charSpacing: 120,
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.18)', blur: 2, offsetX: 0, offsetY: 2 })
    });

    const parts = splitPriceParts(priceStr);
    const integer = parts.integer;
    const dec = parts.dec;

    const priceAreaCenterY = 18;

    const currencyText = new fabric.Text('R$', {
        fontSize: 32,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#B91C1C',
        originX: 'left',
        originY: 'center',
        left: -110,
        top: priceAreaCenterY + 4,
        name: 'price_currency_text',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.12)', blur: 2, offsetX: 0, offsetY: 2 })
    });

    const priceInteger = new fabric.IText(integer, {
        fontSize: 86,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#B91C1C',
        originX: 'left',
        originY: 'center',
        left: -70,
        top: priceAreaCenterY + 8,
        name: 'price_integer_text',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.10)', blur: 2, offsetX: 0, offsetY: 2 })
    });

    const priceDecimal = new fabric.IText(`,${dec}`, {
        fontSize: 46,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#B91C1C',
        originX: 'left',
        originY: 'center',
        left: 40,
        top: priceAreaCenterY - 10,
        name: 'price_decimal_text',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.10)', blur: 2, offsetX: 0, offsetY: 2 })
    });

    const u = normalizeUnitForLabel(unitText);
    const priceUnit = new fabric.IText(u || '', {
        fontSize: 20,
        fontFamily: 'Inter',
        fontWeight: '800',
        fill: '#B91C1C',
        originX: 'left',
        originY: 'center',
        left: 40,
        top: priceAreaCenterY + 34,
        name: 'price_unit_text',
        visible: false
    });

    const pg = new fabric.Group([
        priceBg,
        offerHeaderBg,
        offerHeaderText,
        currencyText,
        priceInteger,
        priceDecimal,
        priceUnit
    ], {
        originX: 'center',
        originY: 'center',
        left: 0,
        top,
        name: 'priceGroup'
    });

    // Mark as manual template so runtime preserves geometry and only fits values.
    (pg as any).__preserveManualLayout = true;
    (pg as any).__isCustomTemplate = true;
    safeAddWithUpdate(pg);
    return pg;
}

function buildRedBurstPriceGroupForCard(priceStr: string, cardW: number, cardH: number, top: number, unitText?: string) {
    const labelW = Math.min(cardW * 0.97, 352);
    const labelH = Math.min(cardH * 0.47, 206);
    const corner = Math.max(14, labelH * 0.12);

    const fillRed =
        fabric?.Gradient
            ? new fabric.Gradient({
                type: 'linear',
                coords: { x1: 0, y1: 0, x2: labelW, y2: labelH },
                colorStops: [
                    { offset: 0, color: '#7c0301' },
                    { offset: 0.26, color: '#c80a06' },
                    { offset: 0.58, color: '#f24612' },
                    { offset: 0.82, color: '#c40a07' },
                    { offset: 1, color: '#7e0201' }
                ]
            })
            : '#c40c08';

    const outerGlow = new fabric.Rect({
        width: labelW + 10,
        height: labelH + 10,
        rx: corner + 5,
        ry: corner + 5,
        fill: 'rgba(255,150,30,0.2)',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        selectable: false,
        evented: false,
        name: 'price_burst_outer_glow'
    });

    const priceBg = new fabric.Rect({
        width: labelW,
        height: labelH,
        rx: corner,
        ry: corner,
        fill: fillRed as any,
        stroke: '#ffd24d',
        strokeWidth: Math.max(2, labelH * 0.015),
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'price_bg',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.3)', blur: 13, offsetX: 0, offsetY: 8 }),
        __roundness: (corner * 2) / labelH
    });

    const innerBorder = new fabric.Rect({
        width: labelW * 0.97,
        height: labelH * 0.95,
        rx: Math.max(10, corner * 0.84),
        ry: Math.max(10, corner * 0.84),
        fill: 'transparent',
        stroke: 'rgba(255,255,255,0.26)',
        strokeWidth: Math.max(1, labelH * 0.008),
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        selectable: false,
        evented: false,
        name: 'price_inner_border'
    });

    const burstA = new fabric.Line(
        [-labelW * 0.49, labelH * 0.28, labelW * 0.14, -labelH * 0.12],
        {
            stroke: 'rgba(255,230,130,0.24)',
            strokeWidth: Math.max(2, labelH * 0.018),
            selectable: false,
            evented: false,
            name: 'price_burst_line_a'
        }
    );
    const burstB = new fabric.Line(
        [-labelW * 0.18, labelH * 0.35, labelW * 0.48, labelH * 0.02],
        {
            stroke: 'rgba(255,118,38,0.4)',
            strokeWidth: Math.max(2, labelH * 0.022),
            selectable: false,
            evented: false,
            name: 'price_burst_line_b'
        }
    );
    const burstC = new fabric.Circle({
        radius: Math.max(10, labelH * 0.1),
        fill: 'rgba(255,245,200,0.24)',
        originX: 'center',
        originY: 'center',
        left: labelW * 0.32,
        top: -labelH * 0.24,
        selectable: false,
        evented: false,
        name: 'price_burst_glow'
    });

    const centerGlow = new fabric.Ellipse({
        rx: labelW * 0.32,
        ry: labelH * 0.19,
        fill: 'rgba(255,170,70,0.12)',
        originX: 'center',
        originY: 'center',
        left: -labelW * 0.03,
        top: labelH * 0.08,
        selectable: false,
        evented: false,
        name: 'price_center_glow'
    });

    const headerW = labelW * 0.92;
    const headerH = labelH * 0.27;
    const headerY = -(labelH / 2) + headerH * 0.72;

    const headerBg = new fabric.Rect({
        width: headerW,
        height: headerH,
        rx: headerH * 0.22,
        ry: headerH * 0.22,
        fill: fabric?.Gradient
            ? new fabric.Gradient({
                type: 'linear',
                coords: { x1: 0, y1: 0, x2: headerW, y2: 0 },
                colorStops: [
                    { offset: 0, color: '#8d0200' },
                    { offset: 0.52, color: '#d61009' },
                    { offset: 1, color: '#870100' }
                ]
            })
            : '#a10703',
        stroke: '#f5cb45',
        strokeWidth: Math.max(1, headerH * 0.052),
        originX: 'center',
        originY: 'center',
        left: 0,
        top: headerY,
        name: 'price_header_bg',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.28)', blur: 8, offsetX: 0, offsetY: 4 })
    });

    const headerHighlight = new fabric.Rect({
        width: headerW * 0.93,
        height: Math.max(4, headerH * 0.2),
        rx: headerH * 0.09,
        ry: headerH * 0.09,
        fill: 'rgba(255,240,208,0.46)',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: headerY - (headerH * 0.3),
        selectable: false,
        evented: false,
        name: 'price_header_highlight'
    });

    const headerUnit = normalizeUnitForLabel(unitText);
    const hasHeaderUnit = headerUnit === 'KG' || headerUnit === 'UN';
    const headerText = new fabric.Textbox('FRALDINHA', {
        width: headerW * (hasHeaderUnit ? 0.76 : 0.86),
        fontSize: Math.max(18, headerH * 0.58),
        fontFamily: 'Inter',
        fontWeight: '900',
        textAlign: 'center',
        fill: '#ffd94c',
        originX: 'center',
        originY: 'center',
        left: hasHeaderUnit ? -headerW * 0.055 : 0,
        top: headerY + (headerH * 0.01),
        name: 'price_header_text',
        charSpacing: 20,
        shadow: new fabric.Shadow({ color: 'rgba(44,0,0,0.62)', blur: 2, offsetX: 0, offsetY: 2 })
    });

    const headerUnitText = new fabric.Text(headerUnit || 'KG', {
        fontSize: Math.max(16, headerH * 0.5),
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#ffffff',
        originX: 'center',
        originY: 'center',
        left: headerW * 0.33,
        top: headerY + (headerH * 0.02),
        name: 'price_header_unit_text',
        visible: hasHeaderUnit,
        shadow: new fabric.Shadow({ color: 'rgba(34,0,0,0.6)', blur: 2, offsetX: 0, offsetY: 2 })
    });

    const parts = splitPriceParts(priceStr);
    const integer = parts.integer;
    const dec = parts.dec;

    const priceBaselineY = labelH * 0.2;
    const currencyX = -(labelW / 2) + (labelW * 0.11);

    const currencyText = new fabric.Text('R$', {
        fontSize: Math.max(22, labelH * 0.21),
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#ffffff',
        originX: 'center',
        originY: 'center',
        left: currencyX,
        top: priceBaselineY + (labelH * 0.015),
        name: 'price_currency_text',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.38)', blur: 3, offsetX: 0, offsetY: 2 })
    });

    const integerX = -labelW * 0.02;
    const priceInteger = new fabric.IText(integer, {
        fontSize: Math.max(64, labelH * 0.82),
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#ffffff',
        stroke: '#a5a5a5',
        strokeWidth: Math.max(1, labelH * 0.008),
        originX: 'center',
        originY: 'center',
        left: integerX,
        top: priceBaselineY + (labelH * 0.01),
        name: 'price_integer_text',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.35)', blur: 5, offsetX: 0, offsetY: 3 })
    });

    const priceDecimal = new fabric.IText(`,${dec}`, {
        fontSize: Math.max(30, labelH * 0.46),
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#ffffff',
        stroke: '#b8b8b8',
        strokeWidth: Math.max(1, labelH * 0.006),
        originX: 'left',
        originY: 'center',
        left: integerX + (labelW * 0.145),
        top: priceBaselineY - (labelH * 0.145),
        name: 'price_decimal_text',
        shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.33)', blur: 4, offsetX: 0, offsetY: 2 })
    });

    // Unit is displayed on the top strip for this style.
    const priceUnit = new fabric.IText(headerUnit || '', {
        fontSize: Math.max(12, labelH * 0.16),
        fontFamily: 'Inter',
        fontWeight: '800',
        fill: '#ffe07a',
        originX: 'left',
        originY: 'center',
        left: integerX + (labelW * 0.15),
        top: priceBaselineY + (labelH * 0.18),
        name: 'price_unit_text',
        visible: false
    });

    const pg = new fabric.Group([
        outerGlow,
        priceBg,
        innerBorder,
        burstA,
        burstB,
        burstC,
        centerGlow,
        headerBg,
        headerHighlight,
        headerText,
        headerUnitText,
        currencyText,
        priceInteger,
        priceDecimal,
        priceUnit
    ], {
        originX: 'center',
        originY: 'center',
        left: 0,
        top,
        name: 'priceGroup'
    });

    // Preserve authored geometry and only apply uniform card fitting later.
    (pg as any).__preserveManualLayout = true;
    (pg as any).__isCustomTemplate = true;
    safeAddWithUpdate(pg);
    return pg;
}

function buildAtacarejoPriceGroupForCard(sample: any, cardW: number, cardH: number, top: number) {
    const retailBg = new fabric.Rect({
        width: 300,
        height: 60,
        rx: 10,
        ry: 10,
        fill: '#EF4444',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'atac_retail_bg'
    });

    const bannerBg = new fabric.Rect({
        width: 300,
        height: 18,
        rx: 8,
        ry: 8,
        fill: '#FFFFFF',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'atac_banner_bg'
    });

    const wholesaleBg = new fabric.Rect({
        width: 300,
        height: 60,
        rx: 10,
        ry: 10,
        fill: '#FDE047',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'atac_wholesale_bg'
    });

    const retailCurrency = new fabric.IText('R$', {
        fontSize: 14,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#FFFFFF',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'retail_currency_text',
        __fontScale: 0.22
    });

    const retailInteger = new fabric.IText('0', {
        fontSize: 40,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#FFFFFF',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'retail_integer_text',
        __fontScale: 0.60
    });

    const retailDecimal = new fabric.IText(',00', {
        fontSize: 24,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#FFFFFF',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'retail_decimal_text',
        __fontScale: 0.36
    });

    const retailUnit = new fabric.IText('UN', {
        fontSize: 14,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#FFFFFF',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'retail_unit_text',
        __fontScale: 0.22
    });

    const retailPack = new fabric.IText('', {
        fontSize: 12,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#FFFFFF',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'retail_pack_line_text',
        __fontScale: 0.18,
        visible: false
    });

    const bannerText = new fabric.IText('ACIMA 10 FD', {
        fontSize: 12,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#000000',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'wholesale_banner_text',
        __fontScale: 0.32
    });

    const wholesaleCurrency = new fabric.IText('R$', {
        fontSize: 14,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#000000',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'wholesale_currency_text',
        __fontScale: 0.22
    });

    const wholesaleInteger = new fabric.IText('0', {
        fontSize: 40,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#000000',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'wholesale_integer_text',
        __fontScale: 0.60
    });

    const wholesaleDecimal = new fabric.IText(',00', {
        fontSize: 24,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#000000',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'wholesale_decimal_text',
        __fontScale: 0.36
    });

    const wholesaleUnit = new fabric.IText('UN', {
        fontSize: 14,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#000000',
        originX: 'left',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'wholesale_unit_text',
        __fontScale: 0.22
    });

    const wholesalePack = new fabric.IText('', {
        fontSize: 12,
        fontFamily: 'Inter',
        fontWeight: '900',
        fill: '#000000',
        originX: 'center',
        originY: 'center',
        left: 0,
        top: 0,
        name: 'wholesale_pack_line_text',
        __fontScale: 0.18,
        visible: false
    });

    const pg = new fabric.Group([
        retailBg,
        bannerBg,
        wholesaleBg,
        retailCurrency,
        retailInteger,
        retailDecimal,
        retailUnit,
        retailPack,
        bannerText,
        wholesaleCurrency,
        wholesaleInteger,
        wholesaleDecimal,
        wholesaleUnit,
        wholesalePack
    ], {
        originX: 'center',
        originY: 'center',
        left: 0,
        top,
        name: 'priceGroup',
        __forceAtacarejoCanonical: true
    });

    applyAtacarejoPricingToPriceGroup(pg, sample);
    layoutPriceGroup(pg, cardW, cardH);
    return pg;
}

async function resetCardPriceGroupToDefault(card: any) {
    if (!fabric || !card || card.type !== 'group' || typeof card.getObjects !== 'function') return;
    const objs = card.getObjects();
    const oldPg = objs.find((o: any) => o && o.type === 'group' && o.name === 'priceGroup');
    if (!oldPg) return;

    const oldParts = typeof oldPg.getObjects === 'function' ? oldPg.getObjects() : [];
    const oldPrice = oldParts.find((o: any) => o.name === 'smart_price' || o.name === 'price_value_text');
    const oldInt = oldParts.find((o: any) => o.name === 'price_integer_text');
    const oldDec = oldParts.find((o: any) => o.name === 'price_decimal_text');
    const oldUnit = oldParts.find((o: any) => o.name === 'price_unit_text');
    const oldPriceText =
        (oldInt && oldDec)
            ? `${oldInt.text || '0'}${oldDec.text || ',00'}`
            : (typeof oldPrice?.text === 'string' ? oldPrice.text : '0,00');
    const oldUnitText = typeof oldUnit?.text === 'string' ? oldUnit.text : undefined;
    const inferredUnit = oldUnitText && oldUnitText.trim().length ? normalizeUnitForLabel(oldUnitText) : inferUnitFromCard(card);

    const cardW = card._cardWidth ?? card.width ?? card.getScaledWidth?.() ?? 0;
    const cardH = card._cardHeight ?? card.height ?? card.getScaledHeight?.() ?? 0;
    if (!cardW || !cardH) return;

    const newPg = buildDefaultPriceGroupForCard(oldPriceText, cardW, cardH, oldPg.top ?? 0, inferredUnit);
    newPg.set({
        left: oldPg.left ?? 0,
        originX: oldPg.originX ?? 'center',
        originY: oldPg.originY ?? 'center',
        angle: oldPg.angle ?? 0
    });

    card.remove(oldPg);
    safeAddWithUpdate(card, newPg);
    // Freeze card dimensions (do NOT call safeAddWithUpdate which expands bounds)
    if (cardW && cardH) card.set({ width: cardW, height: cardH });
    card.dirty = true;
    card.setCoords();
}

const cloneTemplateGroupJson = (group: any) => {
    if (!group || typeof group !== 'object') return null;
    try {
        return (typeof structuredClone === 'function')
            ? structuredClone(group)
            : JSON.parse(JSON.stringify(group));
    } catch {
        return null;
    }
};

async function applyLabelTemplateToZone(zone: any, templateId?: string, applyToExisting: boolean = false) {
    if (!canvas.value || !zone || !isLikelyProductZone(zone)) return;
    const id = templateId || undefined;
    const prev = getZoneGlobalStyles(zone);
    (zone as any)._zoneGlobalStyles = { ...prev, splashTemplateId: id };

    // Persist an immutable snapshot of the selected template group on the zone.
    // New cards should always use this exact JSON from mini editor to avoid stale/incorrect matches.
    if (id) {
        const tpl = labelTemplates.value.find((t: any) => String(t?.id || '') === String(id));
        const snapshot = cloneTemplateGroupJson((tpl as any)?.group);
        (zone as any)._zoneTemplateSnapshotId = id;
        (zone as any)._zoneTemplateSnapshot = snapshot || null;
    } else {
        (zone as any)._zoneTemplateSnapshotId = undefined;
        (zone as any)._zoneTemplateSnapshot = undefined;
    }

    // Only apply to existing cards if explicitly requested (e.g., user explicitly changes template)
    // If applyToExisting is false, just update the reference for new products
    if (applyToExisting) {
        const cards = getZoneChildren(zone);
        for (const card of cards) {
            if (id) await applyLabelTemplateToCard(card, id);
            else await resetCardPriceGroupToDefault(card);
        }

        // Also re-apply colors/text style if the zone has global styles.
        const styles = getZoneGlobalStyles(zone);
        applyGlobalStylesToCards(styles, zone);
    }

    canvas.value.requestRenderAll();
    saveCurrentState();
}

const applyTemplateToActiveZone = (templateId?: string) => {
    const zone = canvas.value?.getActiveObject?.();
    if (zone && isLikelyProductZone(zone)) {
        void applyLabelTemplateToZone(zone, templateId, true);
    }
}

async function setTemplateSplashImage(templateId: string, file: File) {
    if (!fabric) return;
    const idx = labelTemplates.value.findIndex(t => t.id === templateId);
    if (idx === -1) return;

    try {
        const uploaded = await uploadFile(file);
        if (!uploaded?.success || !uploaded?.url) return;

        const tpl = labelTemplates.value[idx]!;
        const g = await instantiatePriceGroupFromTemplate(tpl);

        const labelProxyUrl = toWasabiProxyUrl(uploaded.url) || uploaded.url;
        const img: any = await fabric.Image.fromURL(labelProxyUrl, { crossOrigin: 'anonymous' });
        img.set({
            name: 'price_bg_image',
            originX: 'center',
            originY: 'center',
            left: 0,
            top: 0,
            selectable: false,
            evented: false
        });

        const current = typeof g.getObjects === 'function' ? g.getObjects().slice() : [];
        current.forEach((o: any) => g.remove(o));
        safeAddWithUpdate(g, img);
        current.forEach((o: any) => safeAddWithUpdate(g, o));

        // Serialize back into the template
        const next: LabelTemplate = {
            ...tpl,
            group: serializePriceGroupForTemplate(g),
            updatedAt: new Date().toISOString()
        };
        (next as any).__fromDb = false;
        (next as any).__localOverride = true;
        next.previewDataUrl = await renderLabelTemplatePreview(next);

        const list = [...labelTemplates.value];
        list[idx] = next;
        labelTemplates.value = list;
        saveCurrentState();
        await upsertLabelTemplateToDb(next);
    } catch (err) {
        console.warn('[labelTemplates] Failed to set splash image', err);
    }
}

async function insertLabelTemplateToCanvas(templateId: string) {
    if (!canvas.value) return;
    const tpl = labelTemplates.value.find(t => t.id === templateId);
    if (!tpl) return;
    try {
        const g = await instantiatePriceGroupFromTemplate(tpl);
        const preserveTemplateVisual = shouldPreserveManualTemplateVisual(g);
        if (!preserveTemplateVisual) {
            layoutPriceGroup(g, 320, 220);
        }
        const center = getCenterOfView();
        g.set({
            left: center.x,
            top: center.y,
            originX: 'center',
            originY: 'center',
            selectable: true,
            evented: true,
            hasControls: true,
            hasBorders: true,
            excludeFromExport: true,
            name: 'priceGroup',
            subTargetCheck: true,
            interactive: true
        });
        if (typeof g.getObjects === 'function') {
            g.getObjects().forEach((child: any) => child.set({ selectable: true, evented: true, hasControls: true, hasBorders: true }));
        }
        (g as any)._customId = Math.random().toString(36).substr(2, 9);
        canvas.value.add(g);

        // Center using the actual rendered bounds. Some custom templates can have
        // an offset local origin, which makes `left/top = viewport center` appear off-screen.
        try {
            g.setCoords?.();
            const bounds = g.getBoundingRect?.(true);
            if (bounds && Number.isFinite(bounds.left) && Number.isFinite(bounds.top) && Number.isFinite(bounds.width) && Number.isFinite(bounds.height)) {
                const boundsCenterX = bounds.left + (bounds.width / 2);
                const boundsCenterY = bounds.top + (bounds.height / 2);
                const dx = center.x - boundsCenterX;
                const dy = center.y - boundsCenterY;
                if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {
                    g.set({
                        left: Number(g.left || 0) + dx,
                        top: Number(g.top || 0) + dy
                    });
                    g.setCoords?.();
                }
            }
        } catch (centerErr) {
            console.warn('[labelTemplates] Failed to recenter inserted template bounds', centerErr);
        }

        canvas.value.setActiveObject(g);
        canvas.value.requestRenderAll();
        saveCurrentState();
    } catch (err) {
        console.warn('[labelTemplates] Failed to insert template', err);
    }
}

function beginEditSelectedLabel() {
    if (!canvas.value) return;

    const active = canvas.value.getActiveObject();
    const card = getCardGroupFromAny(active);
    const pg = getPriceGroupFromAny(active);

    // Close modal so the user can interact with the canvas immediately.
    showLabelTemplatesModal.value = false;

    // Enable deep editing on the card so sub-targets can be selected.
    if (card && card.type === 'group') {
        card.set({ subTargetCheck: true, interactive: true });
        if (typeof card.getObjects === 'function') {
            card.getObjects().forEach((child: any) => {
                child.set({
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    hasBorders: true,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: false,
                    lockScalingY: false,
                    lockRotation: false
                });
                child.setCoords?.();
            });
        }
        card.setCoords?.();
        canvas.value.setActiveObject(card);
    }

    // Also enable editing inside the priceGroup directly (2nd level).
    if (pg && pg.type === 'group') {
        pg.set({ subTargetCheck: true, interactive: true });
        if (typeof pg.getObjects === 'function') {
            pg.getObjects().forEach((child: any) => {
                const isBgImage = child?.name === 'price_bg_image' || child?.name === 'splash_image';
                child.set({
                    selectable: !isBgImage,
                    evented: !isBgImage,
                    hasControls: !isBgImage,
                    hasBorders: !isBgImage,
                    lockMovementX: false,
                    lockMovementY: false,
                    lockScalingX: false,
                    lockScalingY: false,
                    lockRotation: false
                });
                child.setCoords?.();
            });
        }
        pg.setCoords?.();
    }

    canvas.value.requestRenderAll();
    triggerRef(selectedObjectRef);
}

async function handleUpdateTemplateFromMiniEditor(
    templateId: string,
    updates: { group: any; previewDataUrl?: string; name?: string },
    done?: (result: { ok: boolean; message?: string }) => void
) {
    try {
        const idx = labelTemplates.value.findIndex(t => t.id === templateId);
        if (idx === -1) {
            done?.({ ok: false, message: 'Modelo não encontrado para salvar.' });
            return;
        }

        const prev = labelTemplates.value[idx]!;
        const rawGroup: any = (updates.group ?? prev.group);
        let nextGroup: any = rawGroup;
        try {
            nextGroup = (typeof structuredClone === 'function')
                ? structuredClone(rawGroup)
                : JSON.parse(JSON.stringify(rawGroup));
        } catch {
            // Fallback to raw object if cloning is not possible.
            nextGroup = rawGroup;
        }

        if (nextGroup && typeof nextGroup === 'object') {
            delete nextGroup.layoutManager;
            delete nextGroup.layout;
            // Mini editor is explicit manual mode: preserve exact element layout on cards/reload.
            nextGroup.__preserveManualLayout = true;
            nextGroup.__isCustomTemplate = true;
            // Preserve explicit canonical flag (only if the template opted into it).
            if (nextGroup.__forceAtacarejoCanonical == null && prev?.group && (prev.group as any).__forceAtacarejoCanonical != null) {
                nextGroup.__forceAtacarejoCanonical = (prev.group as any).__forceAtacarejoCanonical;
            }
            const useVariantSnapshots = shouldUseAtacVariantSnapshotsForTemplate(nextGroup);
            if (!useVariantSnapshots) {
                (nextGroup as any).__atacVariantGroups = {};
            }
            // Guard against serializer/runtime paths that may omit this metadata.
            // Never drop previously saved per-variant settings on update.
            if (
                (nextGroup as any).__atacValueVariants == null &&
                prev?.group &&
                typeof (prev.group as any).__atacValueVariants === 'object'
            ) {
                try {
                    (nextGroup as any).__atacValueVariants =
                        typeof structuredClone === 'function'
                            ? structuredClone((prev.group as any).__atacValueVariants)
                            : JSON.parse(JSON.stringify((prev.group as any).__atacValueVariants));
                } catch {
                    (nextGroup as any).__atacValueVariants = (prev.group as any).__atacValueVariants;
                }
            }
            if (
                useVariantSnapshots &&
                (nextGroup as any).__atacVariantGroups == null &&
                prev?.group &&
                typeof (prev.group as any).__atacVariantGroups === 'object'
            ) {
                try {
                    (nextGroup as any).__atacVariantGroups =
                        typeof structuredClone === 'function'
                            ? structuredClone((prev.group as any).__atacVariantGroups)
                            : JSON.parse(JSON.stringify((prev.group as any).__atacVariantGroups));
                } catch {
                    (nextGroup as any).__atacVariantGroups = (prev.group as any).__atacVariantGroups;
                }
            }
            const manualTemplateProps = [
                '__manualTemplateBaseW',
                '__manualTemplateBaseH',
                '__manualGapSingle',
                '__manualGapRetail',
                '__manualGapWholesale',
                '__manualSingleAnchors'
            ] as const;
            for (const key of manualTemplateProps) {
                if ((nextGroup as any)[key] == null && prev?.group && (prev.group as any)[key] != null) {
                    try {
                        (nextGroup as any)[key] = typeof structuredClone === 'function'
                            ? structuredClone((prev.group as any)[key])
                            : JSON.parse(JSON.stringify((prev.group as any)[key]));
                    } catch {
                        (nextGroup as any)[key] = (prev.group as any)[key];
                    }
                }
            }
        }

        const next: LabelTemplate = {
            ...prev,
            name: (updates.name ?? prev.name),
            group: nextGroup,
            previewDataUrl: updates.previewDataUrl ?? prev.previewDataUrl,
            updatedAt: new Date().toISOString()
        };
        // If mini editor preview generation failed (tainted canvas), regenerate here.
        if (!next.previewDataUrl) {
            next.previewDataUrl = await renderLabelTemplatePreview(next);
        }

        (next as any).__fromDb = false;
        (next as any).__localOverride = true;
        const list = [...labelTemplates.value];
        list[idx] = next;
        labelTemplates.value = list;
        // Keep template definitions aligned across all pages so reload/page-switch
        // cannot bring back stale template snapshots from another page.
        syncLabelTemplatesIntoProjectPages('user');
        saveCurrentState({
            reason: 'mini-editor:template-update',
            skipCoalesce: true,
            skipIfUnchanged: false
        });

        const saved = await upsertLabelTemplateToDb(next);
        if (!saved) {
            console.warn('[labelTemplates] Edição salva no projeto, mas não foi persistida na biblioteca de templates (DB)');
        }

        // If this template is in use by any zone, re-apply it to keep cards in sync.
        if (canvas.value) {
            const zones = canvas.value.getObjects().filter((o: any) => isLikelyProductZone(o));
            for (const z of zones) {
                const usedByStyle = String((z as any)?._zoneGlobalStyles?.splashTemplateId || '').trim();
                const usedBySnapshot = String((z as any)?._zoneTemplateSnapshotId || '').trim();
                if (usedByStyle === templateId || usedBySnapshot === templateId) {
                    // Template edited in mini editor: refresh existing cards that already use it.
                    await applyLabelTemplateToZone(z, templateId, true);
                }
            }
        }

        // Save template edits remotely before returning control to UI
        // so reload/navigation does not drop latest mini editor changes.
        if (hasUnsavedChanges.value) {
            triggerAutoSave();
            try {
                await flushAutoSave();
            } catch (persistErr) {
                console.warn('[labelTemplates] Falha ao forcar flush remoto apos salvar mini editor', persistErr);
            }
        }

        done?.({ ok: true });
    } catch (err: any) {
        console.error('[labelTemplates] Falha ao salvar edição do mini editor', err);
        done?.({ ok: false, message: String(err?.message || 'Falha ao salvar a etiqueta.') });
    }
}

// Helper for Responsive Card Layout
const buildCardRelayoutSignature = (group: any, w: number, h: number, styles?: Partial<GlobalStyles>) => {
    const num = (v: any, precision = 3) => {
        const n = Number(v);
        if (!Number.isFinite(n)) return null;
        return Number(n.toFixed(precision));
    };
    const txt = (v: any) => {
        if (v === null || v === undefined) return '';
        return String(v);
    };

    const productData = ((group as any)?._productData && typeof (group as any)._productData === 'object')
        ? ((group as any)._productData as Record<string, any>)
        : {};
    const s = (styles && typeof styles === 'object') ? styles : ({} as Partial<GlobalStyles>);

    // Keep only layout-relevant values so auto-save noise does not retrigger relayout.
    const styleSig = {
        splashTemplateId: txt((s as any).splashTemplateId),
        splashScale: num((s as any).splashScale),
        splashOffsetY: num((s as any).splashOffsetY),
        splashTextScale: num((s as any).splashTextScale),
        splashFill: txt((s as any).splashFill),
        splashColor: txt((s as any).splashColor ?? (s as any).accentColor),
        splashTextColor: txt((s as any).splashTextColor),
        priceTextColor: txt((s as any).priceTextColor),
        priceCurrencyColor: txt((s as any).priceCurrencyColor),
        priceFont: txt((s as any).priceFont),
        priceFontWeight: txt((s as any).priceFontWeight),
        prodNameScale: num((s as any).prodNameScale),
        prodNameTransform: txt((s as any).prodNameTransform),
        prodNameLineHeight: num((s as any).prodNameLineHeight),
        cardBorderRadius: num((s as any).cardBorderRadius)
    };

    const pricingSig = {
        price: txt((group as any)?.price ?? productData.price),
        pricePack: txt((group as any)?.pricePack ?? productData.pricePack),
        priceUnit: txt((group as any)?.priceUnit ?? productData.priceUnit),
        priceSpecial: txt((group as any)?.priceSpecial ?? productData.priceSpecial),
        priceSpecialUnit: txt((group as any)?.priceSpecialUnit ?? productData.priceSpecialUnit),
        priceWholesale: txt((group as any)?.priceWholesale ?? productData.priceWholesale),
        wholesaleTrigger: txt((group as any)?.wholesaleTrigger ?? productData.wholesaleTrigger),
        wholesaleTriggerUnit: txt((group as any)?.wholesaleTriggerUnit ?? productData.wholesaleTriggerUnit),
        packQuantity: txt((group as any)?.packQuantity ?? productData.packQuantity),
        packUnit: txt((group as any)?.packUnit ?? productData.packUnit),
        packageLabel: txt((group as any)?.packageLabel ?? productData.packageLabel),
        specialCondition: txt((group as any)?.specialCondition ?? productData.specialCondition),
        imageUrl: txt((group as any)?.imageUrl ?? productData.imageUrl ?? productData.image)
    };

    return JSON.stringify({
        w: num(w),
        h: num(h),
        styleSig,
        pricingSig
    });
};

const resizeSmartObject = (group: any, w: number, h: number, styles?: Partial<GlobalStyles>) => {
    // Reset Group Scale/Skew to ensure clean internal layout
    group.scale(1);
    group.set({ width: w, height: h });

    const relayoutSignature = buildCardRelayoutSignature(group, w, h, styles);
    const forceRelayout = (group as any).__forceCardRelayout === true;
    if (!forceRelayout && (group as any).__lastCardRelayoutSignature === relayoutSignature) {
        (group as any)._cardWidth = w;
        (group as any)._cardHeight = h;
        group.dirty = true;
        group.setCoords?.();
        return;
    }
    (group as any).__lastCardRelayoutSignature = relayoutSignature;
    (group as any).__forceCardRelayout = false;
    
    const halfW = w / 2;
    const halfH = h / 2;
    const baseSize = Math.min(w, h);
    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const objects = group.getObjects();
    let bg: any = null;
    let title: any = null;
    let limit: any = null;
    let img: any = null;
    let namedSplash: any = null;
    let fallbackSplashGroup: any = null;
    let directPriceGroup: any = null;
    let topMostText: any = null;
    let topMostTextTop = Infinity;
    let largestRect: any = null;
    let largestRectArea = -1;
    let rectCount = 0;
    let imageCount = 0;
    let loneImage: any = null;

    // Single-pass lookup to keep relayout fast when many cards are updated.
    for (const obj of objects) {
        if (!obj) continue;
        const name = String(obj.name || '');
        const type = String(obj.type || '').toLowerCase();

        if (!bg && name === 'offerBackground') bg = obj;
        if (!title && name === 'smart_title') title = obj;
        if (!img && name === 'smart_image') img = obj;
        if (!namedSplash && (name === 'smart_price' || name === 'smart_splash')) namedSplash = obj;
        if (!directPriceGroup && type === 'group' && name === 'priceGroup') directPriceGroup = obj;
        if (!fallbackSplashGroup && type === 'group') fallbackSplashGroup = obj;
        if (!limit && (name === 'smart_limit' || name === 'limitText' || name === 'product_limit' || obj?.data?.smartType === 'product-limit')) {
            limit = obj;
        }

        if (type === 'rect') {
            rectCount += 1;
            const area = (obj?.width || 0) * (obj?.height || 0) * (obj?.scaleX || 1) * (obj?.scaleY || 1);
            if (area >= largestRectArea) {
                largestRectArea = area;
                largestRect = obj;
            }
        }

        if (isTextLikeObject(obj)) {
            const top = typeof obj?.top === 'number' ? obj.top : Infinity;
            if (top <= topMostTextTop) {
                topMostTextTop = top;
                topMostText = obj;
            }
        }

        if (type === 'image') {
            imageCount += 1;
            loneImage = obj;
        }
    }

    // Fallback: The background is usually the largest rect that fills most of the card.
    if (!bg && largestRect && rectCount > 0) {
        bg = largestRect;
        bg.name = 'offerBackground'; // Repair name
    }

    // Fallback: title is usually the top-most text object.
    if (!title && topMostText) {
        title = topMostText;
        title.name = 'smart_title';
    }

    // Fallback: image is often the only image in the card.
    if (!img && imageCount === 1 && loneImage) {
        img = loneImage;
        img.name = 'smart_image';
    }

    // Splash can vary names; prefer the canonical price label group when present (even when nested).
    const isDescendantOfGroup = (candidate: any, root: any) => {
        let current = candidate;
        while (current) {
            if (current === root) return true;
            current = current.group;
        }
        return false;
    };

    let priceGroup = (group as any).__priceGroupRef;
    if (!(priceGroup && priceGroup.type === 'group' && isDescendantOfGroup(priceGroup, group))) {
        priceGroup = directPriceGroup ?? getPriceGroupFromAny(group);
        (group as any).__priceGroupRef = priceGroup ?? null;
    }

    const splash = priceGroup ?? namedSplash ?? fallbackSplashGroup;

    // When the user moves an inner element (deep select), we mark it with `__manualTransform`.
    // During zone relayout (and on reload), we must NOT override these user placements.
    const isManual = (o: any) => !!(o && (o as any).__manualTransform);

    // If the card size changes (ex: more items in the zone, zone resize, preset change),
    // reposition manual elements proportionally so they keep their relative placement.
    const maybeRescaleManualTransforms = (o: any) => {
        if (!o || !isManual(o)) return;
        const prevW = Number((o as any).__manualTransformCardW);
        const prevH = Number((o as any).__manualTransformCardH);

        // Initialize baseline on first layout pass.
        if (!Number.isFinite(prevW) || prevW <= 0 || !Number.isFinite(prevH) || prevH <= 0) {
            (o as any).__manualTransformCardW = w;
            (o as any).__manualTransformCardH = h;
            return;
        }

        // Skip micro-deltas to avoid drift on repeated relayouts with same size.
        const dw = Math.abs(prevW - w);
        const dh = Math.abs(prevH - h);
        if (dw < 0.5 && dh < 0.5) return;

        const rx = w / prevW;
        const ry = h / prevH;
        if (!Number.isFinite(rx) || !Number.isFinite(ry) || rx <= 0 || ry <= 0) return;

        if (typeof o.left === 'number') o.left = o.left * rx;
        if (typeof o.top === 'number') o.top = o.top * ry;
        o.setCoords?.();

        (o as any).__manualTransformCardW = w;
        (o as any).__manualTransformCardH = h;
    };
    objects.forEach((o: any) => maybeRescaleManualTransforms(o));
    
    // 1. Background Fill
    if (bg) {
        if(bg.type === 'rect') {
             // Keep the background centered on the group origin to avoid drifting bounds/selection boxes.
             bg.set({
                 width: w,
                 height: h,
                 scaleX: 1,
                 scaleY: 1,
                 originX: 'center',
                 originY: 'center',
                 left: 0,
                 top: 0
             });

             if (styles) {
                 if (styles.isProdBgTransparent) bg.set('fill', 'transparent');
                 else if (styles.cardColor) bg.set('fill', styles.cardColor);
                 if (typeof styles.cardBorderRadius === 'number') bg.set({ rx: styles.cardBorderRadius, ry: styles.cardBorderRadius });

                 // Apply border color and width.
                 // If width is 0, keep border fully disabled (default cards without outline).
                 if (styles.cardBorderColor) {
                     const borderWidth = Math.max(0, Number(styles.cardBorderWidth ?? 0));
                     if (borderWidth > 0) {
                         bg.set('stroke', styles.cardBorderColor);
                         bg.set('strokeWidth', borderWidth);
                     } else {
                         bg.set('stroke', undefined);
                         bg.set('strokeWidth', 0);
                     }
                 } else if (typeof styles.cardBorderWidth === 'number') {
                     const borderWidth = Math.max(0, Number(styles.cardBorderWidth ?? 0));
                     if (borderWidth > 0) {
                         bg.set('strokeWidth', borderWidth);
                     } else {
                         bg.set('stroke', undefined);
                         bg.set('strokeWidth', 0);
                     }
                 }
             }
        } else {
             bg.set({ scaleX: w / bg.width, scaleY: h / bg.height, left: 0, top: 0, originX: 'center', originY: 'center' });
        }
    }
    
    // 2. Title (Top)
    let titleH = 0;
    if (title) {
        // Margin Top: 5% of height
        const marginTop = h * 0.05;
        if (!isManual(title)) {
            title.set({
                originX: 'center',
                originY: 'top',
                left: 0,
                top: -halfH + marginTop,
                scaleX: 1, scaleY: 1
            });
        }

        if (styles) {
            if (styles.prodNameFont) title.set('fontFamily', styles.prodNameFont);
            if (styles.prodNameColor) title.set('fill', styles.prodNameColor);
            if (styles.prodNameWeight !== undefined) title.set('fontWeight', styles.prodNameWeight as any);
            if (styles.prodNameAlign) title.set('textAlign', styles.prodNameAlign);
            if (typeof styles.prodNameLineHeight === 'number') title.set('lineHeight', styles.prodNameLineHeight);

            const rawKey = '__rawText';
            const curText = String((title as any).text ?? '');
            if (typeof (title as any)[rawKey] !== 'string') (title as any)[rawKey] = curText;
            const mode = styles.prodNameTransform ?? 'none';
            if (mode === 'none') {
                (title as any)[rawKey] = curText;
            } else {
                const baseText = String((title as any)[rawKey] ?? curText);
                const nextText = mode === 'upper' ? baseText.toUpperCase() : mode === 'lower' ? baseText.toLowerCase() : baseText;
                if (nextText !== curText) title.set('text', nextText);
            }

            const scale = typeof styles.prodNameScale === 'number' ? styles.prodNameScale : 1;
            const baseFont = baseSize * 0.09;
            const nextFont = clamp(baseFont * scale, 10, baseSize * 0.22);
            title.set('fontSize', nextFont);
        }
        
        // Responsive Text Width
        if (title.type === 'textbox') {
            const manualTitleWidth = Number((title as any).__manualTextWidth);
            const manualTitleWidthRatio = Number((title as any).__manualTextWidthRatio);
            let nextTitleWidth = w * 0.9; // default auto width
            if (isManual(title)) {
                if (Number.isFinite(manualTitleWidthRatio) && manualTitleWidthRatio > 0) {
                    nextTitleWidth = w * manualTitleWidthRatio;
                } else if (Number.isFinite(manualTitleWidth) && manualTitleWidth > 0) {
                    nextTitleWidth = manualTitleWidth;
                }
            }
            nextTitleWidth = clamp(nextTitleWidth, 20, Math.max(20, w));
            title.set({ width: nextTitleWidth });
            if (isManual(title)) {
                (title as any).__manualTextWidth = nextTitleWidth;
                const ratio = w > 0 ? (nextTitleWidth / w) : Number.NaN;
                if (Number.isFinite(ratio) && ratio > 0) {
                    (title as any).__manualTextWidthRatio = Math.min(1, Math.max(0.1, ratio));
                }
            }
            if (typeof title.initDimensions === 'function') title.initDimensions();
        } else {
            // Scale down if too wide
            if (title.width > w * 0.9) {
                title.scale((w * 0.9) / title.width);
            }
        }
        if (typeof title.initDimensions === 'function') title.initDimensions();
        titleH = title.getScaledHeight() + marginTop;
    }

    // 2.1 Limit badge/text (Below Title)
    let limitH = 0;
    if (limit && String(limit.type || '').includes('text')) {
        const marginTop = h * 0.05;
        const gap = Math.max(4, h * 0.008);

        const titleHeight = title ? (title.getScaledHeight?.() ?? title.height ?? 0) : 0;
        if (!isManual(limit)) {
            limit.set({
                originX: 'center',
                originY: 'top',
                left: 0,
                top: -halfH + marginTop + titleHeight + gap,
                scaleX: 1,
                scaleY: 1
            });
        }

        if (styles) {
            if (styles.limitFont) limit.set('fontFamily', styles.limitFont);
            if (styles.limitColor) limit.set('fill', styles.limitColor);

            // Dynamic sizing: base on card size, and respect legacy `limitSize` as multiplier (default ~14).
            const mult = (typeof styles.limitSize === 'number' && styles.limitSize > 0) ? (styles.limitSize / 14) : 1;
            const baseFont = baseSize * 0.045;
            const nextFont = clamp(baseFont * mult, 8, baseSize * 0.12);
            limit.set('fontSize', nextFont);
        } else {
            // Reasonable default if older cards have this text but no styles passed
            const baseFont = baseSize * 0.045;
            limit.set('fontSize', clamp(baseFont, 8, baseSize * 0.12));
        }

        // Hide if empty
        const txt = String((limit as any).text ?? '').trim();
        limit.visible = txt.length > 0;

        if (limit.type === 'textbox') {
            limit.set({ width: w * 0.9 });
            if (typeof (limit as any).initDimensions === 'function') (limit as any).initDimensions();
        }

        if (typeof (limit as any).initDimensions === 'function') (limit as any).initDimensions();
        limitH = limit.visible ? ((limit.getScaledHeight?.() ?? 0) + gap) : 0;
    }

    // 3. Bottom Element (Splash/Price)
    let bottomH = 0;
    if (splash) {
        const marginBottom = h * 0.05;
        const splashManual = isManual(splash);
        let preserveTemplateVisual = false;
        let layoutScaleX = 1;
        let layoutScaleY = 1;

        // Extract priceBg for later use (shadow update needs pillH from layout)
        let priceBg: any = null;

        if (splash.type === 'group' && splash.name === 'priceGroup') {
            preserveTemplateVisual = shouldPreserveManualTemplateVisual(splash);
            // Apply label styling overrides (local to the selected zone/design; never mutates templates).
            if (styles && typeof splash.getObjects === 'function') {
                const parts = collectObjectsDeep(splash);
                priceBg = parts.find((o: any) => o?.name === 'price_bg');
                const currencyText = parts.find((o: any) => o?.name === 'price_currency_text');
                const priceInteger = parts.find((o: any) => o?.name === 'price_integer_text');
                const priceDecimal = parts.find((o: any) => o?.name === 'price_decimal_text');
                const priceUnit = parts.find((o: any) => o?.name === 'price_unit_text');
                const normalizeColorToken = (value: any) => {
                    const raw = String(value ?? '').trim().toLowerCase();
                    if (!raw) return '';
                    return raw.startsWith('#') ? raw : `#${raw}`;
                };
                const defaultPriceFont = String(DEFAULT_GLOBAL_STYLES.priceFont || '').trim().toLowerCase();
                const defaultSplashTextColor = normalizeColorToken(DEFAULT_GLOBAL_STYLES.splashTextColor || '');
                const defaultSplashFill = normalizeColorToken(DEFAULT_GLOBAL_STYLES.splashFill || '');
                const defaultAccentColor = normalizeColorToken(
                    DEFAULT_GLOBAL_STYLES.splashColor ?? DEFAULT_GLOBAL_STYLES.accentColor ?? ''
                );

                const accent = styles.splashColor ?? styles.accentColor;
                const hasExplicitAccent = !!String(accent ?? '').trim() && (
                    !preserveTemplateVisual || normalizeColorToken(accent) !== defaultAccentColor
                );
                const hasExplicitFill = typeof styles.splashFill === 'string' && styles.splashFill.trim().length > 0 && (
                    !preserveTemplateVisual || normalizeColorToken(styles.splashFill) !== defaultSplashFill
                );
                const hasExplicitRoundness = typeof styles.splashRoundness === 'number' && (
                    !preserveTemplateVisual ||
                    Math.abs(Number(styles.splashRoundness) - Number(DEFAULT_GLOBAL_STYLES.splashRoundness ?? 1)) > 0.0001
                );
                const hasExplicitStrokeWidth = typeof styles.splashStrokeWidth === 'number' && Number.isFinite(styles.splashStrokeWidth);
                const hasExplicitPriceFont = typeof styles.priceFont === 'string' && styles.priceFont.trim().length > 0 && (
                    !preserveTemplateVisual || styles.priceFont.trim().toLowerCase() !== defaultPriceFont
                );
                const hasExplicitPriceWeight = styles.priceFontWeight !== undefined && (
                    !preserveTemplateVisual ||
                    String(styles.priceFontWeight) !== String(DEFAULT_GLOBAL_STYLES.priceFontWeight ?? '')
                );
                const hasExplicitPriceTextColor = typeof styles.priceTextColor === 'string' && styles.priceTextColor.trim().length > 0;
                const hasExplicitSplashTextColor = typeof styles.splashTextColor === 'string' && styles.splashTextColor.trim().length > 0 && (
                    !preserveTemplateVisual || normalizeColorToken(styles.splashTextColor) !== defaultSplashTextColor
                );
                const hasExplicitCurrencyColor = typeof styles.priceCurrencyColor === 'string' && styles.priceCurrencyColor.trim().length > 0;

                if (priceBg) {
                    // Apply styles to price background
                    // Priority: explicit splashFill > template fill > default
                    if (hasExplicitFill) {
                        priceBg.set('fill', styles.splashFill);
                    }
                    if (hasExplicitRoundness && typeof styles.splashRoundness === 'number') {
                        const roundness = clamp(styles.splashRoundness, 0, 1);
                        (priceBg as any).__roundness = roundness;
                        if (String(priceBg?.type || '').toLowerCase() === 'rect') {
                            const hRaw = Number(priceBg.height || 0);
                            if (Number.isFinite(hRaw) && hRaw > 0) {
                                const radius = (hRaw / 2) * roundness;
                                priceBg.set({ rx: radius, ry: radius });
                            }
                        }
                    }
                    if (hasExplicitStrokeWidth) (priceBg as any).__strokeWidth = styles.splashStrokeWidth;

                    // Apply accent/splash color - always apply if set, regardless of template
                    // This allows users to override template colors with zone styles
                    if (hasExplicitAccent && accent) {
                        priceBg.set('stroke', accent);
                    }
                }

                const applyTextShared = (t: any) => {
                    if (!t || !String(t.type || '').includes('text')) return;
                    // Always apply font and weight if explicitly set (overrides template)
                    if ((!preserveTemplateVisual || hasExplicitPriceFont) && styles.priceFont) t.set('fontFamily', styles.priceFont);
                    if ((!preserveTemplateVisual || hasExplicitPriceWeight) && styles.priceFontWeight !== undefined) {
                        t.set('fontWeight', styles.priceFontWeight as any);
                    }

                    const mult = typeof styles.splashTextScale === 'number' ? styles.splashTextScale : 1;
                    if (preserveTemplateVisual) {
                        const originalFont = Number((t as any).__originalFontSize);
                        const currentFont = Number(t.fontSize || 0);
                        const baseFont = Number((t as any).__fontSizeBase);
                        const fallbackBase = Number.isFinite(originalFont) && originalFont > 0
                            ? originalFont
                            : (Number.isFinite(currentFont) && currentFont > 0 ? currentFont : 0);
                        const sourceBase = Number.isFinite(baseFont) && baseFont > 0 ? baseFont : fallbackBase;
                        if (sourceBase > 0) {
                            (t as any).__fontSizeBase = sourceBase;
                            t.set({
                                fontSize: sourceBase * mult,
                                scaleX: 1,
                                scaleY: 1
                            });
                        }
                    } else if (typeof t.__fontScale === 'number') {
                        if (typeof t.__fontScaleBase !== 'number') t.__fontScaleBase = t.__fontScale;
                        t.__fontScale = t.__fontScaleBase * mult;
                    }
                    if (typeof t.initDimensions === 'function') t.initDimensions();
                };

                const applyPriceText = (t: any) => {
                    applyTextShared(t);
                    if (!t || !String(t.type || '').includes('text')) return;
                    // Apply text color if set (explicit override)
                    if (hasExplicitPriceTextColor) t.set('fill', styles.priceTextColor);
                    else if ((!preserveTemplateVisual && typeof styles.splashTextColor === 'string' && styles.splashTextColor.trim())
                        || (preserveTemplateVisual && hasExplicitSplashTextColor)) {
                        t.set('fill', styles.splashTextColor);
                    }
                };

                const applyCurrencyText = (t: any) => {
                    applyTextShared(t);
                    if (!t || !String(t.type || '').includes('text')) return;
                    // Apply currency color if explicitly set
                    if (hasExplicitCurrencyColor) t.set('fill', styles.priceCurrencyColor);
                };

                applyCurrencyText(currencyText);
                [priceInteger, priceDecimal, priceUnit].forEach(applyPriceText);
                if (preserveTemplateVisual) {
                    // Keep authored geometry and only re-fit dynamic values after typography changes.
                    fitManualSinglePriceValuesIntoTemplate(splash);
                    fitManualAtacarejoValuesIntoTemplate(splash);
                }
            }

            const layout = layoutPriceGroup(splash, w, h);

            if (layout) {
                const { pillH } = layout;
                layoutScaleX = Number(splash.scaleX) || 1;
                layoutScaleY = Number(splash.scaleY) || 1;
                const rawScale = typeof styles?.splashScale === 'number' ? styles!.splashScale! : 1;
                const rawOffsetY = typeof styles?.splashOffsetY === 'number' ? styles!.splashOffsetY! : 0;
                const scale = rawScale;
                const offsetY = rawOffsetY;

                // Update shadow color to match accent (after we have pillH for proper blur calculation)
                const accent = styles?.splashColor ?? styles?.accentColor;
                if (!preserveTemplateVisual && accent && priceBg && fabric?.Shadow) {
                    priceBg.set('stroke', accent);
                    const blur = Math.max(6, Math.min(26, pillH * 0.22));
                    priceBg.set('shadow', new fabric.Shadow({ color: accent, blur, offsetX: 0, offsetY: 0 }));
                }

                // Force dirty flag to ensure Fabric.js updates the object
                splash.dirty = true;
                
                if (!splashManual) {
                    const newTop = halfH - ((pillH * scale) / 2) - marginBottom + offsetY;
                    const finalScaleX = preserveTemplateVisual ? (layoutScaleX * scale) : scale;
                    const finalScaleY = preserveTemplateVisual ? (layoutScaleY * scale) : scale;
                    splash.set({
                        scaleX: finalScaleX,
                        scaleY: finalScaleY,
                        originX: 'center',
                        originY: 'center',
                        left: 0,
                        top: newTop
                    });
                } else {
                    // Manual positioning: keep left/top, but still apply the zone-level scale.
                    const finalScaleX = preserveTemplateVisual ? (layoutScaleX * scale) : scale;
                    const finalScaleY = preserveTemplateVisual ? (layoutScaleY * scale) : scale;
                    splash.set({ scaleX: finalScaleX, scaleY: finalScaleY });
                }
                
                // Force coordinate update
                splash.setCoords();
                
                bottomH = (pillH * scale) + marginBottom;
            } else {
                // Fallback to generic scaling for older cards without named parts
                // Apply global styles even in fallback mode
                const globalScale = typeof styles?.splashScale === 'number' ? styles!.splashScale! : 1;
                const offsetY = typeof styles?.splashOffsetY === 'number' ? styles!.splashOffsetY! : 0;

                // Armazenar o scale ORIGINAL (na criação), não o scale atual
                // Isso garante que o redimensionamento funcione corretamente em ambas direções
                if (typeof (splash as any).__originalScaleX !== 'number') {
                    // Primeira vez: capturar o scale atual como "original"
                    (splash as any).__originalScaleX = splash.scaleX || 1;
                    (splash as any).__originalScaleY = splash.scaleY || 1;
                }

                // Calcular scale baseado no tamanho do cartão relativo ao tamanho original
                const originalW = (splash as any).__originalCardWidth || splash.width || 100;
                const sizeRatio = w / originalW;

                // Aplicar: scale_original × ratio × globalScale
                const origScaleX = (splash as any).__originalScaleX || 1;
                const origScaleY = (splash as any).__originalScaleY || 1;
                let sScaleX = origScaleX * sizeRatio * globalScale;
                let sScaleY = origScaleY * sizeRatio * globalScale;

                // Armazenar largura original do cartão para próximos redimensionamentos
                (splash as any).__originalCardWidth = w;

                // Clamp para não ultrapassar limites
                if ((splash.width * sScaleX) > w * 0.9) {
                    const clampScale = (w * 0.9) / splash.width;
                    sScaleX = clampScale;
                    sScaleY = clampScale;
                }

                const maxSplashH = h * 0.35;
                if ((splash.height * sScaleY) > maxSplashH) {
                    const clampScale = maxSplashH / splash.height;
                    sScaleX = clampScale;
                    sScaleY = clampScale;
                }

                // Force dirty flag to ensure Fabric.js updates the object
                splash.dirty = true;

                if (!splashManual) {
                    const newTop = halfH - marginBottom + offsetY;
                    splash.set({
                        scaleX: sScaleX,
                        scaleY: sScaleY,
                        originX: 'center',
                        originY: 'bottom',
                        left: 0,
                        top: newTop
                    });
                } else {
                    splash.set({ scaleX: sScaleX, scaleY: sScaleY });
                }

                // Force coordinate update
                splash.setCoords();

                bottomH = (splash.height * sScaleY) + marginBottom;
            }
        } else {
            // Max height for splash: 30% of card
            const maxSplashH = h * 0.35;
            
            // Scale splash to fit width or max height
            let sScale = splash.scaleX; // Use current or reset? Better maintain relative scale if possible, or reset.
            // Assuming splash starts at scale 1 relative to card creation size...
            // But users scale splash individually.
            // Let's rely on bounding Width relative to W.
            
            // Fit width (90%)
            if ((splash.width * sScale) > w * 0.9) {
                sScale = (w * 0.9) / splash.width;
            }
            
            // Check height Constraint
            if ((splash.height * sScale) > maxSplashH) {
                sScale = maxSplashH / splash.height;
            }
            
            if (!splashManual) {
                splash.set({
                    scaleX: sScale,
                    scaleY: sScale,
                    originX: 'center',
                    originY: 'bottom',
                    left: 0,
                    top: halfH - marginBottom
                });
            }
            
            bottomH = (splash.height * sScale) + marginBottom;
        }

        // If the user positioned the splash manually, reserve space based on its current size,
        // not the auto-layout computation above (prevents image layout from hiding it).
        if (splashManual) {
            const sh = typeof splash.getScaledHeight === 'function'
                ? splash.getScaledHeight()
                : (Number(splash.height || 0) * Number(splash.scaleY || 1));
            bottomH = Math.max(0, Number(sh) || 0) + marginBottom;
        }
    }
    
    // 4. Image (Middle - Object Fit: Contain)
    if (img) {
        const imgManual = isManual(img);
        const availH = h - titleH - limitH - bottomH - 20; // 20px buffer
        const availW = w * 0.9;

        // Product images inside cards should never flip during resize interactions.
        img.set({
            lockScalingFlip: true,
            lockSkewingX: true,
            lockSkewingY: true,
            flipX: false,
            flipY: false
        });
        if ((Number(img.scaleX ?? 1) || 1) < 0) img.set('scaleX', Math.abs(Number(img.scaleX ?? 1)) || 1);
        if ((Number(img.scaleY ?? 1) || 1) < 0) img.set('scaleY', Math.abs(Number(img.scaleY ?? 1)) || 1);
        
        if (availH > 20) {
            // Restore scale 1 to measure
            const currentScale = img.scaleX; 
            // We use raw img.width/height assuming scale=1 is base assets.
            
            const iW = img.width;
            const iH = img.height;
            const iRatio = iW / iH;
            const availRatio = availW / availH;
            
            let scale = 1;
            if (iRatio > availRatio) {
                // Width constrained
                scale = availW / iW;
            } else {
                // Height constrained
                scale = availH / iH;
            }
            
            // Center in available space
            // Space starts at: -halfH + titleH
            // Space center: (-halfH + titleH) + (availH / 2)
            const centerY = (-halfH + titleH + limitH) + (availH / 2);
            
            img.visible = true;
            if (!imgManual) {
                img.set({
                    scaleX: scale,
                    scaleY: scale,
                    originX: 'center',
                    originY: 'center',
                    left: 0,
                    top: centerY
                });
            }
        } else {
            // Hide only when auto-layout controls the image; a manual image should remain visible.
            if (!imgManual) img.visible = false;
            else img.visible = true;
        }
    }

    // Keep user-positioned inner elements inside the card bounds after any resize/relayout.
    // This avoids "teleporting" on reload when the card size changes (zone preset/columns/etc.).
    const clampChildToCard = (obj: any) => {
        if (!obj || typeof obj.getScaledWidth !== 'function' || typeof obj.getScaledHeight !== 'function') return;
        const objW = obj.getScaledWidth();
        const objH = obj.getScaledHeight();
        let minX = -halfW;
        let maxX = halfW;
        let minY = -halfH;
        let maxY = halfH;
        if (obj.originX === 'center') { minX = -halfW + objW / 2; maxX = halfW - objW / 2; }
        else if (obj.originX === 'left') { maxX = halfW - objW; }
        if (obj.originY === 'center') { minY = -halfH + objH / 2; maxY = halfH - objH / 2; }
        else if (obj.originY === 'top') { maxY = halfH - objH; }
        if (minX > maxX) { const t = minX; minX = maxX; maxX = t; }
        if (minY > maxY) { const t = minY; minY = maxY; maxY = t; }
        if (typeof obj.left === 'number') obj.left = Math.min(maxX, Math.max(minX, obj.left));
        if (typeof obj.top === 'number') obj.top = Math.min(maxY, Math.max(minY, obj.top));
        obj.setCoords?.();
    };
    objects.forEach((o: any) => {
        if (!o || o === bg) return;
        if (isManual(o)) clampChildToCard(o);
    });

    // Ensure stacking order stays predictable (image should not hide the title).
    // We reorder via the internal array to avoid coordinate transforms from remove/add.
    const stackList = (group as any)?._objects;
    if (Array.isArray(stackList)) {
        const moveToIndex = (obj: any, index: number) => {
            if (!obj) return;
            const from = stackList.indexOf(obj);
            if (from === -1) return;
            stackList.splice(from, 1);
            const to = Math.max(0, Math.min(index, stackList.length));
            stackList.splice(to, 0, obj);
        };
        const moveToEnd = (obj: any) => moveToIndex(obj, stackList.length);
        moveToIndex(bg, 0);
        moveToIndex(img, 1);
        moveToEnd(title);
        moveToEnd(splash);
        if (typeof (group as any)._onStackOrderChanged === 'function') {
            (group as any)._onStackOrderChanged();
        }
    }
    
    (group as any)._cardWidth = w;
    (group as any)._cardHeight = h;
    // CRITICAL: Do NOT call safeAddWithUpdate(group) — Fabric's LayoutManager recalculates
    // bounds from ALL children. If splash/shadows extend beyond the intended w×h, Fabric
    // expands the group and shifts its center, causing the background to be offset and the
    // splash/price label to visually ESCAPE the card. Instead, freeze the group dimensions.
    group.set({ width: w, height: h });
    // Update coords for all children (replaces _updateObjectsCoords that safeAddWithUpdate would do)
    objects.forEach((o: any) => {
        if (o && typeof o.setCoords === 'function') o.setCoords();
    });
    group.dirty = true;
    if (typeof group.setCoords === 'function') group.setCoords();
}

const getZoneRect = (zone: any) => {
    if (!zone) return null;
    if (zone.type === 'rect') return zone;
    if (typeof zone.getObjects !== 'function') return null;
    const objs = zone.getObjects() || [];
    return (
        objs.find((o: any) => o.type === 'rect' && (o.name === 'zoneRect' || o.name === 'zone-border' || Array.isArray(o.strokeDashArray))) ||
        objs.find((o: any) => o.type === 'rect') ||
        null
    );
}

const isLikelyProductZone = (obj: any) => {
    if (!obj) return false;
    if (obj.type !== 'group') return false;
    if (obj.isGridZone || obj.isProductZone) return true;
    if (obj.name === 'gridZone' || obj.name === 'productZoneContainer') return true;
    // CRITICAL: Detect zones via zone-specific custom properties that survive serialization.
    // This catches legacy arts where flags were not originally in CANVAS_CUSTOM_PROPS.
    if (typeof obj._zonePadding === 'number' && typeof obj._zoneWidth === 'number' && typeof obj._zoneHeight === 'number') return true;
    const rect = getZoneRect(obj);
    return !!(rect && Array.isArray(rect.strokeDashArray));
}

const isStandalonePriceGroup = (obj: any) => {
    if (!obj) return false;
    if (obj.type !== 'group' || typeof obj.getObjects !== 'function') return false;
    if (String(obj.name || '') !== 'priceGroup') return false;

    // If it's already tagged as card/smart object, it's not a standalone label.
    if (obj.isSmartObject || obj.isProductCard) return false;
    if (String((obj as any).parentZoneId || '').trim()) return false;
    if (String((obj as any).smartGridId || '').trim()) return false;

    const children = obj.getObjects() || [];
    const hasOfferBg = children.some((c: any) => String(c?.name || '') === 'offerBackground');
    const hasSmartImage = children.some((c: any) => {
        const t = String(c?.type || '').toLowerCase();
        const n = String(c?.name || '');
        return t === 'image' || ['smart_image', 'product_image', 'productImage'].includes(n);
    });

    // A real standalone price label usually has only price texts/backgrounds, not card background/image.
    return !hasOfferBg && !hasSmartImage;
}

const isLikelyProductCard = (obj: any) => {
    if (!obj) return false;
    if (obj.excludeFromExport) return false;
    if (obj.isFrame) return false;
    if (isLikelyProductZone(obj)) return false;
    if (obj.type !== 'group' || typeof obj.getObjects !== 'function') return false;
    // Ignore only true standalone price labels. Some legacy cards were incorrectly named "priceGroup".
    if (isStandalonePriceGroup(obj)) return false;

    // If it already has a zone binding, treat as a product card (legacy-safe).
    const pz = String((obj as any).parentZoneId || '').trim();
    if (pz) return true;

    // Strong signals from our engine (even in older saves).
    const cw = Number((obj as any)._cardWidth);
    const ch = Number((obj as any)._cardHeight);
    if (Number.isFinite(cw) && cw > 0 && Number.isFinite(ch) && ch > 0) return true;
    if (String((obj as any).smartGridId || '').trim()) return true;
    if (String((obj as any).priceMode || '').trim()) return true;

    const children = obj.getObjects() || [];
    if (!children.length) return false;

    const isText = (o: any) => String(o?.type || '').toLowerCase().includes('text');
    const hasOfferBg = children.some((c: any) => String(c?.name || '') === 'offerBackground');
    const hasBg = hasOfferBg || children.some((c: any) => String(c?.type || '').toLowerCase() === 'rect' && /(offerBackground|background|bg)/i.test(String(c?.name || '')));
    const hasPriceGroup = children.some((c: any) => String(c?.type || '').toLowerCase() === 'group' && String(c?.name || '') === 'priceGroup');
    const hasAnyPriceText = children.some((c: any) => /price_(integer|decimal|value|currency|unit)_text/i.test(String(c?.name || '')));
    const hasImage = children.some((c: any) => {
        const t = String(c?.type || '').toLowerCase();
        const n = String(c?.name || '');
        return t === 'image' || ['smart_image', 'product_image', 'productImage'].includes(n);
    });
    const hasTitle = children.some((c: any) => isText(c) && /(^smart_title$|^title$|title)/i.test(String(c?.name || '')));
    const textCount = children.filter((c: any) => isText(c)).length;
    const nonTextCount = children.length - textCount;

    // Super-forte: o retângulo de fundo padrão do card.
    if (hasOfferBg) return true;
    // Forte: templates normalmente sempre têm o priceGroup.
    if (hasPriceGroup && (hasImage || hasTitle || textCount >= 1)) return true;

    // Heurística mais permissiva para cards montados manualmente:
    // se for um grupo (não-zone) com texto + algum elemento visual, tratamos como card.
    if (textCount >= 1 && nonTextCount >= 1 && (hasImage || hasBg || hasAnyPriceText)) return true;

    // Most cards have an embedded priceGroup. Require at least 2 signals to avoid false positives.
    const signals = [hasPriceGroup, hasImage, hasTitle, hasBg, hasAnyPriceText].filter(Boolean).length;
    if (hasAnyPriceText && hasImage && textCount >= 1) return true;
    return signals >= 3 || (hasAnyPriceText && textCount >= 2);
}

const repairLegacyProductCardImageTransforms = (
    cards: any[],
    opts: { verbose?: boolean } = {}
): { cardsScanned: number; imagesScanned: number; imagesRepaired: number } => {
    const verbose = opts.verbose === true;
    if (!Array.isArray(cards) || cards.length === 0) {
        return { cardsScanned: 0, imagesScanned: 0, imagesRepaired: 0 };
    }

    let cardsScanned = 0;
    let imagesScanned = 0;
    let imagesRepaired = 0;

    cards.forEach((card: any) => {
        if (!card || card.type !== 'group') return;
        if (isStandalonePriceGroup(card)) return;

        cardsScanned += 1;
        const descendants = typeof card.getObjects === 'function' ? collectObjectsDeep(card) : [];
        const images = descendants.filter((o: any) => String(o?.type || '').toLowerCase() === 'image');

        images.forEach((img: any) => {
            imagesScanned += 1;
            let changed = false;

            let nextScaleX = Number(img.scaleX ?? 1);
            let nextScaleY = Number(img.scaleY ?? 1);
            if (!Number.isFinite(nextScaleX) || nextScaleX === 0) {
                nextScaleX = 1;
                changed = true;
            }
            if (!Number.isFinite(nextScaleY) || nextScaleY === 0) {
                nextScaleY = 1;
                changed = true;
            }
            if (nextScaleX < 0 || nextScaleY < 0) {
                nextScaleX = Math.abs(nextScaleX) || 1;
                nextScaleY = Math.abs(nextScaleY) || 1;
                changed = true;
            }

            if (img.flipX || img.flipY) changed = true;
            if (img.lockScalingFlip !== true) changed = true;
            if (img.lockSkewingX !== true || img.lockSkewingY !== true) changed = true;

            // Repair invalid intrinsic dimensions when legacy/corrupted state has zero or NaN sizes.
            const rawW = Number(img.width ?? 0);
            const rawH = Number(img.height ?? 0);
            let nextWidth = rawW;
            let nextHeight = rawH;
            if (!Number.isFinite(rawW) || rawW <= 0 || !Number.isFinite(rawH) || rawH <= 0) {
                const el: any = (img as any)._originalElement || (img as any)._element || null;
                const naturalW = Number(el?.naturalWidth ?? el?.width ?? 0);
                const naturalH = Number(el?.naturalHeight ?? el?.height ?? 0);
                if (Number.isFinite(naturalW) && naturalW > 0 && Number.isFinite(naturalH) && naturalH > 0) {
                    nextWidth = naturalW;
                    nextHeight = naturalH;
                    changed = true;
                }
            }

            if (changed) {
                img.set({
                    scaleX: nextScaleX,
                    scaleY: nextScaleY,
                    flipX: false,
                    flipY: false,
                    lockScalingFlip: true,
                    lockSkewingX: true,
                    lockSkewingY: true
                });
                if (Number.isFinite(nextWidth) && nextWidth > 0 && Number.isFinite(nextHeight) && nextHeight > 0) {
                    img.set({
                        width: nextWidth,
                        height: nextHeight
                    });
                }
                img.setCoords?.();
                imagesRepaired += 1;
            }

            // Always clamp inside card after load to prevent detached images from legacy states.
            applyContainmentConstraints(img);
        });
    });

    if (verbose && imagesRepaired > 0) {
        console.log('[repairLegacyProductCardImageTransforms] repaired:', {
            cardsScanned,
            imagesScanned,
            imagesRepaired
        });
    }

    return { cardsScanned, imagesScanned, imagesRepaired };
}

const ensureZoneSanity = (zone: any) => {
    if (!zone) return;
    if (!zone._customId) zone._customId = Math.random().toString(36).substr(2, 9);
    let needsBoundsUpdate = false;

    // CRITICAL: Product zones should NOT have clipPath as it causes rendering errors
    // Cards are added separately to canvas, not as children of the zone group
    if (zone.clipPath) {
        zone.clipPath = null;
    }

    // Keep Fabric group padding at 0 to avoid inflating the selection bounds.
    // Use `_zonePadding` for layout math instead (used by recalculateZoneLayout).
    if (typeof zone._zonePadding !== 'number') {
        const currentPad = typeof zone.padding === 'number' ? zone.padding : 0;
        // Legacy zones used `group.padding` for layout; older defaults used 5 just for selection padding.
        zone._zonePadding = currentPad >= 10 ? currentPad : 20;
    }
    if (zone.padding !== 0) {
        zone.set('padding', 0);
        needsBoundsUpdate = true;
    }

    // Rows are auto-calculated in the current UX. Legacy saved fixed rows create holes after reload.
    if (typeof (zone as any).rows !== 'number' || !Number.isFinite((zone as any).rows) || (zone as any).rows < 0) {
        (zone as any).rows = 0;
    }
    if ((zone as any).rows > 0) {
        (zone as any).rows = 0;
    }

    // CRITICAL: Initialize _zoneWidth and _zoneHeight if missing (for persistence after reload)
    // This ensures the zone dimensions are correctly restored from the inner rect or calculated bounds
    if (typeof zone._zoneWidth !== 'number' || typeof zone._zoneHeight !== 'number') {
        const rect = typeof zone.getObjects === 'function' 
            ? zone.getObjects().find((o: any) => o?.type === 'rect') 
            : null;
        const rectWidth = rect ? (rect.width ?? 0) * (rect.scaleX ?? 1) : 0;
        const rectHeight = rect ? (rect.height ?? 0) * (rect.scaleY ?? 1) : 0;
        const zoneScaleX = Math.abs(zone.scaleX ?? 1);
        const zoneScaleY = Math.abs(zone.scaleY ?? 1);
        
        if (typeof zone._zoneWidth !== 'number') {
            zone._zoneWidth = rectWidth ? rectWidth * zoneScaleX : (zone.getScaledWidth?.() ?? zone.width ?? 400);
        }
        if (typeof zone._zoneHeight !== 'number') {
            zone._zoneHeight = rectHeight ? rectHeight * zoneScaleY : (zone.getScaledHeight?.() ?? zone.height ?? 600);
        }
        console.log('🔧 [ensureZoneSanity] Initialized zone dimensions:', { _zoneWidth: zone._zoneWidth, _zoneHeight: zone._zoneHeight });
    }

    // Ensure stable interaction flags
    zone.set({
        lockScalingFlip: true,
        objectCaching: false,
        statefullCache: false,
        selectable: true,
        evented: true,
        hasControls: true,
        hasBorders: true,
        subTargetCheck: false
    });

    // Normalize the inner rect scale so it always matches the group bounds while scaling.
    const rect = getZoneRect(zone);
    if (rect) {
        const sx = rect.scaleX ?? 1;
        const sy = rect.scaleY ?? 1;
        if (sx !== 1 || sy !== 1) {
            rect.set({
                width: (rect.width ?? 0) * sx,
                height: (rect.height ?? 0) * sy,
                scaleX: 1,
                scaleY: 1
            });
            needsBoundsUpdate = true;
        }
        rect.set({
            selectable: false,
            evented: false,
            strokeUniform: true
        });
    }

    if (needsBoundsUpdate) safeAddWithUpdate(zone);
    zone.setCoords();
}

const getZoneMetrics = (zone: any) => {
    if (!zone) return null;
    
    // CRITICAL: Prefer _zoneWidth/_zoneHeight when available (persisted dimensions)
    // This ensures correct layout after reload even if Fabric bounds are not yet updated
    let width = 0;
    let height = 0;
    
    if (typeof zone._zoneWidth === 'number' && zone._zoneWidth > 0 &&
        typeof zone._zoneHeight === 'number' && zone._zoneHeight > 0) {
        width = zone._zoneWidth;
        height = zone._zoneHeight;
    } else {
        const rect = getZoneRect(zone);
        const rectScaleX = rect?.scaleX ?? 1;
        const rectScaleY = rect?.scaleY ?? 1;
        const baseWidth = rect?.width ? rect.width * rectScaleX : zone.width;
        const baseHeight = rect?.height ? rect.height * rectScaleY : zone.height;
        const scaleX = Math.abs(zone.scaleX ?? 1);
        const scaleY = Math.abs(zone.scaleY ?? 1);
        width = baseWidth ? baseWidth * scaleX : zone.getScaledWidth?.() ?? 0;
        height = baseHeight ? baseHeight * scaleY : zone.getScaledHeight?.() ?? 0;
    }
    
    if (!width || !height) {
        const fallback = zone.getBoundingRect ? zone.getBoundingRect(true) : { left: zone.left ?? 0, top: zone.top ?? 0, width: 0, height: 0 };
        return {
            left: fallback.left,
            top: fallback.top,
            width: fallback.width,
            height: fallback.height,
            centerX: fallback.left + (fallback.width / 2),
            centerY: fallback.top + (fallback.height / 2)
        };
    }
    const center = zone.getCenterPoint ? zone.getCenterPoint() : { x: zone.left ?? 0, y: zone.top ?? 0 };
    return {
        left: center.x - (width / 2),
        top: center.y - (height / 2),
        width,
        height,
        centerX: center.x,
        centerY: center.y
    };
}

const getResolvedZoneFrameId = (zone: any): string | undefined => {
    if (!canvas.value || !zone) return undefined;

    let frameId = String((zone as any).parentFrameId || '').trim() || undefined;
    if (frameId && !getFrameById(frameId)) {
        frameId = undefined;
    }

    if (!frameId) {
        const detected = findFrameUnderObject(zone);
        if (detected && detected._customId) {
            frameId = String(detected._customId);
        }
    }

    if ((zone as any).parentFrameId !== frameId) {
        (zone as any).parentFrameId = frameId;
    }

    return frameId;
}

const applyCardFrameBinding = (card: any, frameId?: string) => {
    if (!card || card.excludeFromExport || card.isFrame) return;
    const isCardLike = !!(card.isSmartObject || card.isProductCard || isLikelyProductCard(card));
    if (!isCardLike) return;

    const nextFrameId = String(frameId || '').trim() || undefined;
    if ((card as any).parentFrameId !== nextFrameId) {
        (card as any).parentFrameId = nextFrameId;
    }

    // Product cards are never clipped by frame clipPath.
    const hadClip = !!card.clipPath || !!(card as any)._frameClipOwner;
    if (card.clipPath) {
        card.set?.('clipPath', null);
    }
    if ((card as any)._frameClipOwner) {
        delete (card as any)._frameClipOwner;
    }
    if (hadClip) {
        card.set?.('dirty', true);
        card.setCoords?.();
    }
}

const syncZoneCardFrameBindings = (zone: any, cards?: any[]) => {
    if (!zone) return;
    const zoneFrameId = getResolvedZoneFrameId(zone);
    const list = Array.isArray(cards) ? cards : getZoneChildren(zone);
    list.forEach((card: any) => applyCardFrameBinding(card, zoneFrameId));
}

const getZoneChildCandidates = (zone: any) => {
    if (!canvas.value || !zone) return [];
    const topLevel = canvas.value.getObjects() || [];
    const isCandidateGroup = (o: any) => {
        if (!o || o === zone) return false;
        if (o.visible === false) return false;
        if ((o as any).excludeFromExport) return false;
        if ((o as any).isFrame) return false;
        if (isLikelyProductZone(o)) return false;
        if (o.type !== 'group' || typeof o.getObjects !== 'function') return false;
        // Exclude only bare price labels, not misnamed legacy product cards.
        if (isStandalonePriceGroup(o)) return false;
        return true;
    };

    const topCandidates = topLevel.filter(isCandidateGroup);
    if (topCandidates.length > 0) return topCandidates;

    // Legacy fallback: in rare old states cards can be nested. Scan only group nodes.
    const deepCandidates: any[] = [];
    const seen = new Set<any>();
    const stack = [...topLevel];
    while (stack.length > 0) {
        const cur = stack.pop();
        if (!cur || seen.has(cur)) continue;
        seen.add(cur);
        if (cur.type === 'group' && typeof cur.getObjects === 'function') {
            if (isCandidateGroup(cur)) deepCandidates.push(cur);
            const children = cur.getObjects() || [];
            for (const child of children) {
                if (child?.type === 'group') stack.push(child);
            }
        }
    }
    return deepCandidates;
};

const getZoneChildren = (zone: any) => {
    if (!canvas.value || !zone) return [];
    const candidates = getZoneChildCandidates(zone);

    const zoneBounds = getZoneMetrics(zone) ?? zone.getBoundingRect(true);
    const zoneFrameId = getResolvedZoneFrameId(zone);
    const zoneId = String((zone as any)?._customId || '').trim();
    const margin = (() => {
        const pad = typeof (zone as any)._zonePadding === 'number' ? (zone as any)._zonePadding : 20;
        const base = Math.min(zoneBounds.width || 0, zoneBounds.height || 0);
        // Small tolerance to keep legacy cards attached after reload (prevents "zone moves alone").
        return Math.max(60, Math.min(220, pad + base * 0.12));
    })();
    
    const normalizeLegacyCard = (o: any, explicitCard: boolean) => {
        if (!explicitCard) {
            // Upgrade legacy card objects (old saves) so the rest of the engine can rely on flags.
            o.isProductCard = true;
            o.isSmartObject = true;
        }

        // Always normalize interactivity for cards (legacy and explicit cards alike).
        o.subTargetCheck = true;
        o.interactive = true;
        o.selectable = true;
        o.evented = true;

        // Ensure inner elements are selectable with controls
        if (typeof o.getObjects === 'function') {
            o.getObjects().forEach((child: any) => {
                const n = String(child?.name || '');
                const isBackground = n === 'offerBackground' || n === 'price_bg' || n === 'price_bg_image' || n === 'splash_image';
                child.selectable = !isBackground;
                child.evented = !isBackground;
                child.hasControls = !isBackground;
                child.hasBorders = !isBackground;
            });
        }
        if (typeof o.setCoords === 'function') o.setCoords();
    };

    const explicitBound: any[] = [];
    const slotBound: any[] = [];
    const legacyCandidates: any[] = [];

    const hasStrongCardSignature = (o: any) => {
        if (!o || typeof o.getObjects !== 'function') return false;
        const cw = Number((o as any)?._cardWidth);
        const ch = Number((o as any)?._cardHeight);
        if (Number.isFinite(cw) && cw > 0 && Number.isFinite(ch) && ch > 0) return true;

        const children = o.getObjects() || [];
        if (!Array.isArray(children) || children.length === 0) return false;

        const hasOfferBg = children.some((c: any) => String(c?.name || '') === 'offerBackground');
        if (hasOfferBg) return true;

        const hasPriceGroup = children.some((c: any) => String(c?.type || '').toLowerCase() === 'group' && String(c?.name || '') === 'priceGroup');
        const hasImage = children.some((c: any) => String(c?.type || '').toLowerCase() === 'image');
        return hasPriceGroup && hasImage;
    };

    const canBelongToZone = (o: any) => {
        const objBounds = o.getBoundingRect();
        const isInside =
            objBounds.left >= zoneBounds.left &&
            objBounds.top >= zoneBounds.top &&
            objBounds.left + objBounds.width <= zoneBounds.left + zoneBounds.width &&
            objBounds.top + objBounds.height <= zoneBounds.top + zoneBounds.height;

        const center = typeof o.getCenterPoint === 'function'
            ? o.getCenterPoint()
            : { x: (o.left ?? 0), y: (o.top ?? 0) };
        const nearInside =
            center.x >= (zoneBounds.left - margin) &&
            center.x <= (zoneBounds.left + zoneBounds.width + margin) &&
            center.y >= (zoneBounds.top - margin) &&
            center.y <= (zoneBounds.top + zoneBounds.height + margin);

        let intersects = false;
        try {
            intersects = !!zone.intersectsWithObject(o);
        } catch {
            intersects = false;
        }

        return isInside || intersects || nearInside;
    };

    candidates.forEach((o: any) => {
        const explicitCard = !!(o.isProductCard || o.isSmartObject || String(o.name || '').startsWith('product-card'));
        const likelyCard = explicitCard ? true : isLikelyProductCard(o);
        if (!likelyCard) return;

        const boundId = String((o as any)?.parentZoneId || '').trim();
        if (zoneId && boundId && boundId === zoneId) {
            normalizeLegacyCard(o, explicitCard);
            applyCardFrameBinding(o, zoneFrameId);
            explicitBound.push(o);
            return;
        }

        // Keep deterministic binding when slot metadata exists (important after undo/reload).
        const slotZoneId = String((o as any)?._zoneSlot?.zoneId || '').trim();
        if (zoneId && slotZoneId && slotZoneId === zoneId) {
            normalizeLegacyCard(o, explicitCard);
            o.parentZoneId = zoneId;
            applyCardFrameBinding(o, zoneFrameId);
            slotBound.push(o);
            return;
        }

        // Hard stop: a card already bound to ANOTHER zone must never be auto-captured here.
        if ((boundId && boundId !== zoneId) || (slotZoneId && slotZoneId !== zoneId)) {
            return;
        }

        legacyCandidates.push(o);
    });

    // Recover unbound but strongly-identifiable product cards that are still inside/near the zone.
    // This keeps old/corrupted layouts responsive after resize without stealing objects from other zones.
    const recoveredUnbound = legacyCandidates.filter((o: any) => {
        const boundId = String((o as any)?.parentZoneId || '').trim();
        const slotZoneId = String((o as any)?._zoneSlot?.zoneId || '').trim();
        if (boundId || slotZoneId) return false;
        if (!hasStrongCardSignature(o)) return false;
        if (!canBelongToZone(o)) return false;

        const explicitCard = !!(o.isProductCard || o.isSmartObject || String(o.name || '').startsWith('product-card'));
        normalizeLegacyCard(o, explicitCard);
        o.parentZoneId = zoneId || zone._customId;
        applyCardFrameBinding(o, zoneFrameId);
        return true;
    });

    // If the zone already has explicit bindings, keep strict mode but include recovered unbound cards.
    // This prevents false positives while fixing detached cards from legacy/buggy states.
    if (explicitBound.length > 0 || slotBound.length > 0) {
        return [...explicitBound, ...slotBound, ...recoveredUnbound];
    }

    // Legacy rescue mode: only when no explicit cards exist for the zone.
    return legacyCandidates.filter((o: any) => {
        // Legacy rescue should only capture truly unbound cards.
        const boundId = String((o as any)?.parentZoneId || '').trim();
        const slotZoneId = String((o as any)?._zoneSlot?.zoneId || '').trim();
        if (boundId || slotZoneId) return false;
        if (canBelongToZone(o)) {
            const explicitCard = !!(o.isProductCard || o.isSmartObject || String(o.name || '').startsWith('product-card'));
            normalizeLegacyCard(o, explicitCard);
            o.parentZoneId = zoneId || zone._customId;
            applyCardFrameBinding(o, zoneFrameId);
            return true;
        }

        return false;
    });
}

const moveZoneChildren = (zone: any, dx: number, dy: number, children?: any[]) => {
    if (!zone || (!dx && !dy)) return;
    const list = children && children.length > 0 ? children : getZoneChildren(zone);
    list.forEach((child: any) => {
        child.set({
            left: child.left + dx,
            top: child.top + dy
        });
        child.setCoords();
    });
}

const normalizeZoneScale = (zone: any) => {
    if (!zone || !zone.getObjects) return;
    if (zone.scaleX === 1 && zone.scaleY === 1) return;
    applyZoneScaleToRect(zone);
}

const applyZoneScaleToRect = (zone: any, minSize = 60) => {
    if (!zone || !zone.getObjects) return null;
    const zoneRect = zone.getObjects().find((o: any) => o.type === 'rect');
    if (!zoneRect) return null;

    const nextWidth = Math.max(minSize, Math.abs(zone.getScaledWidth?.() ?? 0));
    const nextHeight = Math.max(minSize, Math.abs(zone.getScaledHeight?.() ?? 0));
    if (!nextWidth || !nextHeight) return null;

    zoneRect.set({
        width: nextWidth,
        height: nextHeight,
        scaleX: 1,
        scaleY: 1
    });

    zone.set({
        scaleX: 1,
        scaleY: 1,
        flipX: false,
        flipY: false
    });

    safeAddWithUpdate(zone);
    zone.setCoords();
    zone._zoneWidth = nextWidth;
    zone._zoneHeight = nextHeight;
    return { width: nextWidth, height: nextHeight };
}

/**
 * Normaliza o scale de retângulos após redimensionamento.
 * Converte scaleX/scaleY em width/height reais e preserva o border-radius proporcional.
 * Igual ao Figma: usa dimensões reais em vez de scale para evitar distorção dos cantos.
 */
const normalizeRectScale = (obj: any, minSize = 1) => {
    if (!obj) return;

    // Apenas para retângulos (rect, Rect)
    if (obj.type !== 'rect') return;

    // Se não há scale para normalizar, retorna
    if (obj.scaleX === 1 && obj.scaleY === 1) return;

    const newWidth = Math.max(minSize, Math.abs(obj.getScaledWidth?.() ?? (obj.width * obj.scaleX)));
    const newHeight = Math.max(minSize, Math.abs(obj.getScaledHeight?.() ?? (obj.height * obj.scaleY)));

    // Calcular o novo border-radius proporcional, limitado a metade da menor dimensão
    // Isso evita cantos quebrados e mantém a aparência visual consistente
    const originalRx = obj.rx || 0;
    const originalRy = obj.ry || 0;

    // Fator de escala aplicado
    const scaleFatorX = newWidth / obj.width;
    const scaleFatorY = newHeight / obj.height;

    // Novo radius proporcional (média dos fatores de escala para manter aparência)
    const newRadius = Math.min(
        (originalRx * Math.max(scaleFatorX, scaleFatorY)),
        newWidth / 2,
        newHeight / 2
    );

    obj.set({
        width: newWidth,
        height: newHeight,
        rx: newRadius,
        ry: newRadius,
        scaleX: 1,
        scaleY: 1,
        flipX: false,
        flipY: false
    });

    obj.setCoords();
    return { width: newWidth, height: newHeight, rx: newRadius, ry: newRadius };
};

/**
 * Normaliza o scale de grupos que contêm retângulos com border-radius.
 * Percorre todos os objetos dentro do grupo e normaliza os retângulos.
 */
const normalizeGroupRects = (group: any) => {
    if (!group || !group.getObjects || group.type !== 'group') return;

    const objects = group.getObjects();
    if (!Array.isArray(objects)) return;

    objects.forEach((obj: any) => {
        if (obj.type === 'rect') {
            normalizeRectScale(obj);
        } else if (obj.type === 'group') {
            // Recursivo para grupos aninhados
            normalizeGroupRects(obj);
        }
    });
};

const stableHash32 = (s: string): number => {
    // FNV-1a 32-bit hash (stable across sessions).
    let h = 0x811c9dc5;
    for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
    }
    return h >>> 0;
};

const getZoneHighlightPredicate = (zone: any, cards: any[]) => {
    const count = Array.isArray(cards) ? cards.length : 0;
    const rawCount = Number((zone as any)?.highlightCount ?? 0);
    const want = Math.max(0, Math.min(count, Math.round(Number.isFinite(rawCount) ? rawCount : 0)));
    const rawMult = Number((zone as any)?.highlightHeight ?? 1);
    const mult = Math.max(1, Math.min(4, Number.isFinite(rawMult) ? rawMult : 1));
    const pos = String((zone as any)?.highlightPos ?? 'first').toLowerCase();

    if (!want || mult <= 1) {
        return { count: 0, mult: 1, isHighlighted: (_card: any, _index: number) => false };
    }

    // Random = stable per-zone/per-card identity (does NOT reshuffle every relayout).
    if (pos === 'random') {
        const zoneId = String((zone as any)?._customId ?? 'zone');
        const scored = cards.map((c: any, idx: number) => {
            const id = String(c?._customId ?? c?.id ?? idx);
            return { id, score: stableHash32(`${zoneId}:${id}`) };
        });
        scored.sort((a, b) => a.score - b.score);
        const picked = scored.slice(0, want);
        const idSet = new Set<string>(picked.map(p => p.id));
        return {
            count: want,
            mult,
            isHighlighted: (card: any, index: number) => idSet.has(String(card?._customId ?? card?.id ?? index))
        };
    }

    if (pos === 'center') {
        const start = Math.max(0, Math.floor((count - want) / 2));
        const end = Math.min(count, start + want);
        return {
            count: want,
            mult,
            isHighlighted: (_card: any, index: number) => index >= start && index < end
        };
    }

    if (pos === 'last' || pos === 'bottom') {
        return {
            count: want,
            mult,
            isHighlighted: (_card: any, index: number) => index >= (count - want)
        };
    }

    // Default = first/top
    return {
        count: want,
        mult,
        isHighlighted: (_card: any, index: number) => index < want
    };
};

const recalculateZoneLayout = (zone: any, cachedChildren?: any[], opts: { save?: boolean } = {}) => {
    if (!zone || !canvas.value) return;
    const shouldSave = opts.save !== false;
    
    // 1. Find cards in zone (Use cache if available for performance)
    const cardMap = new Map<any, any>();
    (cachedChildren || []).forEach((card: any) => {
        const key = card._customId ?? card.id ?? card;
        cardMap.set(key, card);
    });
    
    getZoneChildren(zone).forEach((card: any) => {
        const key = card._customId ?? card.id ?? card;
        cardMap.set(key, card);
    });
    
    let cards = Array.from(cardMap.values());
    
    if (cards.length === 0) return;
    
    // 2. Sort by stable zone order when available, otherwise fall back to visual order.
    const hasAllOrders = cards.every((c: any) => Number.isFinite((c as any)._zoneOrder));
    if (hasAllOrders) {
        cards.sort((a: any, b: any) => ((a as any)._zoneOrder ?? 0) - ((b as any)._zoneOrder ?? 0));
    } else {
        cards.sort((a: any, b: any) => {
            const rowDiff = (a.top ?? 0) - (b.top ?? 0);
            if (Math.abs(rowDiff) > 50) return rowDiff; // Same row tolerance
            return (a.left ?? 0) - (b.left ?? 0);
        });
        cards.forEach((c: any, i: number) => ((c as any)._zoneOrder = i));
    }
    
    // 3. Setup Grid Vars
    const zoneRect = getZoneMetrics(zone) ?? zone.getBoundingRect(true);
    const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));
    const minSlotSize = 12;

    const rawPadding = Math.max(0, Number(typeof zone._zonePadding === 'number' ? zone._zonePadding : (zone.padding ?? 20)) || 0);
    const rawGapX = Math.max(0, Number(zone.gapHorizontal ?? rawPadding) || 0);
    const rawGapY = Math.max(0, Number(zone.gapVertical ?? rawPadding) || 0);
    // Default to `fill` so the grid always uses the full zone width (no empty space).
    const lastRowBehavior = zone.lastRowBehavior || 'fill'; 
    const layoutDirection = zone.layoutDirection || 'horizontal';
    const stylesToApply: Partial<GlobalStyles> = getZoneGlobalStyles(zone);
    const zoneFrameId = getResolvedZoneFrameId(zone);
    
    const count = cards.length;
    
    const zoneConfig: ProductZone = {
        x: zoneRect.left,
        y: zoneRect.top,
        width: zoneRect.width,
        height: zoneRect.height,
        padding: rawPadding,
        gapHorizontal: rawGapX,
        gapVertical: rawGapY,
        columns: typeof zone.columns === 'number' ? zone.columns : 0,
        rows: typeof zone.rows === 'number' ? zone.rows : 0,
        cardAspectRatio: zone.cardAspectRatio ?? 'auto',
        lastRowBehavior: lastRowBehavior
    };
    
    const { cols: computedCols, rows: computedRows } = calculateGridLayout(zoneConfig, count);
    const cols = Math.max(1, Math.round(Number(computedCols) || 1));
    const rows = Math.max(1, Math.round(Number(computedRows) || 1));
    const effectiveRows = Math.max(rows, Math.ceil(count / cols));

    // Fit spacing to available area so cards never overflow the product zone.
    const fitSpacing = (colCount: number, rowCount: number) => {
        let padding = rawPadding;
        let gapX = rawGapX;
        let gapY = rawGapY;

        if (colCount > 1) {
            const maxGapForMinWidth = (zoneRect.width - (padding * 2) - (colCount * minSlotSize)) / (colCount - 1);
            gapX = clamp(gapX, 0, Math.max(0, maxGapForMinWidth));
        }
        if (rowCount > 1) {
            const maxGapForMinHeight = (zoneRect.height - (padding * 2) - (rowCount * minSlotSize)) / (rowCount - 1);
            gapY = clamp(gapY, 0, Math.max(0, maxGapForMinHeight));
        }

        const maxPadByWidth = (zoneRect.width - (colCount * minSlotSize) - ((colCount - 1) * gapX)) / 2;
        const maxPadByHeight = (zoneRect.height - (rowCount * minSlotSize) - ((rowCount - 1) * gapY)) / 2;
        const padLimit = Math.max(0, Math.min(maxPadByWidth, maxPadByHeight));
        padding = clamp(padding, 0, padLimit);

        const usableW = Math.max(2, zoneRect.width - (padding * 2));
        const usableH = Math.max(2, zoneRect.height - (padding * 2));

        if (colCount > 1) {
            const maxGapByUsableWidth = (usableW - (colCount * minSlotSize)) / (colCount - 1);
            gapX = clamp(gapX, 0, Math.max(0, maxGapByUsableWidth));
        }
        if (rowCount > 1) {
            const maxGapByUsableHeight = (usableH - (rowCount * minSlotSize)) / (rowCount - 1);
            gapY = clamp(gapY, 0, Math.max(0, maxGapByUsableHeight));
        }

        return {
            padding,
            gapX,
            gapY,
            usableW,
            usableH,
            startX: zoneRect.left + padding,
            startY: zoneRect.top + padding
        };
    };

    const spacing = fitSpacing(cols, effectiveRows);
    const padding = spacing.padding;
    const gapX = spacing.gapX;
    const gapY = spacing.gapY;
    const usableW = spacing.usableW;
    const usableH = spacing.usableH;
    
    // 4. Layout Execution
    const startX = spacing.startX;
    const startY = spacing.startY;
    const maxSlotX = zoneRect.left + zoneRect.width - padding;
    const maxSlotY = zoneRect.top + zoneRect.height - padding;

    // Helper: resize & position a single card in its slot
    const placeCard = (card: any, x: number, y: number, w: number, h: number, order: number) => {
        const slotW = Math.max(2, w);
        const slotH = Math.max(2, h);
        const boundedX = clamp(x, startX, Math.max(startX, maxSlotX - slotW));
        const boundedY = clamp(y, startY, Math.max(startY, maxSlotY - slotH));
        card.parentZoneId = zone._customId;
        applyCardFrameBinding(card, zoneFrameId);
        card._zoneOrder = order;
        (card as any)._zoneSlot = { zoneId: zone._customId, left: boundedX, top: boundedY, width: slotW, height: slotH };
        const cx = boundedX + slotW / 2;
        const cy = boundedY + slotH / 2;
        if (card.isSmartObject || card.name?.startsWith('product-card')) {
            resizeSmartObject(card, slotW, slotH, stylesToApply);
            card.set({ left: cx, top: cy, originX: 'center', originY: 'center', scaleX: 1, scaleY: 1 });
        } else {
            card.set({ left: cx, top: cy, originX: 'center', originY: 'center', scaleX: slotW / (card.width || 1), scaleY: slotH / (card.height || 1) });
        }
        card.setCoords();
    };

    // Highlight detection
    const hl = getZoneHighlightPredicate(zone, cards);

    if (hl.count > 0 && hl.mult > 1) {
        // ══════════════ FEATURED LAYOUT ══════════════
        // Highlighted cards get their own COLUMN SECTION (spanning full height).
        // Normal cards fill the remaining width as a sub-grid.
        const hlCards: any[] = [];
        const normCards: any[] = [];
        cards.forEach((card, i) => {
            if (hl.isHighlighted(card, i)) hlCards.push(card);
            else normCards.push(card);
        });

        // Edge case: all cards highlighted → fall through to standard grid
        if (normCards.length > 0) {
            const rawHighlightPos = String((zone as any)?.highlightPos ?? 'first').toLowerCase();
            const useHorizontalFeatured =
                rawHighlightPos === 'top' ||
                rawHighlightPos === 'bottom' ||
                rawHighlightPos === 'center';

            if (useHorizontalFeatured) {
                const normalCols = Math.max(1, (zone.columns && zone.columns > 0)
                    ? cols
                    : Math.max(1, Math.round(Math.sqrt(normCards.length * (usableW / Math.max(1, usableH)))))
                );

                const normRowCount = Math.max(1, Math.ceil(normCards.length / normalCols));
                const totalGapsY = normRowCount * gapY; // normal rows + separator between sections
                const totalUnitsY = normRowCount + hl.mult;
                const unitH = (usableH - totalGapsY) / Math.max(1, totalUnitsY);

                if (Number.isFinite(unitH) && unitH > 2) {
                    const hlSectionH = unitH * hl.mult;
                    const normSectionH = usableH - hlSectionH - gapY;
                    const normCardH = (normSectionH - (Math.max(0, normRowCount - 1) * gapY)) / Math.max(1, normRowCount);
                    const baseNormCellW = (usableW - ((normalCols - 1) * gapX)) / Math.max(1, normalCols);

                    const highlightCols = Math.max(1, Math.min(cols, hlCards.length));
                    const highlightRows = Math.max(1, Math.ceil(hlCards.length / highlightCols));
                    const highlightCellW = (usableW - ((highlightCols - 1) * gapX)) / Math.max(1, highlightCols);
                    const highlightCellH = (hlSectionH - (Math.max(0, highlightRows - 1) * gapY)) / Math.max(1, highlightRows);

                    const canApplyHorizontalFeatured =
                        normSectionH > 2 &&
                        normCardH > 2 &&
                        baseNormCellW > 2 &&
                        highlightCellW > 2 &&
                        highlightCellH > 2;

                    if (canApplyHorizontalFeatured) {
                        const placeAtBottom = rawHighlightPos === 'bottom';
                        const centerHighlightRows = rawHighlightPos === 'center';

                        const hlSectionY = placeAtBottom
                            ? (startY + usableH - hlSectionH)
                            : startY;
                        const normSectionY = placeAtBottom
                            ? startY
                            : (hlSectionY + hlSectionH + gapY);

                        hlCards.forEach((card: any, i: number) => {
                            const row = Math.floor(i / highlightCols);
                            const col = i % highlightCols;
                            const isLastRow = row === highlightRows - 1;
                            const itemsInRow = isLastRow ? (hlCards.length % highlightCols || highlightCols) : highlightCols;
                            const rowW = (itemsInRow * highlightCellW) + ((itemsInRow - 1) * gapX);
                            const rowStartX = centerHighlightRows
                                ? (startX + (usableW - rowW) / 2)
                                : startX;
                            const x = rowStartX + (col * (highlightCellW + gapX));
                            const y = hlSectionY + (row * (highlightCellH + gapY));
                            placeCard(card, x, y, highlightCellW, highlightCellH, cards.indexOf(card));
                        });

                        normCards.forEach((card: any, i: number) => {
                            const col = i % normalCols;
                            const row = Math.floor(i / normalCols);
                            const isLastRow = row === normRowCount - 1;
                            const itemsInRow = isLastRow ? (normCards.length % normalCols || normalCols) : normalCols;

                            let cellW = baseNormCellW;
                            let rowGapX = gapX;
                            let rowStartX = startX;

                            if (isLastRow && itemsInRow < normalCols) {
                                if ((lastRowBehavior === 'fill' || lastRowBehavior === 'stretch') && itemsInRow >= 1) {
                                    cellW = (usableW - ((itemsInRow - 1) * gapX)) / Math.max(1, itemsInRow);
                                    rowGapX = gapX;
                                    rowStartX = startX;
                                } else {
                                    const rowW = (itemsInRow * cellW) + ((itemsInRow - 1) * rowGapX);
                                    if (lastRowBehavior === 'center') rowStartX = startX + (usableW - rowW) / 2;
                                    else if (lastRowBehavior === 'left') rowStartX = startX;
                                }
                            }

                            const x = rowStartX + (col * (cellW + rowGapX));
                            const y = normSectionY + (row * (normCardH + gapY));
                            placeCard(card, x, y, cellW, normCardH, cards.indexOf(card));
                        });

                        canvas.value.requestRenderAll();
                        if (shouldSave) saveCurrentState();
                        return;
                    }
                }
            }

            const hlOnLeft = rawHighlightPos !== 'last';

            // Column distribution for normal section
            const normalCols = Math.max(1, (zone.columns && zone.columns > 0)
                ? cols - 1
                : Math.max(1, Math.round(Math.sqrt(normCards.length * (usableW / Math.max(1, usableH)))))
            );

            // Width: highlight section = hl.mult units, normal cols = 1 unit each
            // Total gaps: 1 between hl and normal + (normalCols - 1) between normal cols = normalCols gaps
            const totalGapsX = normalCols * gapX;
            const totalUnits = normalCols + hl.mult;
            const unitW = (usableW - totalGapsX) / Math.max(1, totalUnits);

            if (Number.isFinite(unitW) && unitW > 2) {
                const hlW = unitW * hl.mult;
                const normSectionW = usableW - hlW - gapX;

                // Heights (each section fills full height independently)
                const hlRowCount = hlCards.length;
                const hlGapH = Math.max(0, hlRowCount - 1) * gapY;
                const hlCardH = (usableH - hlGapH) / Math.max(1, hlRowCount);

                const normRowCount = Math.max(1, Math.ceil(normCards.length / normalCols));
                const normGapH = Math.max(0, normRowCount - 1) * gapY;
                const normCardH = (usableH - normGapH) / normRowCount;
                const baseNormCellW = (normSectionW - ((normalCols - 1) * gapX)) / Math.max(1, normalCols);

                const canApplyFeatured =
                    normSectionW > 2 &&
                    hlCardH > 2 &&
                    normCardH > 2 &&
                    baseNormCellW > 2;

                if (canApplyFeatured) {
                    // Position highlight cards (full-height column section)
                    const hlSectionX = hlOnLeft ? startX : (startX + usableW - hlW);
                    hlCards.forEach((card: any, i: number) => {
                        const y = startY + i * (hlCardH + gapY);
                        placeCard(card, hlSectionX, y, hlW, hlCardH, cards.indexOf(card));
                    });

                    // Position normal cards in sub-grid
                    const normSectionX = hlOnLeft ? (startX + hlW + gapX) : startX;

                    normCards.forEach((card: any, i: number) => {
                        const col = i % normalCols;
                        const row = Math.floor(i / normalCols);

                        // Last row fill
                        const isLastRow = row === normRowCount - 1;
                        const itemsInRow = isLastRow ? (normCards.length % normalCols || normalCols) : normalCols;
                        // Match standard grid semantics:
                        // - fill: keep card size, expand gaps (but clamp to avoid huge "holes" on sparse last rows)
                        // - stretch: stretch cards
                        // - center: keep card size, center row
                        let cellW = baseNormCellW;
                        let rowGapX = gapX;
                        let rowStartX = normSectionX;
                        if (isLastRow && itemsInRow < normalCols) {
                            // For a single item, "fill" should actually fill the entire row width.
                            // Expanding gaps is impossible with 1 item, so we span the full section.
                            if (itemsInRow === 1 && (lastRowBehavior === 'fill' || lastRowBehavior === 'stretch')) {
                                cellW = normSectionW;
                                rowGapX = 0;
                                rowStartX = normSectionX;
                            }
                            if ((lastRowBehavior === 'fill' || lastRowBehavior === 'stretch') && itemsInRow > 1) {
                                // "fill" in sparse last rows: prefer stretching cards instead of exploding gaps.
                                cellW = (normSectionW - ((itemsInRow - 1) * gapX)) / Math.max(1, itemsInRow);
                                rowGapX = gapX;
                                rowStartX = normSectionX;
                            }
                            const rowW = (itemsInRow * cellW) + ((itemsInRow - 1) * rowGapX);
                            const shouldCenter =
                                lastRowBehavior === 'center' ||
                                (itemsInRow === 1 && (lastRowBehavior === 'fill' || lastRowBehavior === 'stretch'));
                            if (shouldCenter) {
                                rowStartX = normSectionX + (normSectionW - rowW) / 2;
                            } else if (lastRowBehavior === 'left') {
                                rowStartX = normSectionX;
                            }
                        }

                        let x = rowStartX + col * (cellW + rowGapX);

                        const y = startY + row * (normCardH + gapY);
                        placeCard(card, x, y, cellW, normCardH, cards.indexOf(card));
                    });

                    canvas.value.requestRenderAll();
                    if (shouldSave) saveCurrentState();
                    return;
                }
            }
        }
    }

    // ══════════════ STANDARD GRID LAYOUT ══════════════
    // For vertical layout, compute the effective number of columns used (otherwise we can
    // end up with "empty columns" to the right when count < cols * rows).
    const gridCols = layoutDirection === 'vertical'
        ? Math.max(1, Math.ceil(count / Math.max(1, effectiveRows)))
        : cols;

    const totalGapW = (gridCols - 1) * gapX;
    const totalGapH = (effectiveRows - 1) * gapY;
    const itemW = (usableW - totalGapW) / gridCols;
    const itemH = (usableH - totalGapH) / effectiveRows;

    if (!Number.isFinite(itemW) || !Number.isFinite(itemH) || itemW <= 0 || itemH <= 0) {
        return;
    }

    cards.forEach((card: any, index: number) => {
        const col = layoutDirection === 'vertical'
            ? Math.floor(index / Math.max(1, effectiveRows))
            : (index % cols);
        const row = layoutDirection === 'vertical'
            ? (index % Math.max(1, effectiveRows))
            : Math.floor(index / cols);

        // Vertical flow: last column can be incomplete (itemsInCol < effectiveRows)
        // Horizontal flow: last row can be incomplete (itemsInRow < cols)
        const isLastRow = layoutDirection !== 'vertical' && row === effectiveRows - 1;
        const itemsInRow = isLastRow ? (count % cols || cols) : cols;
        const isLastCol = layoutDirection === 'vertical' && col === (gridCols - 1);
        const itemsInCol = isLastCol ? (count % effectiveRows || effectiveRows) : effectiveRows;

        // Handle vertical "last column" alignment/fill (analogous to last-row behavior).
        if (layoutDirection === 'vertical' && isLastCol && itemsInCol < effectiveRows) {
            let colItemH = itemH;
            let colGapY = gapY;
            let colStartY = startY;

            if ((lastRowBehavior === 'fill' || lastRowBehavior === 'stretch') && itemsInCol >= 1) {
                // Fill the full height by stretching items (gaps stay consistent).
                colItemH = (usableH - ((itemsInCol - 1) * gapY)) / Math.max(1, itemsInCol);
                colGapY = gapY;
                colStartY = startY;
            } else if (lastRowBehavior === 'center') {
                const colH = (itemsInCol * colItemH) + ((itemsInCol - 1) * colGapY);
                colStartY = startY + (usableH - colH) / 2;
            } else if (lastRowBehavior === 'left') {
                // Treat "left" as "top" for vertical flow.
                colStartY = startY;
            }

            let x = startX + (col * (itemW + gapX));
            let y = colStartY + (row * (colItemH + colGapY));

            x = clamp(x, startX, Math.max(startX, maxSlotX - itemW));
            y = clamp(y, startY, Math.max(startY, maxSlotY - colItemH));
            placeCard(card, x, y, itemW, colItemH, index);
            return;
        }

        // Last row handling:
        // - center: keep card size, center the row
        // - fill: keep card size, expand gaps to occupy full width (preserves label/card proportions)
        // - stretch: stretch card width to occupy full width
        // - left: keep card size, align left
                        let rowItemW = itemW;
                        let rowGapX = gapX;
        let rowStartX = startX;

        if (isLastRow && itemsInRow < cols) {
            if ((lastRowBehavior === 'fill' || lastRowBehavior === 'stretch') && itemsInRow >= 1) {
                // Prefer stretching cards (consistent gap) instead of creating huge gaps between items.
                rowItemW = (usableW - ((itemsInRow - 1) * gapX)) / Math.max(1, itemsInRow);
                rowGapX = gapX;
                rowStartX = startX;
            } else {
                const rowW = (itemsInRow * rowItemW) + ((itemsInRow - 1) * rowGapX);
                const shouldCenter = lastRowBehavior === 'center';
                if (shouldCenter) rowStartX = startX + (usableW - rowW) / 2;
                else if (lastRowBehavior === 'left') rowStartX = startX;
            }
        }

        let x = rowStartX + (col * (rowItemW + rowGapX));
        let y = startY + (row * (itemH + gapY));

        x = clamp(x, startX, Math.max(startX, maxSlotX - rowItemW));
        y = clamp(y, startY, Math.max(startY, maxSlotY - itemH));
        placeCard(card, x, y, rowItemW, itemH, index);
    });

    canvas.value.requestRenderAll();
    if (shouldSave) saveCurrentState();
}

const rehydrateCanvasZones = (opts: { relayout?: boolean; applyZoneStyles?: boolean } = {}) => {
    if (!canvas.value) return;
    const relayout = opts.relayout !== false;
    const applyZoneStyles = opts.applyZoneStyles !== false;

    const prevHistory = isHistoryProcessing.value;
    isHistoryProcessing.value = true;
    try {
        let objs = canvas.value.getObjects();

        // Ensure IDs exist (used for parentZoneId mapping and selection)
        objs.forEach((o: any) => {
            if (!o._customId) o._customId = Math.random().toString(36).substr(2, 9);
        });

        // CRITICAL: Clear clipPath from all product zones to prevent rendering errors
        // Product zones should not have clipPath as cards are added separately to canvas
        objs.forEach((o: any) => {
            if (isMisnamedProductCardGroup(o)) {
                const currentLayerName = String((o as any)?.layerName || '').trim();
                const repairedName = currentLayerName && currentLayerName !== 'priceGroup'
                    ? currentLayerName
                    : 'product-card';
                o.name = repairedName;
                if (!currentLayerName || currentLayerName === 'priceGroup') {
                    (o as any).layerName = repairedName;
                }
            }
            if (o.clipPath && (o.isGridZone || o.isProductZone || o.name === 'gridZone' || o.name === 'productZoneContainer')) {
                o.clipPath = null;
            }
            // CRITICAL: Ensure all remaining clipPaths have _objects initialized
            // This prevents "forEach of undefined" errors in fabric.js createClipPathLayer
            if (o.clipPath && o.clipPath._objects === undefined) {
                o.clipPath._objects = [];
            }

            // CRITICAL: Normalize product cards to Canva-like behavior:
            // - Default: select/move the whole card (subTargetCheck OFF)
            // - Double click: enable deep select for inner elements (handled elsewhere)
            // Also supports legacy projects where flags were not serialized yet (heuristic-based detection).
            const isCardLike =
                (o.isProductCard || o.isSmartObject || isLikelyProductCard(o)) &&
                o.type === 'group' &&
                !isLikelyPriceGroupObject(o);
            if (isCardLike) {
                if (!o.isProductCard && !o.isSmartObject && isLikelyProductCard(o)) {
                    o.isProductCard = true;
                    o.isSmartObject = true;
                }

                // Normalize origin to center for stable containment math.
                try {
                    const cp = typeof o.getCenterPoint === 'function'
                        ? o.getCenterPoint()
                        : { x: (o.left ?? 0), y: (o.top ?? 0) };
                    if (o.originX !== 'center' || o.originY !== 'center') {
                        o.set({ originX: 'center', originY: 'center', left: cp.x, top: cp.y });
                    }
                } catch (e) {
                    // ignore
                }
                // Single-click deep select: user can click directly on inner elements.
                if (o.subTargetCheck !== true) o.subTargetCheck = true;
                if (o.interactive !== true) o.interactive = true;
                if (o.selectable !== true) o.selectable = true;
                if (o.evented !== true) o.evented = true;
                // Ensure internal elements are selectable with controls
                if (typeof o.getObjects === 'function') {
                    o.getObjects().forEach((child: any) => {
                        const isBackground = child.name === 'offerBackground' || child.name === 'price_bg';
                        child.selectable = !isBackground;
                        child.evented = !isBackground;
                        child.hasControls = !isBackground;
                        child.hasBorders = !isBackground;
                    });
                }
            }
        });

        // Re-apply custom rendering patches (e.g. per-corner rounded rects) recursively.
        const patchTree = (o: any) => {
            if (!o) return;
            if (isRectObject(o) && o.cornerRadii) applyRectCornerRadiiPatch(o);
            // Re-apply sticker outline patch for images loaded from JSON
            if (String(o.type || '').toLowerCase() === 'image' && o.__stickerOutlineEnabled) {
                applyStickerOutlinePatch(o);
                // Images may not have their element loaded yet after loadFromJSON
                // Schedule additional retries to ensure outline is generated
                setTimeout(() => {
                    if (o.__stickerOutlineEnabled && !o.__stickerOutlineCache) {
                        applyStickerOutlinePatch(o);
                    }
                }, 1500);
                setTimeout(() => {
                    if (o.__stickerOutlineEnabled && !o.__stickerOutlineCache) {
                        applyStickerOutlinePatch(o);
                    }
                }, 4000);
            }
            if (o.type === 'group' && typeof o.getObjects === 'function') {
                o.getObjects().forEach((c: any) => patchTree(c));
            }
        };
        objs.forEach((o: any) => patchTree(o));

        const isFrameLike = (o: any) => {
            if (!o) return false;
            const nRaw = (o?.name ?? '').toString();
            const n = nRaw.toUpperCase();
            // Prefer explicit flag.
            if (o?.isFrame) return true;
            // Common legacy names.
            if (n === 'FRAME' || n === 'FRAMER' || /^FRAME\s+\d+\s*$/i.test(nRaw)) return true;
            // Heuristic for older saves where custom props were missing:
            // A Frame is a Rect with clipContent + Figma blue stroke.
            const stroke = (o?.stroke ?? '').toString().toLowerCase();
            const isRect = isRectObject(o) || o?.type === 'rect';
            if (isRect && (o?.clipContent === true || o?.clipContent === 1) && stroke === '#0d99ff') return true;
            return false;
        };

        // Frames: restore flags + clip behavior
        const frames = objs.filter((o: any) => isFrameLike(o));

        // Normalize default Frame names (Figma-like): Frame 1, Frame 2, ...
        // Only touch frames that were never explicitly renamed (no layerName) and have a generic name.
        let maxFrameN = 0;
        frames.forEach((f: any) => {
            const n = (f?.layerName || f?.name || '').toString();
            const m = /^Frame\s+(\d+)\s*$/i.exec(n);
            if (m) maxFrameN = Math.max(maxFrameN, Number(m[1] || 0));
        });
        const nextFrameName = () => `Frame ${++maxFrameN}`;
        frames.forEach((f: any) => {
            // CRITICAL: Always restore isFrame flag (even if missing from JSON)
            f.isFrame = true;
            if (typeof f.clipContent !== 'boolean') f.clipContent = true;

            // CRITICAL: Ensure frames always have originX='center' and originY='center'
            // This prevents size jumps after reload when clipPath is recalculated
            if (f.originX !== 'center') {
                f.originX = 'center';
                f.setCoords?.();
            }
            if (f.originY !== 'center') {
                f.originY = 'center';
                f.setCoords?.();
            }
            
            // Normalize name: if user renamed via layerName, keep it. Otherwise ensure proper "Frame N" name.
            if (!f.layerName) {
                const n = (f?.name || '').toString().trim();
                const isGeneric = !n || /^frame$/i.test(n) || /^framer$/i.test(n) || /^ret(â|a)ngulo$/i.test(n);
                const isNumbered = /^Frame\s+\d+\s*$/i.test(n);
                if (isGeneric) {
                    // Force normalize generic names to "Frame N"
                    f.name = nextFrameName();
                    console.log(`🔄 Frame normalizado: "${n}" → "${f.name}"`);
                } else if (!isNumbered && !/^Frame\s+\d+/.test(n)) {
                    // Custom name - leave as-is but ensure it's not empty
                    if (!f.name) f.name = nextFrameName();
                }
            } else {
                // User renamed - keep layerName, but also ensure name is set for display
                if (!f.name || /^ret(â|a)ngulo$/i.test(f.name)) {
                    f.name = f.layerName;
                }
            }
            
            // Ensure stroke is Figma blue if missing (helps with detection)
            if (!f.stroke || String(f.stroke).toLowerCase() !== '#0d99ff') {
                f.stroke = '#0d99ff';
            }
            
            if (isRectObject(f) && f.cornerRadii) applyRectCornerRadiiPatch(f);
            getOrCreateFrameClipRect(f);
        });

        const frameIds = new Set<string>(frames.map((f: any) => f._customId).filter(Boolean));
        objs.forEach((o: any) => {
            if (o?.parentFrameId && !frameIds.has(o.parentFrameId)) {
                o.parentFrameId = undefined;
                if (o._frameClipOwner) {
                    o.clipPath = null;
                    delete o._frameClipOwner;
                }
            }
        });

        // CRITICAL: Clear parentFrameId for objects that are NOT inside their supposed parent frame
        // This prevents clipping issues when objects are moved outside frames
        objs.forEach((o: any) => {
            if (!o?.parentFrameId || o?.isFrame) return;
            const frame = frames.find((f: any) => f._customId === o.parentFrameId);
            if (!frame) {
                o.parentFrameId = undefined;
                if (o._frameClipOwner) {
                    o.clipPath = null;
                    delete o._frameClipOwner;
                }
                return;
            }
            
            // Keep frame binding while object still overlaps the frame bounds.
            // Only remove binding when the object is fully outside.
            if (!isObjectIntersectingFrame(o, frame)) {
                console.log(`🔓 Removendo parentFrameId de objeto totalmente fora do frame:`, {
                    object: o.name || o._customId,
                    frame: frame.name || frame._customId
                });
                o.parentFrameId = undefined;
                if (o._frameClipOwner) {
                    o.clipPath = null;
                    delete o._frameClipOwner;
                }
            }
        });

        // Re-apply clipPaths using shared frame clip rects (prevents stale deserialized clip rects).
        objs.forEach((o: any) => {
            if (o?.parentFrameId || o?._frameClipOwner) syncObjectFrameClip(o);
        });
        frames.forEach((f: any) => syncFrameClips(f));

        // Remove legacy zone rectangles from the deprecated renderer.
        // Keeping them causes duplicate/overlapping zone behaviors after spacing edits.
        if (!LEGACY_PRODUCT_ZONE_RENDERER_ENABLED) {
            const legacyZoneRects = objs.filter((o: any) =>
                o?.type === 'rect' &&
                (
                    o?.id === 'product_zone_container' ||
                    o?.name === 'product_zone_container' ||
                    (o?.isZone === true && o?.isProductZone === true)
                )
            );
            if (legacyZoneRects.length > 0) {
                legacyZoneRects.forEach((o: any) => {
                    if (zoneObjectRef.value === o) zoneObjectRef.value = null;
                    canvas.value.remove(o);
                });
                console.log(`[rehydrateCanvasZones] Removed ${legacyZoneRects.length} legacy zone rect(s)`);
                objs = canvas.value.getObjects();
            }
        }

        const zones = objs.filter((o: any) => o?.type === 'group' && isLikelyProductZone(o));
        restoreMissingManualTemplateFlagsInCanvas(canvas.value, 'rehydrate');
        
        if (LEGACY_PRODUCT_ZONE_RENDERER_ENABLED) {
            // Legacy only: reconnect zone rect reference used by renderProductZone().
            const existingProductZoneRect = objs.find((o: any) =>
                o?.type === 'rect' &&
                (
                    o?.isProductZone === true ||
                    o?.id === 'product_zone_container' ||
                    o?.name === 'product_zone_container'
                )
            );
            if (existingProductZoneRect && !zoneObjectRef.value) {
                console.log('[rehydrateCanvasZones] Reconnecting zoneObjectRef to existing product zone from JSON');
                zoneObjectRef.value = existingProductZoneRect;
            }
        }
        
        zones.forEach((z: any) => {
            if (z.name === 'gridZone') z.isGridZone = true;
            if (z.name === 'productZoneContainer') z.isProductZone = true;
            if (!z.isGridZone && !z.isProductZone) z.isGridZone = true;
            getResolvedZoneFrameId(z);

            // CRITICAL: Clear clipPath from zone AND all its children
            if (z.clipPath) {
                z.clipPath = null;
            }
            if (typeof z.getObjects === 'function') {
                z.getObjects().forEach((child: any) => {
                    if (child.clipPath) {
                        child.clipPath = null;
                    }
                });
            }

            // Keep persisted visibility, but never show a zone whose parent frame is hidden.
            const zoneFrameId = String((z as any).parentFrameId || '').trim();
            const hiddenByFrame = !!(zoneFrameId && getFrameById(zoneFrameId)?.visible === false);
            if (typeof z.visible !== 'boolean') z.visible = true;
            if (hiddenByFrame) z.visible = false;
            if (typeof z.opacity !== 'number') z.opacity = 1;
            if (!hiddenByFrame && z.opacity === 0) z.opacity = 1;

            ensureZoneSanity(z);

            // Zones should start with no background by default.
            // Fabric defaults rect fill to black when fill is unset/undefined; we normalize using `z.backgroundColor`.
            const zr = getZoneRect(z);
            if (zr) {
                const desired = typeof (z as any).backgroundColor === 'string' ? String((z as any).backgroundColor).trim() : '';
                if (!desired || desired === 'transparent') {
                    zr.set('fill', 'transparent');
                } else {
                    zr.set('fill', desired);
                }
            }

            normalizeZoneScale(z);
            // Ensure Fabric v7 group bounds match the inner rect (prevents the "outer container" selection bug).
            safeAddWithUpdate(z);
            
            const rawZoneStyles = (z as any)._zoneGlobalStyles;
            const hasPersistedZoneStyles =
                !!rawZoneStyles &&
                typeof rawZoneStyles === 'object' &&
                !Array.isArray(rawZoneStyles) &&
                Object.keys(rawZoneStyles).length > 0;

            // Only normalize and re-apply when styles were explicitly persisted for the zone.
            // This avoids overriding card visuals on reload with fresh defaults.
            if (hasPersistedZoneStyles) {
                (z as any)._zoneGlobalStyles = normalizeGlobalStyles(rawZoneStyles as Partial<GlobalStyles>);
            }
            const zoneStyles = hasPersistedZoneStyles ? getZoneGlobalStyles(z) : null;
            if (applyZoneStyles && zoneStyles) {
                const zoneCards = getZoneChildren(z);
                if (zoneCards.length > 0) {
                    applyGlobalStylesToCards(zoneStyles, z);
                } else if (import.meta.dev) {
                    console.debug('[rehydrateCanvasZones] Zone has no cards; skipping style reapply:', z._customId);
                }
            }
        });

        // ═══════════════════════════════════════════════════════════════════
        // CRITICAL FIX: Sync composable state from persisted zone data.
        // After reload the composable starts with DEFAULT_GLOBAL_STYLES / DEFAULT_PRODUCT_ZONE.
        // The real source of truth lives on the Fabric zone object (_zoneGlobalStyles + zone props).
        // Without this sync, the ProductZoneSettings UI shows stale defaults until the user
        // manually clicks the zone (which triggers refreshSelectedRef).
        // ═══════════════════════════════════════════════════════════════════
        if (zones.length > 0) {
            const zonesWithCounts = zones.map((z: any) => ({ zone: z, count: getZoneChildren(z).length }));
            const primaryZone =
                zonesWithCounts
                    .filter((item: any) => item.count > 0)
                    .sort((a: any, b: any) => b.count - a.count)[0]?.zone ??
                zones.find((z: any) => z?.isProductZone || String(z?.name || '') === 'productZoneContainer') ??
                zones[0];

            // Sync global styles
            productZoneState.updateGlobalStyles(getZoneGlobalStyles(primaryZone));

            // Sync zone config (columns, rows, gaps, padding, layout settings, highlights)
            const pad = typeof primaryZone._zonePadding === 'number'
                ? primaryZone._zonePadding
                : (primaryZone.padding || 20);
            const zoneConfig: Partial<ProductZone> = {
                enabled: true,
                columns: primaryZone.columns || 0,
                rows: primaryZone.rows || 0,
                padding: pad,
                gapHorizontal: typeof primaryZone.gapHorizontal === 'number' ? primaryZone.gapHorizontal : pad,
                gapVertical: typeof primaryZone.gapVertical === 'number' ? primaryZone.gapVertical : pad,
                layoutDirection: primaryZone.layoutDirection || 'horizontal',
                cardAspectRatio: primaryZone.cardAspectRatio || 'auto',
                lastRowBehavior: primaryZone.lastRowBehavior || 'fill',
                verticalAlign: primaryZone.verticalAlign || 'stretch',
                highlightCount: primaryZone.highlightCount || 0,
                highlightPos: primaryZone.highlightPos || 'first',
                highlightHeight: primaryZone.highlightHeight || 1.5,
            };
            productZoneState.updateZone(zoneConfig);
            console.log('[rehydrateCanvasZones] Synced composable from zone:', { styles: true, config: zoneConfig });
        }

        const zonesById = new Map<string, any>();
        zones.forEach((z: any) => zonesById.set(z._customId, z));

        const cards = objs.filter((o: any) => (o?.isSmartObject || o?.isProductCard || isLikelyProductCard(o)) && o !== null && o !== undefined);

        const validZoneIds = new Set<string>(zones.map((z: any) => String(z?._customId || '').trim()).filter(Boolean));
        const hadAnyValidBinding = cards.some((c: any) => {
            const id = String(c?.parentZoneId || '').trim();
            return id && validZoneIds.has(id);
        });

        // CRITICAL: Ensure all product cards are visible and have valid properties
        cards.forEach((card: any) => {
            if (!card.isProductCard && !card.isSmartObject && isLikelyProductCard(card)) {
                card.isProductCard = true;
                card.isSmartObject = true;
            }
            // Keep persisted visibility, but never show cards whose frame is hidden.
            let cardFrameId = String((card as any).parentFrameId || '').trim();
            if (!cardFrameId) {
                const zoneId = String((card as any).parentZoneId || (card as any)?._zoneSlot?.zoneId || '').trim();
                const boundZone = zoneId ? zonesById.get(zoneId) : null;
                const fallbackFrameId = String((boundZone as any)?.parentFrameId || '').trim();
                if (fallbackFrameId) {
                    cardFrameId = fallbackFrameId;
                    (card as any).parentFrameId = fallbackFrameId;
                }
            }
            const cardHiddenByFrame = !!(cardFrameId && getFrameById(cardFrameId)?.visible === false);
            if (typeof card.visible !== 'boolean') card.visible = true;
            if (cardHiddenByFrame) card.visible = false;
            if (typeof card.opacity !== 'number') card.opacity = 1;
            if (!cardHiddenByFrame && card.opacity === 0) card.opacity = 1;

            // CRITICAL: Disable objectCaching on cards after reload.
            // During creation, cards get objectCaching:false, but this prop is NOT
            // in CANVAS_CUSTOM_PROPS so it reverts to true after loadFromJSON.
            // Without this, style changes via resizeSmartObject may not render.
            card.set({ objectCaching: false, statefullCache: false, dirty: true });
            // Also disable caching on nested groups (e.g. priceGroup)
            if (typeof card.getObjects === 'function') {
                card.getObjects().forEach((child: any) => {
                    if (child && child.type === 'group') {
                        child.set({ objectCaching: false, statefullCache: false, dirty: true });
                    }
                });
            }

            // Prevent random black rectangles: Fabric defaults rect fill to black when fill is unset/undefined.
            // If a card's background fill becomes invalid, restore a safe default.
            if (card.type === 'group' && typeof card.getObjects === 'function') {
                const bg = card.getObjects().find((c: any) => c?.name === 'offerBackground' && c?.type === 'rect');
                if (bg && (bg.fill === undefined || bg.fill === null || bg.fill === '')) {
                    bg.set('fill', 'transparent');
                }
            }

            // Ensure the card is properly initialized
            if (typeof card.setCoords === 'function') card.setCoords();
        });

        // Auto-repair legacy/corrupted image transforms inside product cards
        // (negative scales, flips, invalid dimensions) before reflowing zone layout.
        const repairStats = repairLegacyProductCardImageTransforms(cards, { verbose: import.meta.dev });
        if (import.meta.dev && repairStats.imagesRepaired > 0) {
            console.log('[rehydrateCanvasZones] Legacy image repair applied:', repairStats);
        }

        // Repair missing parentZoneId by intersection (helps after old history/undo states)
        const cardsWithSavedParentZone = new Set<any>();
        cards.forEach((card: any) => {
            if (!card._customId) card._customId = Math.random().toString(36).substr(2, 9);
            if (card._cardWidth == null) card._cardWidth = card.width;
            if (card._cardHeight == null) card._cardHeight = card.height;

            // If card already has a valid parentZoneId from saved data, preserve it
            if (card.parentZoneId && zonesById.has(card.parentZoneId)) {
                cardsWithSavedParentZone.add(card);
                return;
            }
            
            // Only repair cards that are missing parentZoneId
            card.parentZoneId = undefined;

            const center = typeof card.getCenterPoint === 'function'
                ? card.getCenterPoint()
                : { x: (card.left ?? 0), y: (card.top ?? 0) };

            let bestZone: any = null;
            let bestD2 = Infinity;

            for (const zone of zones) {
                if (zone.intersectsWithObject && zone.intersectsWithObject(card)) {
                    card.parentZoneId = zone._customId;
                    bestZone = null;
                    bestD2 = Infinity;
                    break;
                }

                // Fallback: distance from card center to zone rect (more robust than center-to-center).
                const zm = getZoneMetrics(zone) ?? zone.getBoundingRect(true);
                const dx = (center.x < zm.left)
                    ? (zm.left - center.x)
                    : (center.x > (zm.left + zm.width))
                        ? (center.x - (zm.left + zm.width))
                        : 0;
                const dy = (center.y < zm.top)
                    ? (zm.top - center.y)
                    : (center.y > (zm.top + zm.height))
                        ? (center.y - (zm.top + zm.height))
                        : 0;
                const d2 = (dx * dx) + (dy * dy);
                if (d2 < bestD2) {
                    bestD2 = d2;
                    bestZone = zone;
                }
            }

            // If not intersecting any zone, attach to the nearest one only if it's reasonably close.
            if (!card.parentZoneId && bestZone) {
                // If there's only one zone, legacy projects often lost the IDs entirely.
                // In that case, bind every card-like group to the single zone so the layout can be reconstructed.
                if (zones.length === 1) {
                    card.parentZoneId = bestZone._customId;
                    return;
                }

                const zm = getZoneMetrics(bestZone) ?? bestZone.getBoundingRect(true);
                const maxDim = Math.max(zm.width || 0, zm.height || 0);

                // More aggressive repair if the project has no valid bindings at all (classic "solto" legacy state).
                const base = hadAnyValidBinding ? 2.5 : 6.0;
                const maxD = Math.max(200, maxDim * base);
                if (Number.isFinite(bestD2) && bestD2 <= (maxD * maxD)) {
                    card.parentZoneId = bestZone._customId;
                }
            }
        });

        // Keep card → frame binding aligned with its zone frame.
        cards.forEach((card: any) => {
            const zoneId = String((card as any)?.parentZoneId || '').trim();
            if (!zoneId) return;
            const zone = zonesById.get(zoneId);
            if (!zone) return;
            const zoneFrameId = getResolvedZoneFrameId(zone);
            applyCardFrameBinding(card, zoneFrameId);
        });

        const zoneIdsWithCards = new Set<string>();
        cards.forEach((c: any) => {
            if (typeof c.parentZoneId === 'string') zoneIdsWithCards.add(c.parentZoneId);
        });
        zones.forEach((z: any) => {
            if (zoneIdsWithCards.has(z._customId)) z.isProductZone = true;
        });

        if (relayout) {
            zones.forEach((z: any) => {
                if (z.isProductZone || zoneIdsWithCards.has(z._customId)) {
                    try {
                        // Preserve manually-saved placements after reload.
                        // Reflow only when this zone has cards without reliable saved positions.
                        const zoneCards = cards.filter((c: any) => String((c as any).parentZoneId || '').trim() === String(z._customId || '').trim());
                        const hasAllSavedPositions =
                            zoneCards.length > 0 &&
                            zoneCards.every((c: any) =>
                                cardsWithSavedParentZone.has(c) &&
                                Number.isFinite(Number(c.left)) &&
                                Number.isFinite(Number(c.top))
                            );
                        if (!hasAllSavedPositions) {
                            recalculateZoneLayout(z);
                        }
                    } catch (err) {
                        console.warn('[rehydrateCanvasZones] Failed to relayout zone', err);
                    }
                }
            });
        }

        // Ensure zones never sit above their cards (legacy saved designs sometimes have wrong stacking order).
        // If the zone is above the cards, it intercepts clicks and prevents selecting products individually.
        try {
            const c: any = canvas.value as any;
            if (typeof c.moveTo === 'function') {
                zones.forEach((z: any) => {
                    const list = canvas.value!.getObjects();
                    const zoneIndex = list.indexOf(z);
                    if (zoneIndex < 0) return;

                    const zoneCardIndices: number[] = [];
                    for (let i = 0; i < list.length; i++) {
                        const o = list[i];
                        if (!o || o === z) continue;
                        const isCard = !!(o.isSmartObject || o.isProductCard || isLikelyProductCard(o));
                        if (!isCard) continue;
                        if ((o as any).parentZoneId === z._customId) zoneCardIndices.push(i);
                    }
                    if (!zoneCardIndices.length) return;

                    const minCardIndex = Math.min(...zoneCardIndices);
                    if (!Number.isFinite(minCardIndex)) return;

                    // Keep it above artboard-bg and frames.
                    const bgIndex = list.findIndex((o: any) => o?.id === 'artboard-bg');
                    let floorIndex = bgIndex >= 0 ? bgIndex + 1 : 0;
                    for (let i = 0; i < list.length; i++) {
                        if (list[i]?.isFrame) floorIndex = Math.max(floorIndex, i + 1);
                    }

                    const targetIndex = Math.max(floorIndex, minCardIndex - 1);
                    if (zoneIndex > targetIndex) c.moveTo(z, targetIndex);
                });
            }
        } catch (e) {
            // Ignore stacking errors
        }

        // Frames sempre atrás do conteúdo (evita bloquear drag do mouse em imagens)
        ensureFramesBelowContents();
        stabilizePriceGroupsForPersistence(canvas.value, 'rehydrate');
        scheduleMissingProductImageRecovery();

        refreshCanvasObjects();
        canvas.value.requestRenderAll();
    } finally {
        isHistoryProcessing.value = prevHistory;
    }
}

const handleRecalculateLayout = () => {
    const zone = getCurrentZoneObject();
    if (!zone) return;
    ensureZoneSanity(zone);
    recalculateZoneLayout(zone);
    // Re-select zone and refresh snapshot after layout recalculation
    if (canvas.value) {
        try { canvas.value.setActiveObject(zone); } catch { /* ignore */ }
        canvas.value.requestRenderAll();
    }
    refreshSelectedRef();
}


</script>

<template>
  <div class="flex flex-col h-full min-h-0 min-w-0 w-full bg-background text-foreground antialiased font-sans overflow-hidden">
      
      <ProjectManager
        v-if="showProjectManager"
        :isOpen="showProjectManager" 
        @close="showProjectManager = false"
        @load="(data) => loadCanvasData(data)"
      />

      <AiImageStudioModal
        v-if="aiStudioOpen"
        v-model="aiStudioOpen"
        :uploads="aiStudioUploads"
        :initial="aiStudioOptions.initial"
        @created="handleAiStudioCreated"
      />

      <div
        v-if="showProductImageUploadPicker"
        class="fixed inset-0 z-140 bg-black/60 backdrop-blur-[1px] flex items-center justify-center p-4"
        @click.self="showProductImageUploadPicker = false; clearPendingProductImageOperation()"
      >
        <div class="w-full max-w-5xl max-h-[85vh] bg-[#1a1a1a] border border-white/10 rounded-xl shadow-2xl flex flex-col overflow-hidden">
          <div class="flex items-center justify-between px-4 py-3 border-b border-white/10">
            <div>
              <h3 class="text-sm font-semibold text-white">Selecionar do Upload</h3>
              <p class="text-[11px] text-zinc-400">
                {{ productImagePickerMode === 'replace' ? 'Substituir imagem do produto' : 'Adicionar imagem mantendo a atual' }}
              </p>
            </div>
            <button
              type="button"
              class="text-zinc-400 hover:text-white text-lg leading-none"
              @click="showProductImageUploadPicker = false; clearPendingProductImageOperation()"
            >
              ×
            </button>
          </div>

          <div class="px-4 py-3 border-b border-white/10">
            <input
              v-model="productImagePickerSearch"
              type="text"
              placeholder="Buscar imagem no upload..."
              class="w-full h-10 bg-zinc-900 border border-white/10 rounded px-3 text-sm text-white focus:outline-none focus:border-violet-500/50"
            />
          </div>

          <div class="flex-1 overflow-y-auto p-4">
            <div v-if="!filteredProductImageUploads.length" class="text-xs text-zinc-500">
              Nenhuma imagem encontrada no upload.
            </div>
            <div v-else class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
              <button
                v-for="asset in filteredProductImageUploads"
                :key="asset.id"
                type="button"
                class="bg-zinc-900 border border-white/10 rounded-lg overflow-hidden text-left hover:border-violet-500/50 transition-colors"
                @click="applyProductImageFromUploadPicker(asset)"
              >
                <div class="aspect-square">
                  <img :src="toWasabiProxyUrl(asset.url) || asset.url" class="w-full h-full object-cover" />
                </div>
                <div class="px-2 py-1.5 border-t border-white/10">
                  <p class="text-[10px] text-zinc-200 truncate">{{ asset.name || 'Sem nome' }}</p>
                </div>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Central Workspace -->
      <div class="flex flex-1 min-h-0 min-w-0 overflow-hidden relative bg-[#1a1a1a]">
          <!-- Left Sidebar (New Component) -->
          <SidebarLeft @insert-asset="insertAssetToCanvas" @insert-element="insertElementToCanvas" @open-menu="showProjectManager = true">
              <template #layers-panel>
                  <LayersPanel 
                      class="flex-1"
                      :objects="canvasObjects" 
                      :selectedId="selectedObjectId"
                      :selectedIds="selectedObjectIds"
                      @select="selectObject"
                      @toggle-visible="toggleVisible"
                      @toggle-lock="toggleLock"
                      @delete="deleteObject"
                      @move-up="id => moveLayer(id, 'up')"
                      @move-down="id => moveLayer(id, 'down')"
                      @rename="renameLayer"
                      @reorder="reorderLayerByDrag"
                      @context-menu="handleLayersContextMenu"
                  />
              </template>
          </SidebarLeft>

          <!-- Canvas Stage -->
          <main class="flex-1 min-w-0 min-h-0 relative bg-[#1a1a1a] flex items-center justify-center overflow-hidden cursor-grab active:cursor-grabbing">
              <!-- Infinite Canvas Effect (Wrapper) -->
                  <div ref="wrapperEl" class="w-full h-full min-w-0 min-h-0 relative flex items-center justify-center overflow-hidden bg-[#1a1a1a]">
                  <canvas ref="canvasEl" class="block canvas-touch-surface" @contextmenu.prevent.stop></canvas>

                  <CanvasRulers
                    :visible="viewShowRulers"
                    :canvas="canvas"
                    :wrapper-el="wrapperEl"
                    :guides="rulerGuides"
                    @create-guide="handleCreateUserGuide"
                    @update-guide="handleUpdateUserGuide"
                    @delete-guide="handleDeleteUserGuide"
                  />

                  <!-- Design loader overlay (prevents "blank canvas until click" confusion) -->
                  <div
                    v-show="showDesignLoaderOverlay"
                    class="absolute inset-0 flex items-center justify-center bg-black/40 backdrop-blur-[1px] cursor-wait"
                    style="z-index: 200;"
                    aria-live="polite"
                  >
                    <div class="px-4 py-3 rounded-lg bg-zinc-950/70 border border-white/10 shadow-xl">
                      <div class="flex items-center gap-2">
                        <div class="w-4 h-4 rounded-full border-2 border-white/20 border-t-white animate-spin"></div>
                        <p class="text-sm text-white/90">{{ designLoadMessage }}</p>
                      </div>
                      <p class="text-[11px] text-white/55 mt-1">{{ designLoadProgressLine || 'Aguarde alguns segundos.' }}</p>
                    </div>
                  </div>

                  <!-- Storage degraded banner (missing/blocked images) -->
                  <div
                    v-show="showStorageDegradedBanner"
                    class="absolute top-3 left-1/2 -translate-x-1/2"
                    style="z-index: 210;"
                  >
                    <div class="flex items-center gap-2 px-3 py-2 rounded-full bg-amber-950/60 border border-amber-300/20 text-amber-100 shadow-lg">
                      <span class="text-xs">{{ storageDegradedHint || 'Algumas imagens nao carregaram.' }}</span>
                      <button
                        type="button"
                        class="text-xs px-2 py-1 rounded-full bg-amber-200/10 hover:bg-amber-200/15 border border-amber-200/20"
                        @click="retryStorageReload"
                      >
                        Recarregar
                      </button>
                      <button
                        v-if="canRecoverLatestNonEmpty"
                        type="button"
                        class="text-xs px-2 py-1 rounded-full bg-white/5 hover:bg-white/10 border border-white/10"
                        @click="openHistoryModal"
                      >
                        Historico
                      </button>
                      <button
                        v-if="canRecoverLatestNonEmpty"
                        type="button"
                        class="text-xs px-2 py-1 rounded-full bg-red-200/10 hover:bg-red-200/15 border border-red-200/20"
                        :disabled="isRecoveringLatestNonEmpty"
                        @click="recoverLatestNonEmptyForActivePage"
                      >
                        {{ isRecoveringLatestNonEmpty ? 'Recuperando...' : 'Recuperar' }}
                      </button>
                    </div>
                  </div>

                  <ContextMenu
                    v-model="canvasContextMenu.show"
                    :x="canvasContextMenu.x"
                    :y="canvasContextMenu.y"
                    :items="canvasContextMenuItems"
                    @select="handleCanvasContextMenuSelect"
                  />

                  <ContextMenu
                    v-model="layersContextMenu.show"
                    :x="layersContextMenu.x"
                    :y="layersContextMenu.y"
                    :items="layersContextMenuItems"
                    @select="handleLayersContextMenuSelect"
                  />
                  
                  <!-- Virtual Scrollbars (Figma Style) -->
                  <div 
                    v-show="scrollV.visible" 
                    class="absolute right-1 w-1.5 bg-white/20 hover:bg-white/40 rounded-full z-50 transition-colors cursor-pointer" 
                    :style="{ top: scrollV.top + 'px', height: scrollV.height + 'px' }"
                    @mousedown="handleVerticalScrollbarDrag"
                  ></div>
                  <div 
                    v-show="scrollH.visible" 
                                        class="absolute bottom-1 h-1.5 bg-white/20 hover:bg-white/40 rounded-full z-60 transition-colors cursor-pointer" 
                    :style="{ left: scrollH.left + 'px', width: scrollH.width + 'px' }"
                    @mousedown="handleHorizontalScrollbarDrag"
                  ></div>

                  <!-- Frame Label Overlays (clickable, always visible) -->
                  <FrameLabelsOverlay
                    :labels="frameLabels"
                    @label-click="handleFrameLabelClick"
                    @label-mousedown="handleFrameLabelMouseDown"
                  />

                  <input type="file" ref="fileInput" class="hidden" @change="handleFileUpload" accept="image/*" multiple />
              </div>

              <!-- Contextual Toolbar for Vector Paths (Above Main Toolbar) -->
	              <PenContextualToolbar
	                :visible="showPenContextualToolbar"
	                :is-vector-path="!!selectedObjectRef?.isVectorPath || !!currentEditingPath?.isVectorPath"
	                :is-node-editing="isNodeEditing"
	                :can-delete-point="selectedPathNodeIndex !== null"
                @toggle-visible="selectedObjectRef && updateObjectProperty('visible', !selectedObjectRef.visible)"
                @toggle-handles="handleAction('toggle-handles')"
                @add-point="handleAction('add-path-point')"
                @delete-point="handleAction('delete-path-point')"
                @split-path="splitPath"
                @simplify-path="simplifyPath"
                @close-path="closePath"
              />

              <!-- Floating Toolbar (Figma Style) - Bottom Center -->
              <CanvasFloatingToolbar
                :is-drawing="isDrawing"
                :is-pen-mode="isPenMode"
                @select-tool="setTool('select')"
                @add-frame="addFrame"
                @add-shape="(type, options) => addShape(type as any, options as any)"
                @add-text="(variant) => addText(variant as any)"
                @toggle-pen-mode="togglePenMode"
                @toggle-drawing="toggleDrawing"
                @set-pen-width="setPenWidth"
                @add-grid-zone="addGridZone"
                @open-label-templates="showLabelTemplatesModal = true"
              />
          </main>

          <EditorRightSidebar
            :collaborators="collaborators || []"
            :current-user="currentUser"
            :show-zoom-menu="showZoomMenu"
            :current-zoom="currentZoom"
            :get-color-from-string="getColorFromString"
            :get-initial="getInitial"
            :selected-object="selectedObjectRef"
            :active-mode="activeMode"
            :page-settings="pageSettings"
            :color-styles="project.colorStyles || []"
            :product-zone="productZoneState.productZone.value"
            :product-global-styles="productZoneState.globalStyles.value"
            :label-templates="labelTemplates"
            :view-show-grid="viewShowGrid"
            :view-show-rulers="viewShowRulers"
            :view-show-guides="viewShowGuides"
            :snap-to-objects="snapToObjects"
            :snap-to-guides="snapToGuides"
            :snap-to-grid="snapToGrid"
            :grid-size="gridSize"
            @update:show-zoom-menu="showZoomMenu = $event"
            @present="startPresentation()"
            @open-ai-generate="openAiGenerationModal"
            @open-share="shareDesign"
            @zoom-50="handleZoom50"
            @zoom-100="handleZoom100"
            @zoom-200="handleZoom200"
            @zoom-400="handleZoom400"
            @zoom-fit="zoomToFit"
            @zoom-selection="handleZoomToSelection"
            @toggle-grid="toggleGrid"
            @toggle-rulers="toggleRulers"
            @toggle-guides="toggleGuides"
            @toggle-snap-objects="toggleSnapObjects"
            @toggle-snap-guides="toggleSnapGuides"
            @toggle-snap-grid="toggleSnapGrid"
            @set-grid-size="setGridSize"
            @update-property="updateObjectProperty"
            @update-smart-group="updateSmartGroup"
            @update-page-settings="updatePageSettings"
            @action="handleAction"
            @add-color-style="addColorStyle"
            @apply-color-style="applyColorStyle"
            @update-zone="handleUpdateZone"
            @update-global-styles="handleUpdateGlobalStyles"
            @apply-template-to-zone="handleApplyTemplateToZone"
            @apply-preset="handleApplyZonePreset"
            @sync-gaps="handleSyncZoneGaps"
            @recalculate-layout="handleRecalculateLayout"
            @manage-label-templates="showLabelTemplatesModal = true"
            @change-mode="(mode: 'design' | 'prototype') => activeMode = mode"
          />
      </div>

      <!-- MODALS SYSTEM (Internal Dialogs) -->
      <EditorModalsHost
        :show-save-modal="showSaveModal"
        :save-project-name="saveProjectName"
        :show-label-templates-modal="showLabelTemplatesModal"
        :label-templates="labelTemplates"
        :selected-template-id="activeZoneTemplateId()"
        :can-save-label-template-from-selection="canSaveLabelTemplateFromSelectionComputed"
        :show-a-i-modal="showAIModal"
        :ai-prompt="aiPrompt"
        :ai-reference-image-data-url="aiReferenceImageDataUrl"
        :ai-apply-mode="aiApplyMode"
        :ai-page-type="aiPageType"
        :ai-page-width="aiPageWidth"
        :ai-page-height="aiPageHeight"
        :is-processing="isProcessing"
        :show-paste-list-modal="showPasteListModal"
        :active-paste-tab="activePasteTab"
        :paste-list-text="pasteListText"
        :pasted-image="pastedImage"
        :is-analyzing-image="isAnalyzingImage"
        :show-delete-page-modal="showDeletePageModal"
        :show-product-review-modal="showProductReviewModal"
        :review-products="reviewProducts"
        :show-import-mode="!!(targetGridZone && isLikelyProductZone(targetGridZone))"
        :product-import-existing-count="productImportExistingCount"
        :import-zone-label-template-id="importZoneLabelTemplateId"
        :show-export-modal="showExportModal"
        :export-settings="exportSettings"
        :available-frames-for-export="availableFramesForExport"
        :has-exportable-selected-object="hasExportableSelectedObject"
        :available-frames-for-import="availableFramesForImport"
        :show-share-modal="showShareModal"
        :share-settings="shareSettings"
        :show-presentation-modal="showPresentationModal"
        :presentation-image="presentationImage"
        :presentation-hotspots="presentationHotspots"
        :figma-crop-active="figmaCrop.isCropActive.value"
        :crop-frame-rect="figmaCrop.cropFrameRect.value"
        :crop-frame-name="figmaCrop.cropFrameName.value"
        :crop-canvas-offset="cropCanvasOffset"
        @update:show-save-modal="showSaveModal = $event"
        @update:save-project-name="saveProjectName = $event"
        @save="saveProject"
        @update:show-label-templates-modal="showLabelTemplatesModal = $event"
        @edit-selection="beginEditSelectedLabel"
        @create-from-selection="createLabelTemplateFromSelection"
        @create-default="createDefaultLabelTemplate"
        @update-from-selection="updateLabelTemplateFromSelection"
        @insert-to-canvas="insertLabelTemplateToCanvas"
        @update-template="handleUpdateTemplateFromMiniEditor"
        @duplicate-template="duplicateLabelTemplateById"
        @delete-template="deleteLabelTemplateById"
        @apply-template-to-zone="applyTemplateToActiveZone"
        @set-template-splash-image="setTemplateSplashImage"
        @update:show-a-i-modal="showAIModal = $event"
        @update:ai-prompt="aiPrompt = $event"
        @update:ai-reference-image-data-url="aiReferenceImageDataUrl = $event"
        @update:ai-apply-mode="aiApplyMode = $event"
        @update:ai-page-type="aiPageType = $event"
        @update:ai-page-width="aiPageWidth = $event"
        @update:ai-page-height="aiPageHeight = $event"
        @generate-ai="generateFlyerWithAI"
        @update:show-paste-list-modal="showPasteListModal = $event"
        @update:active-paste-tab="activePasteTab = $event"
        @update:paste-list-text="pasteListText = $event"
        @update:pasted-image="pastedImage = $event"
        @update:is-analyzing-image="isAnalyzingImage = $event"
        @submit-paste-list="handlePasteList"
        @update:show-delete-page-modal="showDeletePageModal = $event"
        @confirm-delete-page="confirmDeletePage"
        @update:show-product-review-modal="handleProductReviewModalVisibility"
        @import-products="confirmProductImport"
        @update:show-export-modal="showExportModal = $event"
        @export="performExport"
        @update:show-share-modal="showShareModal = $event"
        @toggle-share-frame="toggleFrameSelection"
        @select-all-share-frames="selectAllFrames"
        @share="performShare"
        @update:show-presentation-modal="showPresentationModal = $event"
        @hotspot-click="handleHotspotClick"
        @update:figma-crop-active="figmaCrop.isCropActive.value = $event"
        @update:crop-frame-rect="handleCropRectUpdate"
        @crop-complete="handleCropComplete"
      />

      <div
        v-if="aiToast"
        class="fixed top-4 right-4 z-10001 px-3 py-2 rounded-lg border text-sm shadow-xl"
        :class="aiToast.type === 'error'
          ? 'bg-red-950/90 border-red-300/35 text-red-100'
          : (aiToast.type === 'success'
              ? 'bg-emerald-950/90 border-emerald-300/35 text-emerald-100'
              : 'bg-sky-950/90 border-sky-300/35 text-sky-100')"
      >
        {{ aiToast.message }}
      </div>

      <div
        v-if="isExportDownloadInProgress"
        class="fixed inset-0 z-10002 pointer-events-none flex items-center justify-center"
      >
        <div class="flex items-center gap-3 rounded-xl border border-violet-400/35 bg-zinc-950/90 px-4 py-3 shadow-2xl">
          <span class="inline-block h-4 w-4 rounded-full border-2 border-violet-300/30 border-t-violet-300 animate-spin" />
          <div class="text-left">
            <p class="text-sm font-semibold text-violet-100">{{ exportDownloadStatus }}</p>
            <p class="text-[11px] text-violet-200/75">Preparando download...</p>
          </div>
        </div>
      </div>

      <!-- Page History / Restore Modal -->
      <div v-if="showHistoryModal" class="fixed inset-0 z-9999">
        <div class="absolute inset-0 bg-black/60" @click="showHistoryModal = false"></div>
        <div class="absolute left-1/2 top-1/2 w-[min(720px,92vw)] -translate-x-1/2 -translate-y-1/2 rounded-xl border border-white/10 bg-zinc-950/90 shadow-2xl">
          <div class="flex items-center justify-between px-4 py-3 border-b border-white/10">
            <div>
              <p class="text-sm text-white/90">Historico da pagina</p>
              <p class="text-[11px] text-white/55">Escolha uma versao para restaurar. Total: {{ historyItems.length }}</p>
            </div>
            <button type="button" class="text-white/70 hover:text-white text-lg leading-none" @click="showHistoryModal = false">×</button>
          </div>
          <div class="px-4 py-3">
            <div v-if="historyLoading" class="text-sm text-white/70">Carregando...</div>
            <div v-else-if="historyError" class="text-sm text-red-300">{{ historyError }}</div>
            <div v-else-if="!historyItems.length" class="text-sm text-white/60">Nenhuma versao encontrada.</div>
            <div v-else class="max-h-[60vh] overflow-auto divide-y divide-white/10">
              <div v-for="it in historyItems" :key="`${it.source}:${it.key}:${it.versionId || ''}:${it.lastModified}`" class="py-3 flex items-center justify-between gap-3">
                <div class="min-w-0">
                  <p class="text-xs text-white/80 truncate">
                    <span class="font-medium">{{ it.source === 'version' ? 'Versao' : 'Snapshot' }}</span>
                    <span class="text-white/40"> · </span>
                    <span class="text-white/60">{{ formatHistoryDateTime(it.lastModified) }}</span>
                  </p>
                  <p class="text-[11px] text-white/50 truncate">
                    {{ it.objectCount != null ? `${it.objectCount} objetos` : '' }}
                    <span v-if="it.size != null" class="text-white/40"> · {{ Math.max(1, Math.round((it.size || 0) / 1024)) }} KB</span>
                  </p>
                </div>
                <button
                  type="button"
                  class="shrink-0 text-xs px-3 py-1.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/10 disabled:opacity-50"
                  :disabled="!!restoringHistoryKey"
                  @click="restoreFromHistoryItem(it as any)"
                >
                  {{ restoringHistoryKey === getHistoryRestoreKey(it as any) ? 'Restaurando...' : 'Restaurar' }}
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

  </div>
</template>

<style scoped>
/* Ensure canvas container handles canvas element correctly */
 :deep(.canvas-container) {
     background-color: transparent !important;
     box-shadow: 0 0 40px rgba(0,0,0,0.5); /* Figma-like page shadow */
 }
main {
     background-color: #1a1a1a !important;
 }

.canvas-touch-surface {
    touch-action: none;
}

/* Keep floating toolbar from "jumping" near bottom (safe area / scrollbars) */
.floating-toolbar {
    /* closer to the bottom scrollbar (which sits at bottom-1) */
    bottom: calc(1.75rem + env(safe-area-inset-bottom, 0px));
}
 
 /* Figma-like Scrollbar */
 .custom-scrollbar::-webkit-scrollbar {
     width: 10px;
     height: 10px;
 }
 .custom-scrollbar::-webkit-scrollbar-track {
     background: #1e1e1e;
     border-left: 1px solid #333;
 }
 .custom-scrollbar::-webkit-scrollbar-thumb {
     background: #444;
     border-radius: 5px;
     border: 2px solid #1e1e1e; /* Creates padding effect */
 }
 .custom-scrollbar::-webkit-scrollbar-thumb:hover {
     background: #666;
 }
 .custom-scrollbar::-webkit-scrollbar-corner {
     background: #1e1e1e;
 }
</style>
